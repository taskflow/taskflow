<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>tf::FlowBuilder class | Taskflow QuickStart</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark+documentation.compiled.css" />
  <link rel="icon" href="favicon.ico" type="image/x-icon" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <span id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">
        <a href="https://taskflow.github.io"><img src="taskflow_logo.png" alt="" />Taskflow</a> <span class="m-breadcrumb">|</span> <a href="index.html" class="m-thin">QuickStart</a>
      </span>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="pages.html">Handbook</a></li>
            <li><a href="namespaces.html">Namespaces</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          <span class="m-breadcrumb"><a href="namespacetf.html">tf</a>::<wbr/></span>FlowBuilder <span class="m-thin">class</span>
        </h1>
        <p>building methods of a task dependency graph</p>
        <div class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li>
              Reference
              <ul>
                <li><a href="#derived-classes">Derived classes</a></li>
                <li><a href="#typeless-methods">Constructors, destructors, conversion operators</a></li>
                <li><a href="#pub-methods">Public functions</a></li>
                <li><a href="#pro-attribs">Protected variables</a></li>
              </ul>
            </li>
          </ul>
        </div>
        <section id="derived-classes">
          <h2><a href="#derived-classes">Derived classes</a></h2>
          <dl class="m-doc">
            <dt>
              class <a href="classtf_1_1Subflow.html" class="m-doc">Subflow</a>
            </dt>
            <dd>class to construct a subflow graph from the execution of a dynamic task</dd>
            <dt>
              class <a href="classtf_1_1Taskflow.html" class="m-doc">Taskflow</a>
            </dt>
            <dd>main entry to create a task dependency graph</dd>
          </dl>
        </section>
        <section id="typeless-methods">
          <h2><a href="#typeless-methods">Constructors, destructors, conversion operators</a></h2>
          <dl class="m-doc">
            <dt id="a67d023d5493da1594a1d2eaea89da179">
              <span class="m-doc-wrap-bumper"><a href="#a67d023d5493da1594a1d2eaea89da179" class="m-doc-self">FlowBuilder</a>(</span><span class="m-doc-wrap">Graph&amp; graph) <span class="m-label m-flat m-warning">protected</span></span>
            </dt>
            <dd>constructs a flow builder with a graph</dd>
          </dl>
        </section>
        <section id="pub-methods">
          <h2><a href="#pub-methods">Public functions</a></h2>
          <dl class="m-doc">
            <dt>
              <div class="m-doc-template">template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a11fc9c98eb3a0d3a9aa55598b1f4d614" class="m-doc">is_<wbr />static_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a static task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a1eea7593f25ab348cfb656dbdf4e5b05" class="m-doc">is_<wbr />dynamic_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a dynamic task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a00ca2fc2de0e679a7d9b8039340343df" class="m-doc">is_<wbr />condition_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a condition task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename... C, std::enable_if_t&lt;(sizeof...(C)&gt;1), void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a1f6118326ad434f6c839007a1a79fe1b" class="m-doc">emplace</a>(</span><span class="m-doc-wrap">C &amp;&amp; ... callables) -&gt; auto</span>
            </dt>
            <dd>creates multiple tasks from a list of callable objects</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a0a01192f4f92c15380a4f259e2fec2d9" class="m-doc">composed_of</a>(</span><span class="m-doc-wrap"><a href="classtf_1_1Taskflow.html" class="m-doc">Taskflow</a>&amp; taskflow) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a module task from a taskflow</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#acab0b4ac82260f47fdb36a3244ee3aaf" class="m-doc">placeholder</a>(</span><span class="m-doc-wrap">) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a placeholder task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#adb8433555d8cdc0b3c5d95e8d51a90f0" class="m-doc">is_<wbr />cudaflow_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a cudaFlow task on the caller&#x27;s GPU device context</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename C, typename D, std::enable_if_t&lt;<a href="namespacetf.html#adb8433555d8cdc0b3c5d95e8d51a90f0" class="m-doc">is_<wbr />cudaflow_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#afdf47fd1a358fb64f8c1b89e2a393169" class="m-doc">emplace_on</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable,
              D&amp;&amp; device) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>creates a cudaFlow task on the given device</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#a90f3d9b9d6fcf4df8e7d7878dfdd130d" class="m-doc">linearize</a>(</span><span class="m-doc-wrap"><a href="http://en.cppreference.com/w/cpp/container/vector.html" class="m-doc-external">std::<wbr />vector</a>&lt;<a href="classtf_1_1Task.html" class="m-doc">Task</a>&gt;&amp; tasks)</span>
            </dt>
            <dd>adds adjacent dependency links to a linear list of tasks</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#a4ec89b554d15ad5fb96f4fdb10dbbb16" class="m-doc">linearize</a>(</span><span class="m-doc-wrap"><a href="http://en.cppreference.com/w/cpp/utility/initializer_list.html" class="m-doc-external">std::<wbr />initializer_list</a>&lt;<a href="classtf_1_1Task.html" class="m-doc">Task</a>&gt; tasks)</span>
            </dt>
            <dd>adds adjacent dependency links to a linear list of tasks</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename C&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a564252001be679600b20ca9ed9920f6a" class="m-doc">for_each</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              C&amp;&amp; callable) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a STL-styled parallel-for task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename C, typename H = size_t&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a1a294c4fa23d74b82e581b8cfd33acdf" class="m-doc">for_each_guided</a>(</span><span class="m-doc-wrap">B&amp;&amp; beg,
              E&amp;&amp; end,
              C&amp;&amp; callable,
              H&amp;&amp; chunk_size = 1) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a STL-styled parallel-for task using the guided partition algorithm</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename C, typename H = size_t&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a5c044a80450742bf6927d0c343c23853" class="m-doc">for_each_dynamic</a>(</span><span class="m-doc-wrap">B&amp;&amp; beg,
              E&amp;&amp; end,
              C&amp;&amp; callable,
              H&amp;&amp; chunk_size = 1) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a STL-styled parallel-for task using the dynamic partition algorithm</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename C, typename H = size_t&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a0af7e250c4ad1ae98bf6e0249b98589f" class="m-doc">for_each_static</a>(</span><span class="m-doc-wrap">B&amp;&amp; beg,
              E&amp;&amp; end,
              C&amp;&amp; callable,
              H&amp;&amp; chunk_size = 0) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a STL-styled parallel-for task using the dynamic partition algorithm</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename S, typename C&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#ab8417b211b18bb1e0f45a049331f084d" class="m-doc">for_each_index</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              S&amp;&amp; step,
              C&amp;&amp; callable) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs an index-based parallel-for task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename S, typename C, typename H = size_t&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a942449afd25e656b9e14cb526cbd8ad2" class="m-doc">for_each_index_guided</a>(</span><span class="m-doc-wrap">B&amp;&amp; beg,
              E&amp;&amp; end,
              S&amp;&amp; step,
              C&amp;&amp; callable,
              H&amp;&amp; chunk_size = 1) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs an index-based parallel-for task using the guided partition algorithm.</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename S, typename C, typename H = size_t&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a930d0343226874d1d40b9e230cccdd52" class="m-doc">for_each_index_dynamic</a>(</span><span class="m-doc-wrap">B&amp;&amp; beg,
              E&amp;&amp; end,
              S&amp;&amp; step,
              C&amp;&amp; callable,
              H&amp;&amp; chunk_size = 1) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs an index-based parallel-for task using the dynamic partition algorithm.</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename S, typename C, typename H = size_t&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a71f204c670ca5857e5527d6000ba73c4" class="m-doc">for_each_index_static</a>(</span><span class="m-doc-wrap">B&amp;&amp; beg,
              E&amp;&amp; end,
              S&amp;&amp; step,
              C&amp;&amp; callable,
              H&amp;&amp; chunk_size = 0) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs an index-based parallel-for task using the static partition algorithm.</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename T, typename O&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#ad999cd75045db225a42d5881d6db1223" class="m-doc">reduce</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              T&amp; init,
              O&amp;&amp; bop) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a STL-styled parallel-reduce task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename T, typename O, typename H = size_t&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a10f13b39b02038c6850aca787923d668" class="m-doc">reduce_guided</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              T&amp; init,
              O&amp;&amp; bop,
              H&amp;&amp; chunk_size = 1) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a STL-styled parallel-reduce task using the guided partition algorithm</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename T, typename O, typename H = size_t&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a83ec799606b7526787761acf27885b00" class="m-doc">reduce_dynamic</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              T&amp; init,
              O&amp;&amp; bop,
              H&amp;&amp; chunk_size = 1) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a STL-styled parallel-reduce task using the dynamic partition algorithm</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename T, typename O, typename H = size_t&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a54e36c916ae7dd88bd079d3fd49119f9" class="m-doc">reduce_static</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              T&amp; init,
              O&amp;&amp; bop,
              H&amp;&amp; chunk_size = 0) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a STL-styled parallel-reduce task using the static partition algorithm</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename T, typename BOP, typename UOP&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#ad8d03524f15292610ebee63d53b89579" class="m-doc">transform_reduce</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              T&amp; init,
              BOP&amp;&amp; bop,
              UOP&amp;&amp; uop) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a STL-styled parallel transform-reduce task</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename T, typename BOP, typename UOP, typename H = size_t&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#aa102a40672a331643944cb17c2377118" class="m-doc">transform_reduce_guided</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              T&amp; init,
              BOP&amp;&amp; bop,
              UOP&amp;&amp; uop,
              H&amp;&amp; chunk_size = 1) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a STL-styled parallel transform-reduce task using the guided partition algorithm</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename T, typename BOP, typename UOP, typename H = size_t&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a562e253028680b61de95e305c0224d91" class="m-doc">transform_reduce_static</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              T&amp; init,
              BOP&amp;&amp; bop,
              UOP&amp;&amp; uop,
              H&amp;&amp; chunk_size = 0) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a STL-styled parallel transform-reduce task using the static partition algorithm</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename T, typename BOP, typename UOP, typename H = size_t&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a6fb87774919f4a570ac505cdcda48249" class="m-doc">transform_reduce_dynamic</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              T&amp; init,
              BOP&amp;&amp; bop,
              UOP&amp;&amp; uop,
              H&amp;&amp; chunk_size = 1) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a STL-styled parallel transform-reduce task using the dynamic partition algorithm</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E, typename C&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#af4848ab51fa3bf5525af58e2440b01c1" class="m-doc">sort</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              C&amp;&amp; cmp) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a dynamic task to perform STL-styled parallel sort</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename B, typename E&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a559afa5066782bc6c38738260e3d4c2e" class="m-doc">sort</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last) -&gt; <a href="classtf_1_1Task.html" class="m-doc">Task</a></span>
            </dt>
            <dd>constructs a dynamic task to perform STL-styled parallel sort using the <code>std::less&lt;T&gt;</code> comparator, where <code>T</code> is the element type</dd>
          </dl>
        </section>
        <section id="pro-attribs">
          <h2><a href="#pro-attribs">Protected variables</a></h2>
          <dl class="m-doc">
            <dt id="a9404a57d9d37a4d49d20b686e4e5f68f">
              Graph&amp; <a href="#a9404a57d9d37a4d49d20b686e4e5f68f" class="m-doc-self">_graph</a>
            </dt>
            <dd>associated graph object</dd>
          </dl>
        </section>
        <section>
          <h2>Function documentation</h2>
          <section class="m-doc-details" id="a60d7a666cab71ecfa3010b2efb0d6b57"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a11fc9c98eb3a0d3a9aa55598b1f4d614" class="m-doc">is_<wbr />static_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc-self">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable)</span></span>
            </h3>
            <p>creates a static task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable type constructible from std::function&lt;void()&gt;</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>callable</td>
                  <td>callable to construct a static task</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The following example creates a static task.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">static_task</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){});</span></pre><p>Please refer to <a href="StaticTasking.html" class="m-doc">Static Tasking</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a60d7a666cab71ecfa3010b2efb0d6b57"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a1eea7593f25ab348cfb656dbdf4e5b05" class="m-doc">is_<wbr />dynamic_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc-self">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable)</span></span>
            </h3>
            <p>creates a dynamic task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable type constructible from std::function&lt;void(tf::Subflow&amp;)&gt;</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>callable</td>
                  <td>callable to construct a dynamic task</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The following example creates a dynamic task (<a href="classtf_1_1Subflow.html" class="m-doc">tf::<wbr />Subflow</a>) that spawns two static tasks.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">dynamic_task</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](</span><span class="n">tf</span><span class="o">::</span><span class="n">Subflow</span><span class="o">&amp;</span> <span class="n">sf</span><span class="p">){</span>
  <span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">static_task1</span> <span class="o">=</span> <span class="n">sf</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){});</span>
  <span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">static_task2</span> <span class="o">=</span> <span class="n">sf</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](){});</span>
<span class="p">});</span></pre><p>Please refer to <a href="DynamicTasking.html" class="m-doc">Dynamic Tasking</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a60d7a666cab71ecfa3010b2efb0d6b57"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#a00ca2fc2de0e679a7d9b8039340343df" class="m-doc">is_<wbr />condition_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc-self">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable)</span></span>
            </h3>
            <p>creates a condition task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable type constructible from std::function&lt;int()&gt;</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>callable</td>
                  <td>callable to construct a condition task</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The following example creates an if-else block using one condition task and three static tasks.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Taskflow</span> <span class="n">taskflow</span><span class="p">;</span>

<span class="k">auto</span> <span class="p">[</span><span class="n">init</span><span class="p">,</span> <span class="n">cond</span><span class="p">,</span> <span class="n">yes</span><span class="p">,</span> <span class="n">no</span><span class="p">]</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span>
 <span class="p">[]</span> <span class="p">()</span> <span class="p">{</span> <span class="p">},</span>
 <span class="p">[]</span> <span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">},</span>
 <span class="p">[]</span> <span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;yes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">},</span>
 <span class="p">[]</span> <span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;no</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">);</span>

<span class="c1">// executes yes if cond returns 0, or no if cond returns 1</span>
<span class="n">cond</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">yes</span><span class="p">,</span> <span class="n">no</span><span class="p">);</span>
<span class="n">cond</span><span class="p">.</span><span class="n">succeed</span><span class="p">(</span><span class="n">init</span><span class="p">);</span></pre><p>Please refer to <a href="ConditionalTasking.html" class="m-doc">Conditional Tasking</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a1f6118326ad434f6c839007a1a79fe1b"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename... C, std::enable_if_t&lt;(sizeof...(C)&gt;1), void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper">auto tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a1f6118326ad434f6c839007a1a79fe1b" class="m-doc-self">emplace</a>(</span><span class="m-doc-wrap">C &amp;&amp; ... callables)</span></span>
            </h3>
            <p>creates multiple tasks from a list of callable objects</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable types</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>callables</td>
                  <td>one or multiple callable objects constructible from each task category</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The method returns a tuple of tasks each corresponding to the given callable target. You can use structured binding to get the return tasks one by one. The following example creates four static tasks and assign them to <code>A</code>, <code>B</code>, <code>C</code>, and <code>D</code> using structured binding.</p><pre class="m-code"><span class="k">auto</span> <span class="p">[</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">D</span><span class="p">]</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span>
  <span class="p">[]</span> <span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;A&quot;</span><span class="p">;</span> <span class="p">},</span>
  <span class="p">[]</span> <span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;B&quot;</span><span class="p">;</span> <span class="p">},</span>
  <span class="p">[]</span> <span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;C&quot;</span><span class="p">;</span> <span class="p">},</span>
  <span class="p">[]</span> <span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;D&quot;</span><span class="p">;</span> <span class="p">}</span>
<span class="p">);</span></pre>
          </div></section>
          <section class="m-doc-details" id="a0a01192f4f92c15380a4f259e2fec2d9"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a0a01192f4f92c15380a4f259e2fec2d9" class="m-doc-self">composed_of</a>(</span><span class="m-doc-wrap"><a href="classtf_1_1Taskflow.html" class="m-doc">Taskflow</a>&amp; taskflow)</span></span>
            </h3>
            <p>creates a module task from a taskflow</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">taskflow</td>
                  <td>a taskflow object for the module</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>Please refer to <a href="ComposableTasking.html" class="m-doc">Composable Tasking</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="acab0b4ac82260f47fdb36a3244ee3aaf"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#acab0b4ac82260f47fdb36a3244ee3aaf" class="m-doc-self">placeholder</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>creates a placeholder task</p>
            <table class="m-table m-fullwidth m-flat">
              <tfoot>
                <tr>
                  <th style="width: 1%">Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>A placeholder task maps to a node in the taskflow graph, but it does not have any callable work assigned yet. A placeholder task is different from an empty task handle that does not point to any node in a graph.</p><pre class="m-code"><span class="c1">// create a placeholder task with no callable target assigned</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">placeholder</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">placeholder</span><span class="p">();</span> 
<span class="n">assert</span><span class="p">(</span><span class="n">placeholder</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">==</span> <span class="nb">false</span> <span class="o">&amp;&amp;</span> <span class="n">placeholder</span><span class="p">.</span><span class="n">has_work</span><span class="p">()</span> <span class="o">==</span> <span class="nb">false</span><span class="p">);</span>

<span class="c1">// create an empty task handle</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">task</span><span class="p">;</span>
<span class="n">assert</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">==</span> <span class="nb">true</span><span class="p">);</span>

<span class="c1">// assign the task handle to the placeholder task</span>
<span class="n">task</span> <span class="o">=</span> <span class="n">placeholder</span><span class="p">;</span>
<span class="n">assert</span><span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">==</span> <span class="nb">false</span> <span class="o">&amp;&amp;</span> <span class="n">task</span><span class="p">.</span><span class="n">has_work</span><span class="p">()</span> <span class="o">==</span> <span class="nb">false</span><span class="p">);</span></pre>
          </div></section>
          <section class="m-doc-details" id="a60d7a666cab71ecfa3010b2efb0d6b57"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename C, std::enable_if_t&lt;<a href="namespacetf.html#adb8433555d8cdc0b3c5d95e8d51a90f0" class="m-doc">is_<wbr />cudaflow_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a60d7a666cab71ecfa3010b2efb0d6b57" class="m-doc-self">emplace</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable)</span></span>
            </h3>
            <p>creates a cudaFlow task on the caller&#x27;s GPU device context</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable type constructible from <code>std::function&lt;void(tf::cudaFlow&amp;)&gt;</code></td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>This method is equivalent to calling tf::FlowBuilder::emplace_on(callable, d) where <code>d</code> is the caller&#x27;s device context. The following example creates a cudaFlow of two kernel tasks, <code>task1</code> and <code>task2</code>, where <code>task1</code> runs before <code>task2</code>.</p><pre class="m-code"><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">cudaFlow</span><span class="o">&amp;</span> <span class="n">cf</span><span class="p">){</span>
  <span class="c1">// create two kernel tasks</span>
  <span class="n">tf</span><span class="o">::</span><span class="n">cudaTask</span> <span class="n">task1</span> <span class="o">=</span> <span class="n">cf</span><span class="p">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">grid1</span><span class="p">,</span> <span class="n">block1</span><span class="p">,</span> <span class="n">shm1</span><span class="p">,</span> <span class="n">kernel1</span><span class="p">,</span> <span class="n">args1</span><span class="p">);</span>
  <span class="n">tf</span><span class="o">::</span><span class="n">cudaTask</span> <span class="n">task2</span> <span class="o">=</span> <span class="n">cf</span><span class="p">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">grid2</span><span class="p">,</span> <span class="n">block2</span><span class="p">,</span> <span class="n">shm2</span><span class="p">,</span> <span class="n">kernel2</span><span class="p">,</span> <span class="n">args2</span><span class="p">);</span>

  <span class="c1">// kernel1 runs before kernel2</span>
  <span class="n">task1</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">task2</span><span class="p">);</span>
<span class="p">});</span></pre><p>Please refer to <a href="GPUTaskingcudaFlow.html" class="m-doc">GPU Tasking (cudaFlow)</a> and <a href="GPUTaskingcudaFlowCapturer.html" class="m-doc">GPU Tasking (cudaFlowCapturer)</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="afdf47fd1a358fb64f8c1b89e2a393169"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename C, typename D, std::enable_if_t&lt;<a href="namespacetf.html#adb8433555d8cdc0b3c5d95e8d51a90f0" class="m-doc">is_<wbr />cudaflow_<wbr />task_<wbr />v</a>&lt;C&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#afdf47fd1a358fb64f8c1b89e2a393169" class="m-doc-self">emplace_on</a>(</span><span class="m-doc-wrap">C&amp;&amp; callable,
              D&amp;&amp; device)</span></span>
            </h3>
            <p>creates a cudaFlow task on the given device</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">C</td>
                  <td>callable type constructible from std::function&lt;void(tf::cudaFlow&amp;)&gt;</td>
                </tr>
                <tr>
                  <td>D</td>
                  <td>device type, either <code>int</code> or <code>std::ref&lt;int&gt;</code> (stateful)</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The following example creates a cudaFlow of two kernel tasks, <code>task1</code> and <code>task2</code> on GPU <code>2</code>, where <code>task1</code> runs before <code>task2</code></p><pre class="m-code"><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace_on</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">cudaFlow</span><span class="o">&amp;</span> <span class="n">cf</span><span class="p">){</span>
  <span class="c1">// create two kernel tasks</span>
  <span class="n">tf</span><span class="o">::</span><span class="n">cudaTask</span> <span class="n">task1</span> <span class="o">=</span> <span class="n">cf</span><span class="p">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">grid1</span><span class="p">,</span> <span class="n">block1</span><span class="p">,</span> <span class="n">shm1</span><span class="p">,</span> <span class="n">kernel1</span><span class="p">,</span> <span class="n">args1</span><span class="p">);</span>
  <span class="n">tf</span><span class="o">::</span><span class="n">cudaTask</span> <span class="n">task2</span> <span class="o">=</span> <span class="n">cf</span><span class="p">.</span><span class="n">kernel</span><span class="p">(</span><span class="n">grid2</span><span class="p">,</span> <span class="n">block2</span><span class="p">,</span> <span class="n">shm2</span><span class="p">,</span> <span class="n">kernel2</span><span class="p">,</span> <span class="n">args2</span><span class="p">);</span>

  <span class="c1">// kernel1 runs before kernel2</span>
  <span class="n">task1</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">task2</span><span class="p">);</span>
<span class="p">},</span> <span class="mi">2</span><span class="p">);</span></pre>
          </div></section>
          <section class="m-doc-details" id="a90f3d9b9d6fcf4df8e7d7878dfdd130d"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a90f3d9b9d6fcf4df8e7d7878dfdd130d" class="m-doc-self">linearize</a>(</span><span class="m-doc-wrap"><a href="http://en.cppreference.com/w/cpp/container/vector.html" class="m-doc-external">std::<wbr />vector</a>&lt;<a href="classtf_1_1Task.html" class="m-doc">Task</a>&gt;&amp; tasks)</span></span>
            </h3>
            <p>adds adjacent dependency links to a linear list of tasks</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">tasks</td>
                  <td>a vector of tasks</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-doc-details" id="a4ec89b554d15ad5fb96f4fdb10dbbb16"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a4ec89b554d15ad5fb96f4fdb10dbbb16" class="m-doc-self">linearize</a>(</span><span class="m-doc-wrap"><a href="http://en.cppreference.com/w/cpp/utility/initializer_list.html" class="m-doc-external">std::<wbr />initializer_list</a>&lt;<a href="classtf_1_1Task.html" class="m-doc">Task</a>&gt; tasks)</span></span>
            </h3>
            <p>adds adjacent dependency links to a linear list of tasks</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">tasks</td>
                  <td>an initializer list of tasks</td>
                </tr>
              </tbody>
            </table>
          </div></section>
          <section class="m-doc-details" id="a564252001be679600b20ca9ed9920f6a"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename C&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a564252001be679600b20ca9ed9920f6a" class="m-doc-self">for_each</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              C&amp;&amp; callable)</span></span>
            </h3>
            <p>constructs a STL-styled parallel-for task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>callable type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
                <tr>
                  <td>callable</td>
                  <td>a callable object to apply to the dereferenced iterator</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow that applies the callable object to each object obtained by dereferencing every iterator in the range <code>[first, last)</code>. By default, we employ the guided partition algorithm with chunk size equal to one. This method is equivalent to the parallel execution of the following loop:</p><pre class="m-code"><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">itr</span><span class="o">=</span><span class="n">first</span><span class="p">;</span> <span class="n">itr</span><span class="o">!=</span><span class="n">last</span><span class="p">;</span> <span class="n">itr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">callable</span><span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">);</span>
<span class="p">}</span></pre><p>Arguments templated to enable stateful passing using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>. The callable needs to take a single argument of the dereferenced iterator type.</p><p>Please refer to <a href="ParallelIterations.html" class="m-doc">Parallel Iterations</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a1a294c4fa23d74b82e581b8cfd33acdf"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename C, typename H = size_t&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a1a294c4fa23d74b82e581b8cfd33acdf" class="m-doc-self">for_each_guided</a>(</span><span class="m-doc-wrap">B&amp;&amp; beg,
              E&amp;&amp; end,
              C&amp;&amp; callable,
              H&amp;&amp; chunk_size = 1)</span></span>
            </h3>
            <p>constructs a STL-styled parallel-for task using the guided partition algorithm</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>H</td>
                  <td>chunk size type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>beg</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>end</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
                <tr>
                  <td>callable</td>
                  <td>a callable object to apply to the dereferenced iterator</td>
                </tr>
                <tr>
                  <td>chunk_size</td>
                  <td>chunk size</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow that applies the callable object to each object obtained by dereferencing every iterator in the range <code>[beg, end)</code>. The runtime partitions the range into chunks of the given chunk size, where each chunk is processed by a worker.</p><p>Arguments are templated to enable stateful passing using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>. The callable needs to take a single argument of the dereferenced iterator type.</p><p>Please refer to <a href="ParallelIterations.html" class="m-doc">Parallel Iterations</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a5c044a80450742bf6927d0c343c23853"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename C, typename H = size_t&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a5c044a80450742bf6927d0c343c23853" class="m-doc-self">for_each_dynamic</a>(</span><span class="m-doc-wrap">B&amp;&amp; beg,
              E&amp;&amp; end,
              C&amp;&amp; callable,
              H&amp;&amp; chunk_size = 1)</span></span>
            </h3>
            <p>constructs a STL-styled parallel-for task using the dynamic partition algorithm</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>H</td>
                  <td>chunk size type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>beg</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>end</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
                <tr>
                  <td>callable</td>
                  <td>a callable object to apply to the dereferenced iterator</td>
                </tr>
                <tr>
                  <td>chunk_size</td>
                  <td>chunk size</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow that applies the callable object to each object obtained by dereferencing every iterator in the range <code>[beg, end)</code>. The runtime partitions the range into chunks of the given chunk size, where each chunk is processed by a worker.</p><p>Arguments are templated to enable stateful passing using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>. The callable needs to take a single argument of the dereferenced iterator type.</p><p>Please refer to <a href="ParallelIterations.html" class="m-doc">Parallel Iterations</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a0af7e250c4ad1ae98bf6e0249b98589f"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename C, typename H = size_t&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a0af7e250c4ad1ae98bf6e0249b98589f" class="m-doc-self">for_each_static</a>(</span><span class="m-doc-wrap">B&amp;&amp; beg,
              E&amp;&amp; end,
              C&amp;&amp; callable,
              H&amp;&amp; chunk_size = 0)</span></span>
            </h3>
            <p>constructs a STL-styled parallel-for task using the dynamic partition algorithm</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>H</td>
                  <td>chunk size type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>beg</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>end</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
                <tr>
                  <td>callable</td>
                  <td>a callable object to apply to the dereferenced iterator</td>
                </tr>
                <tr>
                  <td>chunk_size</td>
                  <td>chunk size</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow that applies the callable object to each object obtained by dereferencing every iterator in the range <code>[beg, end)</code>. The runtime partitions the range into chunks of the given chunk size, where each chunk is processed by a worker. When the given chunk size is zero, the runtime distributes the work evenly across workers.</p><p>Arguments are templated to enable stateful passing using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>. The callable needs to take a single argument of the dereferenced iterator type.</p><p>Please refer to <a href="ParallelIterations.html" class="m-doc">Parallel Iterations</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="ab8417b211b18bb1e0f45a049331f084d"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename S, typename C&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ab8417b211b18bb1e0f45a049331f084d" class="m-doc-self">for_each_index</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              S&amp;&amp; step,
              C&amp;&amp; callable)</span></span>
            </h3>
            <p>constructs an index-based parallel-for task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning index type (must be integral)</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending index type (must be integral)</td>
                </tr>
                <tr>
                  <td>S</td>
                  <td>step type (must be integral)</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>callable type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>index of the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>index of the end (exclusive)</td>
                </tr>
                <tr>
                  <td>step</td>
                  <td>step size</td>
                </tr>
                <tr>
                  <td>callable</td>
                  <td>a callable object to apply to each valid index</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow that applies the callable object to each index in the range <code>[first, last)</code> with the step size. By default, we employ the guided partition algorithm with chunk size equal to one.</p><p>This method is equivalent to the parallel execution of the following loop:</p><pre class="m-code"><span class="c1">// case 1: step size is positive</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="n">first</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">last</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">step</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">callable</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// case 2: step size is negative</span>
<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">i</span><span class="o">=</span><span class="n">first</span><span class="p">,</span> <span class="n">i</span><span class="o">&gt;</span><span class="n">last</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="n">step</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">callable</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="p">}</span></pre><p>Arguments are templated to enable stateful passing using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>. The callable needs to take a single argument of the integral index type.</p><p>Please refer to <a href="ParallelIterations.html" class="m-doc">Parallel Iterations</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a942449afd25e656b9e14cb526cbd8ad2"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename S, typename C, typename H = size_t&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a942449afd25e656b9e14cb526cbd8ad2" class="m-doc-self">for_each_index_guided</a>(</span><span class="m-doc-wrap">B&amp;&amp; beg,
              E&amp;&amp; end,
              S&amp;&amp; step,
              C&amp;&amp; callable,
              H&amp;&amp; chunk_size = 1)</span></span>
            </h3>
            <p>constructs an index-based parallel-for task using the guided partition algorithm.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning index type (must be integral)</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending index type (must be integral)</td>
                </tr>
                <tr>
                  <td>S</td>
                  <td>step type (must be integral)</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>H</td>
                  <td>chunk size type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>beg</td>
                  <td>index of the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>end</td>
                  <td>index of the end (exclusive)</td>
                </tr>
                <tr>
                  <td>step</td>
                  <td>step size</td>
                </tr>
                <tr>
                  <td>callable</td>
                  <td>a callable object to apply to each valid index</td>
                </tr>
                <tr>
                  <td>chunk_size</td>
                  <td>chunk size (default 1)</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow that applies the callable object to each index in the range <code>[beg, end)</code> with the step size. The runtime partitions the range into chunks of the given size, where each chunk is processed by a worker.</p><p>Arguments are templated to enable stateful passing using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>. The callable needs to take a single argument of the integral index type.</p><p>Please refer to <a href="ParallelIterations.html" class="m-doc">Parallel Iterations</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a930d0343226874d1d40b9e230cccdd52"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename S, typename C, typename H = size_t&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a930d0343226874d1d40b9e230cccdd52" class="m-doc-self">for_each_index_dynamic</a>(</span><span class="m-doc-wrap">B&amp;&amp; beg,
              E&amp;&amp; end,
              S&amp;&amp; step,
              C&amp;&amp; callable,
              H&amp;&amp; chunk_size = 1)</span></span>
            </h3>
            <p>constructs an index-based parallel-for task using the dynamic partition algorithm.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning index type (must be integral)</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending index type (must be integral)</td>
                </tr>
                <tr>
                  <td>S</td>
                  <td>step type (must be integral)</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>H</td>
                  <td>chunk size type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>beg</td>
                  <td>index of the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>end</td>
                  <td>index of the end (exclusive)</td>
                </tr>
                <tr>
                  <td>step</td>
                  <td>step size</td>
                </tr>
                <tr>
                  <td>callable</td>
                  <td>a callable object to apply to each valid index</td>
                </tr>
                <tr>
                  <td>chunk_size</td>
                  <td>chunk size (default 1)</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow that applies the callable object to each index in the range <code>[beg, end)</code> with the step size. The runtime partitions the range into chunks of the given size, where each chunk is processed by a worker.</p><p>Arguments are templated to enable stateful passing using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>. The callable needs to take a single argument of the integral index type.</p><p>Please refer to <a href="ParallelIterations.html" class="m-doc">Parallel Iterations</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a71f204c670ca5857e5527d6000ba73c4"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename S, typename C, typename H = size_t&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a71f204c670ca5857e5527d6000ba73c4" class="m-doc-self">for_each_index_static</a>(</span><span class="m-doc-wrap">B&amp;&amp; beg,
              E&amp;&amp; end,
              S&amp;&amp; step,
              C&amp;&amp; callable,
              H&amp;&amp; chunk_size = 0)</span></span>
            </h3>
            <p>constructs an index-based parallel-for task using the static partition algorithm.</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning index type (must be integral)</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending index type (must be integral)</td>
                </tr>
                <tr>
                  <td>S</td>
                  <td>step type (must be integral)</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>H</td>
                  <td>chunk size type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>beg</td>
                  <td>index of the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>end</td>
                  <td>index of the end (exclusive)</td>
                </tr>
                <tr>
                  <td>step</td>
                  <td>step size</td>
                </tr>
                <tr>
                  <td>callable</td>
                  <td>a callable object to apply to each valid index</td>
                </tr>
                <tr>
                  <td>chunk_size</td>
                  <td>chunk size (default 0)</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow that applies the callable object to each index in the range <code>[beg, end)</code> with the step size. The runtime partitions the range into chunks of the given size, where each chunk is processed by a worker. When the given chunk size is zero, the runtime distributes the work evenly across workers.</p><p>Arguments are templated to enable stateful passing using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>. The callable needs to take a single argument of the integral index type.</p><p>Please refer to <a href="ParallelIterations.html" class="m-doc">Parallel Iterations</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="ad999cd75045db225a42d5881d6db1223"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename T, typename O&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ad999cd75045db225a42d5881d6db1223" class="m-doc-self">reduce</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              T&amp; init,
              O&amp;&amp; bop)</span></span>
            </h3>
            <p>constructs a STL-styled parallel-reduce task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>result type</td>
                </tr>
                <tr>
                  <td>O</td>
                  <td>binary reducer type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
                <tr>
                  <td>init</td>
                  <td>initial value of the reduction and the storage for the reduced result</td>
                </tr>
                <tr>
                  <td>bop</td>
                  <td>binary operator that will be applied</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow to perform parallel reduction over <code>init</code> and the elements in the range <code>[first, last)</code>. The reduced result is store in <code>init</code>. The runtime partitions the range into chunks of the given chunk size, where each chunk is processed by a worker. By default, we employ the guided partition algorithm.</p><p>This method is equivalent to the parallel execution of the following loop:</p><pre class="m-code"><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">itr</span><span class="o">=</span><span class="n">first</span><span class="p">;</span> <span class="n">itr</span><span class="o">!=</span><span class="n">last</span><span class="p">;</span> <span class="n">itr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">init</span> <span class="o">=</span> <span class="n">bop</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="o">*</span><span class="n">itr</span><span class="p">);</span>
<span class="p">}</span></pre><p>Arguments are templated to enable stateful passing using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>.</p><p>Please refer to <a href="ParallelReduction.html" class="m-doc">Parallel Reduction</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a10f13b39b02038c6850aca787923d668"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename T, typename O, typename H = size_t&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a10f13b39b02038c6850aca787923d668" class="m-doc-self">reduce_guided</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              T&amp; init,
              O&amp;&amp; bop,
              H&amp;&amp; chunk_size = 1)</span></span>
            </h3>
            <p>constructs a STL-styled parallel-reduce task using the guided partition algorithm</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>result type</td>
                </tr>
                <tr>
                  <td>O</td>
                  <td>binary reducer type</td>
                </tr>
                <tr>
                  <td>H</td>
                  <td>chunk size type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
                <tr>
                  <td>init</td>
                  <td>initial value of the reduction and the storage for the reduced result</td>
                </tr>
                <tr>
                  <td>bop</td>
                  <td>binary operator that will be applied</td>
                </tr>
                <tr>
                  <td>chunk_size</td>
                  <td>chunk size</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow to perform parallel reduction over <code>init</code> and the elements in the range <code>[first, last)</code>. The reduced result is store in <code>init</code>. The runtime partitions the range into chunks of size <code>chunk_size</code>, where each chunk is processed by a worker.</p><p>Arguments are templated to enable stateful passing using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>.</p><p>Please refer to <a href="ParallelReduction.html" class="m-doc">Parallel Reduction</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a83ec799606b7526787761acf27885b00"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename T, typename O, typename H = size_t&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a83ec799606b7526787761acf27885b00" class="m-doc-self">reduce_dynamic</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              T&amp; init,
              O&amp;&amp; bop,
              H&amp;&amp; chunk_size = 1)</span></span>
            </h3>
            <p>constructs a STL-styled parallel-reduce task using the dynamic partition algorithm</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>result type</td>
                </tr>
                <tr>
                  <td>O</td>
                  <td>binary reducer type</td>
                </tr>
                <tr>
                  <td>H</td>
                  <td>chunk size type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
                <tr>
                  <td>init</td>
                  <td>initial value of the reduction and the storage for the reduced result</td>
                </tr>
                <tr>
                  <td>bop</td>
                  <td>binary operator that will be applied</td>
                </tr>
                <tr>
                  <td>chunk_size</td>
                  <td>chunk size</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow to perform parallel reduction over <code>init</code> and the elements in the range <code>[first, last)</code>. The reduced result is store in <code>init</code>. The runtime partitions the range into chunks of size <code>chunk_size</code>, where each chunk is processed by a worker.</p><p>Arguments are templated to enable stateful passing using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>.</p><p>Please refer to <a href="ParallelReduction.html" class="m-doc">Parallel Reduction</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a54e36c916ae7dd88bd079d3fd49119f9"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename T, typename O, typename H = size_t&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a54e36c916ae7dd88bd079d3fd49119f9" class="m-doc-self">reduce_static</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              T&amp; init,
              O&amp;&amp; bop,
              H&amp;&amp; chunk_size = 0)</span></span>
            </h3>
            <p>constructs a STL-styled parallel-reduce task using the static partition algorithm</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>result type</td>
                </tr>
                <tr>
                  <td>O</td>
                  <td>binary reducer type</td>
                </tr>
                <tr>
                  <td>H</td>
                  <td>chunk size type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
                <tr>
                  <td>init</td>
                  <td>initial value of the reduction and the storage for the reduced result</td>
                </tr>
                <tr>
                  <td>bop</td>
                  <td>binary operator that will be applied</td>
                </tr>
                <tr>
                  <td>chunk_size</td>
                  <td>chunk size</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow to perform parallel reduction over <code>init</code> and the elements in the range <code>[first, last)</code>. The reduced result is store in <code>init</code>. The runtime partitions the range into chunks of size <code>chunk_size</code>, where each chunk is processed by a worker.</p><p>Arguments are templated to enable stateful passing using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>.</p><p>Please refer to <a href="ParallelReduction.html" class="m-doc">Parallel Reduction</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="ad8d03524f15292610ebee63d53b89579"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename T, typename BOP, typename UOP&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ad8d03524f15292610ebee63d53b89579" class="m-doc-self">transform_reduce</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              T&amp; init,
              BOP&amp;&amp; bop,
              UOP&amp;&amp; uop)</span></span>
            </h3>
            <p>constructs a STL-styled parallel transform-reduce task</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>result type</td>
                </tr>
                <tr>
                  <td>BOP</td>
                  <td>binary reducer type</td>
                </tr>
                <tr>
                  <td>UOP</td>
                  <td>unary transformion type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
                <tr>
                  <td>init</td>
                  <td>initial value of the reduction and the storage for the reduced result</td>
                </tr>
                <tr>
                  <td>bop</td>
                  <td>binary operator that will be applied in unspecified order to the results of <code>uop</code></td>
                </tr>
                <tr>
                  <td>uop</td>
                  <td>unary operator that will be applied to transform each element in the range to the result type</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow to perform parallel reduction over <code>init</code> and the transformed elements in the range <code>[first, last)</code>. The reduced result is store in <code>init</code>. The runtime partitions the range into chunks of the given chunk size, where each chunk is processed by a worker. By default, we employ the guided partition algorithm.</p><p>This method is equivalent to the parallel execution of the following loop:</p><pre class="m-code"><span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">itr</span><span class="o">=</span><span class="n">first</span><span class="p">;</span> <span class="n">itr</span><span class="o">!=</span><span class="n">last</span><span class="p">;</span> <span class="n">itr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">init</span> <span class="o">=</span> <span class="n">bop</span><span class="p">(</span><span class="n">init</span><span class="p">,</span> <span class="n">uop</span><span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">));</span>
<span class="p">}</span></pre><p>Arguments are templated to enable stateful passing using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>.</p><p>Please refer to <a href="ParallelReduction.html" class="m-doc">Parallel Reduction</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="aa102a40672a331643944cb17c2377118"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename T, typename BOP, typename UOP, typename H = size_t&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#aa102a40672a331643944cb17c2377118" class="m-doc-self">transform_reduce_guided</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              T&amp; init,
              BOP&amp;&amp; bop,
              UOP&amp;&amp; uop,
              H&amp;&amp; chunk_size = 1)</span></span>
            </h3>
            <p>constructs a STL-styled parallel transform-reduce task using the guided partition algorithm</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>result type</td>
                </tr>
                <tr>
                  <td>BOP</td>
                  <td>binary reducer type</td>
                </tr>
                <tr>
                  <td>UOP</td>
                  <td>unary transformion type</td>
                </tr>
                <tr>
                  <td>H</td>
                  <td>chunk size type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
                <tr>
                  <td>init</td>
                  <td>initial value of the reduction and the storage for the reduced result</td>
                </tr>
                <tr>
                  <td>bop</td>
                  <td>binary operator that will be applied in unspecified order to the results of <code>uop</code></td>
                </tr>
                <tr>
                  <td>uop</td>
                  <td>unary operator that will be applied to transform each element in the range to the result type</td>
                </tr>
                <tr>
                  <td>chunk_size</td>
                  <td>chunk size</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow to perform parallel reduction over <code>init</code> and the transformed elements in the range <code>[first, last)</code>. The reduced result is store in <code>init</code>. The runtime partitions the range into chunks of size <code>chunk_size</code>, where each chunk is processed by a worker.</p><p>Arguments are templated to enable stateful passing using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>.</p><p>Please refer to <a href="ParallelReduction.html" class="m-doc">Parallel Reduction</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a562e253028680b61de95e305c0224d91"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename T, typename BOP, typename UOP, typename H = size_t&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a562e253028680b61de95e305c0224d91" class="m-doc-self">transform_reduce_static</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              T&amp; init,
              BOP&amp;&amp; bop,
              UOP&amp;&amp; uop,
              H&amp;&amp; chunk_size = 0)</span></span>
            </h3>
            <p>constructs a STL-styled parallel transform-reduce task using the static partition algorithm</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>result type</td>
                </tr>
                <tr>
                  <td>BOP</td>
                  <td>binary reducer type</td>
                </tr>
                <tr>
                  <td>UOP</td>
                  <td>unary transformion type</td>
                </tr>
                <tr>
                  <td>H</td>
                  <td>chunk size type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
                <tr>
                  <td>init</td>
                  <td>initial value of the reduction and the storage for the reduced result</td>
                </tr>
                <tr>
                  <td>bop</td>
                  <td>binary operator that will be applied in unspecified order to the results of <code>uop</code></td>
                </tr>
                <tr>
                  <td>uop</td>
                  <td>unary operator that will be applied to transform each element in the range to the result type</td>
                </tr>
                <tr>
                  <td>chunk_size</td>
                  <td>chunk size</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow to perform parallel reduction over <code>init</code> and the transformed elements in the range <code>[first, last)</code>. The reduced result is store in <code>init</code>. The runtime partitions the range into chunks of size <code>chunk_size</code>, where each chunk is processed by a worker.</p><p>Arguments are templated to enable stateful passing using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>.</p><p>Please refer to <a href="ParallelReduction.html" class="m-doc">Parallel Reduction</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a6fb87774919f4a570ac505cdcda48249"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename T, typename BOP, typename UOP, typename H = size_t&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a6fb87774919f4a570ac505cdcda48249" class="m-doc-self">transform_reduce_dynamic</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              T&amp; init,
              BOP&amp;&amp; bop,
              UOP&amp;&amp; uop,
              H&amp;&amp; chunk_size = 1)</span></span>
            </h3>
            <p>constructs a STL-styled parallel transform-reduce task using the dynamic partition algorithm</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type</td>
                </tr>
                <tr>
                  <td>T</td>
                  <td>result type</td>
                </tr>
                <tr>
                  <td>BOP</td>
                  <td>binary reducer type</td>
                </tr>
                <tr>
                  <td>UOP</td>
                  <td>unary transformion type</td>
                </tr>
                <tr>
                  <td>H</td>
                  <td>chunk size type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
                <tr>
                  <td>init</td>
                  <td>initial value of the reduction and the storage for the reduced result</td>
                </tr>
                <tr>
                  <td>bop</td>
                  <td>binary operator that will be applied in unspecified order to the results of <code>uop</code></td>
                </tr>
                <tr>
                  <td>uop</td>
                  <td>unary operator that will be applied to transform each element in the range to the result type</td>
                </tr>
                <tr>
                  <td>chunk_size</td>
                  <td>chunk size</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1Task.html" class="m-doc">tf::<wbr />Task</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>The task spawns a subflow to perform parallel reduction over <code>init</code> and the transformed elements in the range <code>[first, last)</code>. The reduced result is store in <code>init</code>. The runtime partitions the range into chunks of size <code>chunk_size</code>, where each chunk is processed by a worker.</p><p>Arguments are templated to enable stateful passing using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>.</p><p>Please refer to <a href="ParallelReduction.html" class="m-doc">Parallel Reduction</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="af4848ab51fa3bf5525af58e2440b01c1"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E, typename C&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#af4848ab51fa3bf5525af58e2440b01c1" class="m-doc-self">sort</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last,
              C&amp;&amp; cmp)</span></span>
            </h3>
            <p>constructs a dynamic task to perform STL-styled parallel sort</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type (random-accessible)</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type (random-accessible)</td>
                </tr>
                <tr>
                  <td>C</td>
                  <td>comparator type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
                <tr>
                  <td>cmp</td>
                  <td>comparison function object</td>
                </tr>
              </tbody>
            </table>
<p>The task spawns a subflow to parallelly sort elements in the range <code>[first, last)</code>.</p><p>Arguments are templated to enable stateful passing using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>.</p><p>Please refer to <a href="ParallelSort.html" class="m-doc">Parallel Sort</a> for details.</p>
          </div></section>
          <section class="m-doc-details" id="a559afa5066782bc6c38738260e3d4c2e"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename B, typename E&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Task.html" class="m-doc">Task</a> tf::<wbr />FlowBuilder::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a559afa5066782bc6c38738260e3d4c2e" class="m-doc-self">sort</a>(</span><span class="m-doc-wrap">B&amp;&amp; first,
              E&amp;&amp; last)</span></span>
            </h3>
            <p>constructs a dynamic task to perform STL-styled parallel sort using the <code>std::less&lt;T&gt;</code> comparator, where <code>T</code> is the element type</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">B</td>
                  <td>beginning iterator type (random-accessible)</td>
                </tr>
                <tr>
                  <td>E</td>
                  <td>ending iterator type (random-accessible)</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
              </tbody>
            </table>
<p>The task spawns a subflow to parallelly sort elements in the range <code>[first, last)</code> using the <code>std::less&lt;T&gt;</code> comparator, where <code>T</code> is the dereferenced iterator type.</p><p>Arguments are templated to enable stateful passing using <a href="http://en.cppreference.com/w/cpp/utility/functional/reference_wrapper.html" class="m-doc-external">std::<wbr />reference_wrapper</a>.</p><p>Please refer to <a href="ParallelSort.html" class="m-doc">Parallel Sort</a> for details.</p>
          </div></section>
        </section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim"></span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim"></span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v1.js"></script>
<script src="searchdata-v1.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Taskflow handbook is part of the <a href="https://taskflow.github.io">Taskflow project</a>, copyright  <a href="https://tsung-wei-huang.github.io/">Dr. Tsung-Wei Huang</a>, 2018&ndash;2021.<br />Generated by <a href="https://doxygen.org/">Doxygen</a> 1.8.20 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
