<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="namespacetf" kind="namespace" language="C++">
    <compoundname>tf</compoundname>
    <innerclass refid="structtf_1_1IsPod" prot="private">tf::IsPod</innerclass>
    <innerclass refid="classtf_1_1SmallVectorBase" prot="private">tf::SmallVectorBase</innerclass>
    <innerclass refid="structtf_1_1SmallVectorStorage" prot="private">tf::SmallVectorStorage</innerclass>
    <innerclass refid="classtf_1_1SmallVectorTemplateCommon" prot="private">tf::SmallVectorTemplateCommon</innerclass>
    <innerclass refid="classtf_1_1SmallVectorTemplateBase" prot="private">tf::SmallVectorTemplateBase</innerclass>
    <innerclass refid="classtf_1_1SmallVectorTemplateBase_3_01T_00_01true_01_4" prot="private">tf::SmallVectorTemplateBase&lt; T, true &gt;</innerclass>
    <innerclass refid="classtf_1_1SmallVectorImpl" prot="private">tf::SmallVectorImpl</innerclass>
    <innerclass refid="structtf_1_1SmallVectorStorage_3_01T_00_011_01_4" prot="private">tf::SmallVectorStorage&lt; T, 1 &gt;</innerclass>
    <innerclass refid="structtf_1_1SmallVectorStorage_3_01T_00_010_01_4" prot="private">tf::SmallVectorStorage&lt; T, 0 &gt;</innerclass>
    <innerclass refid="classtf_1_1SmallVector" prot="public">tf::SmallVector</innerclass>
    <innerclass refid="classtf_1_1CachelineAligned" prot="public">tf::CachelineAligned</innerclass>
    <innerclass refid="classtf_1_1IndexRange" prot="public">tf::IndexRange</innerclass>
    <innerclass refid="classtf_1_1Graph" prot="public">tf::Graph</innerclass>
    <innerclass refid="classtf_1_1TaskParams" prot="public">tf::TaskParams</innerclass>
    <innerclass refid="classtf_1_1DefaultTaskParams" prot="public">tf::DefaultTaskParams</innerclass>
    <innerclass refid="classtf_1_1Node" prot="private">tf::Node</innerclass>
    <innerclass refid="classtf_1_1AnchorGuard" prot="private">tf::AnchorGuard</innerclass>
    <innerclass refid="structtf_1_1has__graph" prot="private">tf::has_graph</innerclass>
    <innerclass refid="classtf_1_1UnboundedTaskQueue" prot="public">tf::UnboundedTaskQueue</innerclass>
    <innerclass refid="classtf_1_1BoundedTaskQueue" prot="public">tf::BoundedTaskQueue</innerclass>
    <innerclass refid="classtf_1_1FlowBuilder" prot="public">tf::FlowBuilder</innerclass>
    <innerclass refid="classtf_1_1Subflow" prot="public">tf::Subflow</innerclass>
    <innerclass refid="classtf_1_1Worker" prot="public">tf::Worker</innerclass>
    <innerclass refid="classtf_1_1WorkerView" prot="public">tf::WorkerView</innerclass>
    <innerclass refid="classtf_1_1WorkerInterface" prot="public">tf::WorkerInterface</innerclass>
    <innerclass refid="classtf_1_1Executor" prot="public">tf::Executor</innerclass>
    <innerclass refid="structtf_1_1is__static__task" prot="private">tf::is_static_task</innerclass>
    <innerclass refid="structtf_1_1is__subflow__task" prot="private">tf::is_subflow_task</innerclass>
    <innerclass refid="structtf_1_1is__runtime__task" prot="private">tf::is_runtime_task</innerclass>
    <innerclass refid="classtf_1_1Task" prot="public">tf::Task</innerclass>
    <innerclass refid="classtf_1_1TaskView" prot="public">tf::TaskView</innerclass>
    <innerclass refid="classtf_1_1AsyncTask" prot="public">tf::AsyncTask</innerclass>
    <innerclass refid="classtf_1_1Runtime" prot="public">tf::Runtime</innerclass>
    <innerclass refid="classtf_1_1NonpreemptiveRuntime" prot="private">tf::NonpreemptiveRuntime</innerclass>
    <innerclass refid="classtf_1_1Semaphore" prot="public">tf::Semaphore</innerclass>
    <innerclass refid="classtf_1_1Taskflow" prot="public">tf::Taskflow</innerclass>
    <innerclass refid="classtf_1_1Future" prot="public">tf::Future</innerclass>
    <innerclass refid="structtf_1_1Segment" prot="private">tf::Segment</innerclass>
    <innerclass refid="structtf_1_1Timeline" prot="private">tf::Timeline</innerclass>
    <innerclass refid="structtf_1_1ProfileData" prot="private">tf::ProfileData</innerclass>
    <innerclass refid="classtf_1_1ObserverInterface" prot="public">tf::ObserverInterface</innerclass>
    <innerclass refid="classtf_1_1ChromeObserver" prot="public">tf::ChromeObserver</innerclass>
    <innerclass refid="classtf_1_1TFProfObserver" prot="public">tf::TFProfObserver</innerclass>
    <innerclass refid="classtf_1_1TFProfManager" prot="private">tf::TFProfManager</innerclass>
    <innerclass refid="classtf_1_1DefaultClosureWrapper" prot="public">tf::DefaultClosureWrapper</innerclass>
    <innerclass refid="structtf_1_1IsPartitioner" prot="private">tf::IsPartitioner</innerclass>
    <innerclass refid="classtf_1_1PartitionerBase" prot="public">tf::PartitionerBase</innerclass>
    <innerclass refid="classtf_1_1GuidedPartitioner" prot="public">tf::GuidedPartitioner</innerclass>
    <innerclass refid="classtf_1_1DynamicPartitioner" prot="public">tf::DynamicPartitioner</innerclass>
    <innerclass refid="classtf_1_1StaticPartitioner" prot="public">tf::StaticPartitioner</innerclass>
    <innerclass refid="classtf_1_1RandomPartitioner" prot="public">tf::RandomPartitioner</innerclass>
    <innerclass refid="classtf_1_1Pipeflow" prot="public">tf::Pipeflow</innerclass>
    <innerclass refid="classtf_1_1Pipe" prot="public">tf::Pipe</innerclass>
    <innerclass refid="classtf_1_1Pipeline" prot="public">tf::Pipeline</innerclass>
    <innerclass refid="classtf_1_1ScalablePipeline" prot="public">tf::ScalablePipeline</innerclass>
    <innerclass refid="classtf_1_1DataPipe" prot="public">tf::DataPipe</innerclass>
    <innerclass refid="classtf_1_1DataPipeline" prot="public">tf::DataPipeline</innerclass>
    <innerclass refid="classtf_1_1cudaScopedDevice" prot="public">tf::cudaScopedDevice</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory" prot="private">tf::cudaSharedMemory</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01int_01_4" prot="private">tf::cudaSharedMemory&lt; int &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01unsigned_01int_01_4" prot="private">tf::cudaSharedMemory&lt; unsigned int &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01char_01_4" prot="private">tf::cudaSharedMemory&lt; char &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01unsigned_01char_01_4" prot="private">tf::cudaSharedMemory&lt; unsigned char &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01short_01_4" prot="private">tf::cudaSharedMemory&lt; short &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01unsigned_01short_01_4" prot="private">tf::cudaSharedMemory&lt; unsigned short &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01long_01_4" prot="private">tf::cudaSharedMemory&lt; long &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01unsigned_01long_01_4" prot="private">tf::cudaSharedMemory&lt; unsigned long &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01bool_01_4" prot="private">tf::cudaSharedMemory&lt; bool &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01float_01_4" prot="private">tf::cudaSharedMemory&lt; float &gt;</innerclass>
    <innerclass refid="structtf_1_1cudaSharedMemory_3_01double_01_4" prot="private">tf::cudaSharedMemory&lt; double &gt;</innerclass>
    <innerclass refid="classtf_1_1cudaDeviceAllocator" prot="private">tf::cudaDeviceAllocator</innerclass>
    <innerclass refid="classtf_1_1cudaUSMAllocator" prot="private">tf::cudaUSMAllocator</innerclass>
    <innerclass refid="classtf_1_1cudaDeviceVector" prot="private">tf::cudaDeviceVector</innerclass>
    <innerclass refid="classtf_1_1cudaEventCreator" prot="public">tf::cudaEventCreator</innerclass>
    <innerclass refid="classtf_1_1cudaEventDeleter" prot="public">tf::cudaEventDeleter</innerclass>
    <innerclass refid="classtf_1_1cudaEventBase" prot="public">tf::cudaEventBase</innerclass>
    <innerclass refid="classtf_1_1cudaStreamCreator" prot="public">tf::cudaStreamCreator</innerclass>
    <innerclass refid="classtf_1_1cudaStreamDeleter" prot="public">tf::cudaStreamDeleter</innerclass>
    <innerclass refid="classtf_1_1cudaStreamBase" prot="public">tf::cudaStreamBase</innerclass>
    <innerclass refid="classtf_1_1cudaTask" prot="public">tf::cudaTask</innerclass>
    <innerclass refid="classtf_1_1cudaGraphCreator" prot="public">tf::cudaGraphCreator</innerclass>
    <innerclass refid="classtf_1_1cudaGraphDeleter" prot="public">tf::cudaGraphDeleter</innerclass>
    <innerclass refid="classtf_1_1cudaGraphBase" prot="public">tf::cudaGraphBase</innerclass>
    <innerclass refid="classtf_1_1cudaGraphExecCreator" prot="public">tf::cudaGraphExecCreator</innerclass>
    <innerclass refid="classtf_1_1cudaGraphExecDeleter" prot="public">tf::cudaGraphExecDeleter</innerclass>
    <innerclass refid="classtf_1_1cudaGraphExecBase" prot="public">tf::cudaGraphExecBase</innerclass>
    <innernamespace refid="namespacetf_1_1detail">tf::detail</innernamespace>
      <sectiondef kind="enum">
      <memberdef kind="enum" id="namespacetf_1a1355048578785a80414707ff308b395a" prot="public" static="no" strong="yes">
        <type>int</type>
        <name>TaskType</name>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aae54e6f6ba0c7cbb4eb7a2016e2f17842" prot="public">
          <name>PLACEHOLDER</name>
          <initializer>= 0</initializer>
          <briefdescription>
<para>placeholder task type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aafe6f99ef1ec99efbdc19a9786cf1facc" prot="public">
          <name>STATIC</name>
          <briefdescription>
<para>static task type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aae5f5cd9fe71ac064a678f27c7d539ae8" prot="public">
          <name>RUNTIME</name>
          <briefdescription>
<para>runtime task type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aa46be697979903d784a70aeec45eb14ad" prot="public">
          <name>SUBFLOW</name>
          <briefdescription>
<para>dynamic (subflow) task type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aa9f768c0bb1c3e84ca086a85211e978ac" prot="public">
          <name>CONDITION</name>
          <briefdescription>
<para>condition task type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aa1cf5e1f5569acda3c4a88a91c5130a69" prot="public">
          <name>MODULE</name>
          <briefdescription>
<para>module task type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aabe553330beb7b3d994656e0a4e66cd96" prot="public">
          <name>ASYNC</name>
          <briefdescription>
<para>asynchronous task type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a1355048578785a80414707ff308b395aa0db45d2a4141101bdfe48e3314cfbca3" prot="public">
          <name>UNDEFINED</name>
          <briefdescription>
<para>undefined task type (for internal use only) </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>enumeration of all task types </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/task.hpp" line="21" column="1" bodyfile="taskflow/core/task.hpp" bodystart="21" bodyend="38"/>
      </memberdef>
      <memberdef kind="enum" id="namespacetf_1a192f7cb0fab2eb6f1c84f6046706435d" prot="public" static="no" strong="yes">
        <type>int</type>
        <name>ObserverType</name>
        <enumvalue id="namespacetf_1a192f7cb0fab2eb6f1c84f6046706435dac19bf39d8838d00eddb556775fa8acce" prot="public">
          <name>TFPROF</name>
          <initializer>= 0</initializer>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a192f7cb0fab2eb6f1c84f6046706435da37960509766262569d504f02a0ee986d" prot="public">
          <name>CHROME</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a192f7cb0fab2eb6f1c84f6046706435da0db45d2a4141101bdfe48e3314cfbca3" prot="public">
          <name>UNDEFINED</name>
          <briefdescription>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>enumeration of all observer types </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/observer.hpp" line="1032" column="1" bodyfile="taskflow/core/observer.hpp" bodystart="1032" bodyend="1036"/>
      </memberdef>
      <memberdef kind="enum" id="namespacetf_1a32d51425fa23cd0dc3518c16cf3bb6c0" prot="public" static="no" strong="yes">
        <type>int</type>
        <name>PartitionerType</name>
        <enumvalue id="namespacetf_1a32d51425fa23cd0dc3518c16cf3bb6c0afe6f99ef1ec99efbdc19a9786cf1facc" prot="public">
          <name>STATIC</name>
          <briefdescription>
<para>static partitioner type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1a32d51425fa23cd0dc3518c16cf3bb6c0a0fcc90da4811c877ba9f9c12f7d60bc9" prot="public">
          <name>DYNAMIC</name>
          <briefdescription>
<para>dynamic partitioner type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>enumeration of all partitioner types </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/algorithm/partitioner.hpp" line="19" column="1" bodyfile="taskflow/algorithm/partitioner.hpp" bodystart="19" bodyend="24"/>
      </memberdef>
      <memberdef kind="enum" id="namespacetf_1abb7a11e41fd457f69e7ff45d4c769564" prot="public" static="no" strong="yes">
        <type>int</type>
        <name>PipeType</name>
        <enumvalue id="namespacetf_1abb7a11e41fd457f69e7ff45d4c769564adf13a99b035d6f0bce4f44ab18eec8eb" prot="public">
          <name>PARALLEL</name>
          <initializer>= 1</initializer>
          <briefdescription>
<para>parallel type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <enumvalue id="namespacetf_1abb7a11e41fd457f69e7ff45d4c769564a7b804a28d6154ab8007287532037f1d0" prot="public">
          <name>SERIAL</name>
          <initializer>= 2</initializer>
          <briefdescription>
<para>serial type </para>
          </briefdescription>
          <detaileddescription>
          </detaileddescription>
        </enumvalue>
        <briefdescription>
<para>enumeration of all pipe types </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/algorithm/pipeline.hpp" line="113" column="1" bodyfile="taskflow/algorithm/pipeline.hpp" bodystart="113" bodyend="118"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="typedef">
      <memberdef kind="typedef" id="namespacetf_1af8633cb190af9c3669002ed342ba9cff" prot="private" static="no">
        <type>AtomicNotifier</type>
        <definition>using tf::DefaultNotifier = typedef AtomicNotifier</definition>
        <argsstring></argsstring>
        <name>DefaultNotifier</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/worker.hpp" line="22" column="1" bodyfile="taskflow/core/worker.hpp" bodystart="22" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacetf_1a8cff4bbd797dde4dfab096c3cc657833" prot="public" static="no">
        <type><ref refid="cpp/chrono/time_point" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::chrono::time_point</ref>&lt; <ref refid="cpp/chrono/steady_clock" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::chrono::steady_clock</ref> &gt;</type>
        <definition>using tf::observer_stamp_t = typedef std::chrono::time_point&lt;std::chrono::steady_clock&gt;</definition>
        <argsstring></argsstring>
        <name>observer_stamp_t</name>
        <briefdescription>
<para>default time point type of observers </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/observer.hpp" line="20" column="1" bodyfile="taskflow/core/observer.hpp" bodystart="20" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacetf_1a66b72776c788898aee9e132b0ea9b405" prot="public" static="no">
        <type><ref refid="classtf_1_1GuidedPartitioner" kindref="compound">GuidedPartitioner</ref>&lt;&gt;</type>
        <definition>using tf::DefaultPartitioner = typedef GuidedPartitioner&lt;&gt;</definition>
        <argsstring></argsstring>
        <name>DefaultPartitioner</name>
        <briefdescription>
<para>default partitioner set to <ref refid="classtf_1_1GuidedPartitioner" kindref="compound">tf::GuidedPartitioner</ref> </para>
        </briefdescription>
        <detaileddescription>
<para>Guided partitioning algorithm can achieve stable and decent performance for most parallel algorithms. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/algorithm/partitioner.hpp" line="819" column="1" bodyfile="taskflow/algorithm/partitioner.hpp" bodystart="819" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacetf_1a19f35245e6334fae46dccb73f27417bf" prot="public" static="no">
        <type><ref refid="classtf_1_1cudaEventBase" kindref="compound">cudaEventBase</ref>&lt; <ref refid="classtf_1_1cudaEventCreator" kindref="compound">cudaEventCreator</ref>, <ref refid="classtf_1_1cudaEventDeleter" kindref="compound">cudaEventDeleter</ref> &gt;</type>
        <definition>using tf::cudaEvent = typedef cudaEventBase&lt;cudaEventCreator, cudaEventDeleter&gt;</definition>
        <argsstring></argsstring>
        <name>cudaEvent</name>
        <briefdescription>
<para>default smart pointer type to manage a <computeroutput>cudaEvent_t</computeroutput> object with unique ownership </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_stream.hpp" line="128" column="1" bodyfile="taskflow/cuda/cuda_stream.hpp" bodystart="128" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacetf_1a45b31698cd7ee9a4dcd55465d1e8942a" prot="public" static="no">
        <type><ref refid="classtf_1_1cudaStreamBase" kindref="compound">cudaStreamBase</ref>&lt; <ref refid="classtf_1_1cudaStreamCreator" kindref="compound">cudaStreamCreator</ref>, <ref refid="classtf_1_1cudaStreamDeleter" kindref="compound">cudaStreamDeleter</ref> &gt;</type>
        <definition>using tf::cudaStream = typedef cudaStreamBase&lt;cudaStreamCreator, cudaStreamDeleter&gt;</definition>
        <argsstring></argsstring>
        <name>cudaStream</name>
        <briefdescription>
<para>default smart pointer type to manage a <computeroutput>cudaStream_t</computeroutput> object with unique ownership </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_stream.hpp" line="340" column="1" bodyfile="taskflow/cuda/cuda_stream.hpp" bodystart="340" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacetf_1ac76b07f7b7055967f6a2f1dc78b0978a" prot="public" static="no">
        <type><ref refid="classtf_1_1cudaGraphBase" kindref="compound">cudaGraphBase</ref>&lt; <ref refid="classtf_1_1cudaGraphCreator" kindref="compound">cudaGraphCreator</ref>, <ref refid="classtf_1_1cudaGraphDeleter" kindref="compound">cudaGraphDeleter</ref> &gt;</type>
        <definition>using tf::cudaGraph = typedef cudaGraphBase&lt;cudaGraphCreator, cudaGraphDeleter&gt;</definition>
        <argsstring></argsstring>
        <name>cudaGraph</name>
        <briefdescription>
<para>default smart pointer type to manage a <computeroutput>cudaGraph_t</computeroutput> object with unique ownership </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cudaflow.hpp" line="18" column="1" bodyfile="taskflow/cuda/cudaflow.hpp" bodystart="18" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="namespacetf_1a21efbebd2a9b305f43dde90b7b837dc7" prot="public" static="no">
        <type><ref refid="classtf_1_1cudaGraphExecBase" kindref="compound">cudaGraphExecBase</ref>&lt; <ref refid="classtf_1_1cudaGraphExecCreator" kindref="compound">cudaGraphExecCreator</ref>, <ref refid="classtf_1_1cudaGraphExecDeleter" kindref="compound">cudaGraphExecDeleter</ref> &gt;</type>
        <definition>using tf::cudaGraphExec = typedef cudaGraphExecBase&lt;cudaGraphExecCreator, cudaGraphExecDeleter&gt;</definition>
        <argsstring></argsstring>
        <name>cudaGraphExec</name>
        <briefdescription>
<para>default smart pointer type to manage a <computeroutput>cudaGraphExec_t</computeroutput> object with unique ownership </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cudaflow.hpp" line="23" column="1" bodyfile="taskflow/cuda/cudaflow.hpp" bodystart="23" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="var">
      <memberdef kind="variable" id="namespacetf_1ad3a41adc2499a9519da3e77dc3e9849c" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::is_task_params_v</definition>
        <argsstring></argsstring>
        <name>is_task_params_v</name>
        <initializer>=
  std::is_same_v&lt;std::decay_t&lt;P&gt;, <ref refid="classtf_1_1TaskParams" kindref="compound">TaskParams</ref>&gt; ||
  std::is_same_v&lt;std::decay_t&lt;P&gt;, <ref refid="classtf_1_1DefaultTaskParams" kindref="compound">DefaultTaskParams</ref>&gt; ||
  std::is_constructible_v&lt;<ref refid="cpp/string/basic_string" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::string</ref>, P&gt;</initializer>
        <briefdescription>
<para>determines if the given type is a task parameter type </para>
        </briefdescription>
        <detaileddescription>
<para><ref refid="classtf_1_1Task" kindref="compound">Task</ref> parameters can be specified in one of the following types:<itemizedlist>
<listitem><para><ref refid="classtf_1_1TaskParams" kindref="compound">tf::TaskParams</ref></para>
</listitem><listitem><para><ref refid="classtf_1_1DefaultTaskParams" kindref="compound">tf::DefaultTaskParams</ref></para>
</listitem><listitem><para><ref refid="cpp/string/basic_string" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::string</ref> </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/graph.hpp" line="133" column="16" bodyfile="taskflow/core/graph.hpp" bodystart="133" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1aea3945d9b15c96a72540ea4fe61947e7" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::has_graph_v</definition>
        <argsstring></argsstring>
        <name>has_graph_v</name>
        <initializer>= has_graph&lt;T&gt;::value</initializer>
        <briefdescription>
<para>determines if the given type has a member function <computeroutput><ref refid="classtf_1_1Graph" kindref="compound">Graph</ref>&amp; graph()</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para>This trait determines if the provided type <computeroutput>T</computeroutput> contains a member function with the exact signature <computeroutput><ref refid="classtf_1_1Graph" kindref="compound">tf::Graph</ref>&amp; graph()</computeroutput>. It uses SFINAE and <computeroutput>std::void_t</computeroutput> to detect the presence of the member function and its return type.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type to inspect. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="retval"><parameteritem>
<parameternamelist>
<parametername>true</parametername>
</parameternamelist>
<parameterdescription>
<para>If the type <computeroutput>T</computeroutput> has a member function <computeroutput><ref refid="classtf_1_1Graph" kindref="compound">tf::Graph</ref>&amp; graph()</computeroutput>. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>false</parametername>
</parameternamelist>
<parameterdescription>
<para>Otherwise.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Example usage: <programlisting><codeline><highlight class="normal">struct<sp/>A<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tf::Graph&amp;<sp/>graph()<sp/>{<sp/>return<sp/>my_graph;<sp/>};</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tf::Graph<sp/>my_graph;</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal"><sp/><sp/>//<sp/>other<sp/>custom<sp/>members<sp/>to<sp/>alter<sp/>my_graph</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">struct<sp/>C<sp/>{};<sp/>//<sp/>No<sp/>graph<sp/>function</highlight></codeline>
<codeline></codeline>
<codeline><highlight class="normal">static_assert(has_graph_v&lt;A&gt;,<sp/>&quot;A<sp/>has<sp/>graph()&quot;);</highlight></codeline>
<codeline><highlight class="normal">static_assert(!has_graph_v&lt;C&gt;,<sp/>&quot;C<sp/>does<sp/>not<sp/>have<sp/>graph()&quot;);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/graph.hpp" line="728" column="16" bodyfile="taskflow/core/graph.hpp" bodystart="728" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1a3d823d8776745f3348dc87bba2fcc91b" prot="private" static="no" constexpr="yes" mutable="no">
        <type>constexpr <ref refid="cpp/container/array" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::array</ref>&lt; <ref refid="namespacetf_1a1355048578785a80414707ff308b395a" kindref="member">TaskType</ref>, 7 &gt;</type>
        <definition>constexpr std::array&lt;TaskType, 7&gt; tf::TASK_TYPES</definition>
        <argsstring></argsstring>
        <name>TASK_TYPES</name>
        <initializer>= {
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aae54e6f6ba0c7cbb4eb7a2016e2f17842" kindref="member">TaskType::PLACEHOLDER</ref>,
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aafe6f99ef1ec99efbdc19a9786cf1facc" kindref="member">TaskType::STATIC</ref>,
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aae5f5cd9fe71ac064a678f27c7d539ae8" kindref="member">TaskType::RUNTIME</ref>,
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aa46be697979903d784a70aeec45eb14ad" kindref="member">TaskType::SUBFLOW</ref>,
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aa9f768c0bb1c3e84ca086a85211e978ac" kindref="member">TaskType::CONDITION</ref>,
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aa1cf5e1f5569acda3c4a88a91c5130a69" kindref="member">TaskType::MODULE</ref>,
  <ref refid="namespacetf_1a1355048578785a80414707ff308b395aabe553330beb7b3d994656e0a4e66cd96" kindref="member">TaskType::ASYNC</ref>,
}</initializer>
        <briefdescription>
<para>array of all task types (used for iterating task types) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/task.hpp" line="44" column="29" bodyfile="taskflow/core/task.hpp" bodystart="44" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1a11fc9c98eb3a0d3a9aa55598b1f4d614" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::is_static_task_v</definition>
        <argsstring></argsstring>
        <name>is_static_task_v</name>
        <initializer>= is_static_task&lt;C&gt;::value</initializer>
        <briefdescription>
<para>determines if a callable is a static task </para>
        </briefdescription>
        <detaileddescription>
<para>A static task is a callable object constructible from std::function&lt;void()&gt;. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/task.hpp" line="107" column="16" bodyfile="taskflow/core/task.hpp" bodystart="107" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1aefeb96086f4a99f0e58a0f321012a52c" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::is_subflow_task_v</definition>
        <argsstring></argsstring>
        <name>is_subflow_task_v</name>
        <initializer>= is_subflow_task&lt;C&gt;::value</initializer>
        <briefdescription>
<para>determines if a callable is a subflow task </para>
        </briefdescription>
        <detaileddescription>
<para>A subflow task is a callable object constructible from std::function&lt;void(Subflow&amp;)&gt;. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/task.hpp" line="132" column="16" bodyfile="taskflow/core/task.hpp" bodystart="132" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1af3d94f0be0f7b49e195c4e92737b1f85" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::is_runtime_task_v</definition>
        <argsstring></argsstring>
        <name>is_runtime_task_v</name>
        <initializer>= is_runtime_task&lt;C&gt;::value</initializer>
        <briefdescription>
<para>determines if a callable is a runtime task </para>
        </briefdescription>
        <detaileddescription>
<para>A runtime task is a callable object constructible from std::function&lt;void(Runtime&amp;)&gt;. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/task.hpp" line="164" column="16" bodyfile="taskflow/core/task.hpp" bodystart="164" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1a00ca2fc2de0e679a7d9b8039340343df" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::is_condition_task_v</definition>
        <argsstring></argsstring>
        <name>is_condition_task_v</name>
        <initializer>= std::is_invocable_r_v&lt;int, C&gt;</initializer>
        <briefdescription>
<para>determines if a callable is a condition task </para>
        </briefdescription>
        <detaileddescription>
<para>A condition task is a callable object constructible from std::function&lt;int()&gt;. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/task.hpp" line="177" column="16" bodyfile="taskflow/core/task.hpp" bodystart="177" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1a78c40dc8776735b0f2c27cd446481aff" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::is_multi_condition_task_v</definition>
        <argsstring></argsstring>
        <name>is_multi_condition_task_v</name>
        <initializer>= std::is_invocable_r_v&lt;<ref refid="classtf_1_1SmallVector" kindref="compound">SmallVector</ref>&lt;int&gt;, C&gt;</initializer>
        <briefdescription>
<para>determines if a callable is a multi-condition task </para>
        </briefdescription>
        <detaileddescription>
<para>A multi-condition task is a callable object constructible from <ref refid="cpp/utility/functional/function" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::function</ref>&lt;tf::SmallVector&lt;int&gt;()&gt;. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/task.hpp" line="186" column="16" bodyfile="taskflow/core/task.hpp" bodystart="186" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="namespacetf_1a73c20705fc54763f195a00b6e626e301" prot="public" static="no" constexpr="yes" mutable="no">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::is_partitioner_v</definition>
        <argsstring></argsstring>
        <name>is_partitioner_v</name>
        <initializer>= <ref refid="cpp/types/is_base_of" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::is_base_of</ref>&lt;IsPartitioner, P&gt;::value</initializer>
        <briefdescription>
<para>determines if a type is a partitioner </para>
        </briefdescription>
        <detaileddescription>
<para>A partitioner is a derived type from <ref refid="classtf_1_1PartitionerBase" kindref="compound">tf::PartitionerBase</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/algorithm/partitioner.hpp" line="827" column="23" bodyfile="taskflow/algorithm/partitioner.hpp" bodystart="827" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="func">
      <memberdef kind="function" id="namespacetf_1aea9fe5c87d4439816239b5af6ebeec55" prot="public" static="yes" const="no" explicit="no" inline="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>unsigned</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
        </templateparamlist>
        <type>size_t</type>
        <definition>static size_t tf::capacity_in_bytes</definition>
        <argsstring>(const SmallVector&lt; T, N &gt; &amp;X)</argsstring>
        <name>capacity_in_bytes</name>
        <param>
          <type>const <ref refid="classtf_1_1SmallVector" kindref="compound">SmallVector</ref>&lt; T, N &gt; &amp;</type>
          <declname>X</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/small_vector.hpp" line="1027" column="22" bodyfile="taskflow/utility/small_vector.hpp" bodystart="1027" bodyend="1029"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1ae9682c3db0662fdf6d688a8b095c19ea" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt;(std::is_unsigned_v&lt; std::decay_t&lt; T &gt;&gt; &amp;&amp;sizeof(T)==8), void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>constexpr T</type>
        <definition>constexpr T tf::next_pow2</definition>
        <argsstring>(T x)</argsstring>
        <name>next_pow2</name>
        <param>
          <type>T</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>rounds the given 64-bit unsigned integer to the nearest power of 2 </para>
        </briefdescription>
        <detaileddescription>
<para>rounds the given 32-bit unsigned integer to the nearest power of 2 </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/math.hpp" line="14" column="13" bodyfile="taskflow/utility/math.hpp" bodystart="14" bodyend="25"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a8d48a5014f34a9f97aae5269c2367e38" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; std::decay_t&lt; T &gt;&gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>constexpr bool</type>
        <definition>constexpr bool tf::is_pow2</definition>
        <argsstring>(const T &amp;x)</argsstring>
        <name>is_pow2</name>
        <param>
          <type>const T &amp;</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>checks if the given number is a power of 2 </para>
        </briefdescription>
        <detaileddescription>
<para>This function determines if the given integer is a power of 2.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the input. Must be an integral type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>The integer to check. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>true</computeroutput> if <computeroutput>x</computeroutput> is a power of 2, otherwise <computeroutput>false</computeroutput>.</para>
</simplesect>
<simplesect kind="attention"><para>This function is constexpr and can be evaluated at compile time. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/math.hpp" line="60" column="16" bodyfile="taskflow/utility/math.hpp" bodystart="60" bodyend="62"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a8845f13b039ef9820087c9f467f6c734" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>constexpr size_t</type>
        <definition>constexpr size_t tf::floor_log2</definition>
        <argsstring>(T n)</argsstring>
        <name>floor_log2</name>
        <param>
          <type>T</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>computes the floor of the base-2 logarithm of a number using count-leading-zeros (CTL). </para>
        </briefdescription>
        <detaileddescription>
<para>This function efficiently calculates the floor of <computeroutput>log2(n)</computeroutput> for both 32-bit and 64-bit integers.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>integer type (uint32_t or uint64_t). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>input number. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>floor of <computeroutput>log2(n)</computeroutput> </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/math.hpp" line="74" column="18" bodyfile="taskflow/utility/math.hpp" bodystart="74" bodyend="100"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a908e0f3faf873e897b3e1bafbd4bb876" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
        </templateparamlist>
        <type>constexpr size_t</type>
        <definition>constexpr size_t tf::static_floor_log2</definition>
        <argsstring>()</argsstring>
        <name>static_floor_log2</name>
        <briefdescription>
<para>returns the floor of <computeroutput>log2(N)</computeroutput> at compile time </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/math.hpp" line="106" column="18" bodyfile="taskflow/utility/math.hpp" bodystart="106" bodyend="113"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a0b2dc0c0c931b9b627fc0a148085fa5e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename RandItr</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>RandItr</type>
        <definition>RandItr tf::median_of_three</definition>
        <argsstring>(RandItr l, RandItr m, RandItr r, C cmp)</argsstring>
        <name>median_of_three</name>
        <param>
          <type>RandItr</type>
          <declname>l</declname>
        </param>
        <param>
          <type>RandItr</type>
          <declname>m</declname>
        </param>
        <param>
          <type>RandItr</type>
          <declname>r</declname>
        </param>
        <param>
          <type>C</type>
          <declname>cmp</declname>
        </param>
        <briefdescription>
<para>finds the median of three numbers pointed to by iterators using the given comparator </para>
        </briefdescription>
        <detaileddescription>
<para>This function determines the median value of the elements pointed to by three random-access iterators using the provided comparator.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>RandItr</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the random-access iterator. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the comparator. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>l</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to the first element. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>m</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to the second element. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>r</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to the third element. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmp</parametername>
</parameternamelist>
<parameterdescription>
<para>The comparator used to compare the dereferenced iterator values. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The iterator pointing to the median value among the three elements. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/math.hpp" line="132" column="9" bodyfile="taskflow/utility/math.hpp" bodystart="132" bodyend="135"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a5f9a989c8de663d3ee010cbc6de13c91" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename RandItr</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>RandItr</type>
        <definition>RandItr tf::pseudo_median_of_nine</definition>
        <argsstring>(RandItr beg, RandItr end, C cmp)</argsstring>
        <name>pseudo_median_of_nine</name>
        <param>
          <type>RandItr</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>RandItr</type>
          <declname>end</declname>
        </param>
        <param>
          <type>C</type>
          <declname>cmp</declname>
        </param>
        <briefdescription>
<para>finds the pseudo median of a range of items using a spread of nine numbers </para>
        </briefdescription>
        <detaileddescription>
<para>This function computes an approximate median of a range of items by sampling nine values spread across the range and finding their median. It uses a combination of the <computeroutput>median_of_three</computeroutput> function to determine the pseudo median.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>RandItr</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the random-access iterator. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the comparator. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to the beginning of the range. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to the end of the range. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmp</parametername>
</parameternamelist>
<parameterdescription>
<para>The comparator used to compare the dereferenced iterator values. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The iterator pointing to the pseudo median of the range.</para>
</simplesect>
<simplesect kind="attention"><para>The pseudo median is an approximation of the true median and may not be the exact middle value of the range. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/math.hpp" line="156" column="9" bodyfile="taskflow/utility/math.hpp" bodystart="156" bodyend="165"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a8d3fa9252b0da87bff1df912d0a591fe" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Iter</type>
          </param>
          <param>
            <type>typename Compare</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::sort2</definition>
        <argsstring>(Iter a, Iter b, Compare comp)</argsstring>
        <name>sort2</name>
        <param>
          <type>Iter</type>
          <declname>a</declname>
        </param>
        <param>
          <type>Iter</type>
          <declname>b</declname>
        </param>
        <param>
          <type>Compare</type>
          <declname>comp</declname>
        </param>
        <briefdescription>
<para>sorts two elements of dereferenced iterators using the given comparison function </para>
        </briefdescription>
        <detaileddescription>
<para>This function compares two elements pointed to by iterators and swaps them if they are out of order according to the provided comparator.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Iter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Compare</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the comparator. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to the first element. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to the second element. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para>The comparator used to compare the dereferenced iterator values. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/math.hpp" line="181" column="6" bodyfile="taskflow/utility/math.hpp" bodystart="181" bodyend="183"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a86489af717270b8c9b657b347215ef0f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Iter</type>
          </param>
          <param>
            <type>typename Compare</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::sort3</definition>
        <argsstring>(Iter a, Iter b, Iter c, Compare comp)</argsstring>
        <name>sort3</name>
        <param>
          <type>Iter</type>
          <declname>a</declname>
        </param>
        <param>
          <type>Iter</type>
          <declname>b</declname>
        </param>
        <param>
          <type>Iter</type>
          <declname>c</declname>
        </param>
        <param>
          <type>Compare</type>
          <declname>comp</declname>
        </param>
        <briefdescription>
<para>Sorts three elements of dereferenced iterators using the given comparison function. </para>
        </briefdescription>
        <detaileddescription>
<para>This function sorts three elements pointed to by iterators in ascending order according to the provided comparator. The sorting is performed using a sequence of calls to the <computeroutput>sort2</computeroutput> function to ensure the correct order of elements.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Iter</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the iterator. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Compare</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the comparator. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>a</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to the first element. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to the second element. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>Iterator to the third element. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para>The comparator used to compare the dereferenced iterator values. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/math.hpp" line="201" column="6" bodyfile="taskflow/utility/math.hpp" bodystart="201" bodyend="205"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a00b75b92482d883f06282d5181e6f6f9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_integral_v&lt; T &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T tf::unique_id</definition>
        <argsstring>()</argsstring>
        <name>unique_id</name>
        <briefdescription>
<para>generates a program-wide unique ID of the given type in a thread-safe manner </para>
        </briefdescription>
        <detaileddescription>
<para>This function provides a globally unique identifier of the specified integral type. It uses a static <computeroutput><ref refid="cpp/atomic/atomic" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::atomic</ref></computeroutput> counter to ensure thread safety and increments the counter in a relaxed memory ordering for efficiency.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the ID to generate. Must be an integral type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A unique ID of type <computeroutput>T</computeroutput>.</para>
</simplesect>
<simplesect kind="attention"><para>The uniqueness of the ID is guaranteed only within the program&apos;s lifetime. </para>
</simplesect>
<simplesect kind="attention"><para>The function does not throw exceptions. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/math.hpp" line="222" column="3" bodyfile="taskflow/utility/math.hpp" bodystart="222" bodyend="225"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a5002af34dc323ff28e87ae83203b2c36" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::atomic_max</definition>
        <argsstring>(std::atomic&lt; T &gt; &amp;v, const T &amp;max_v) noexcept</argsstring>
        <name>atomic_max</name>
        <param>
          <type><ref refid="cpp/atomic/atomic" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::atomic</ref>&lt; T &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>max_v</declname>
        </param>
        <briefdescription>
<para>updates an atomic variable with the maximum value </para>
        </briefdescription>
        <detaileddescription>
<para>This function atomically updates the provided atomic variable <computeroutput>v</computeroutput> to hold the maximum of its current value and <computeroutput>max_v</computeroutput>. The update is performed using a relaxed memory ordering for efficiency in non-synchronizing contexts.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the atomic variable. Must be trivially copyable and comparable. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>The atomic variable to update. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>max_v</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to compare with the current value of <computeroutput>v</computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="attention"><para>If multiple threads call this function concurrently, the value of <computeroutput>v</computeroutput> will be the maximum value seen across all threads. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/math.hpp" line="243" column="13" bodyfile="taskflow/utility/math.hpp" bodystart="243" bodyend="249"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a512ffa0d24a237b098f5de656b8bdcb0" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::atomic_min</definition>
        <argsstring>(std::atomic&lt; T &gt; &amp;v, const T &amp;min_v) noexcept</argsstring>
        <name>atomic_min</name>
        <param>
          <type><ref refid="cpp/atomic/atomic" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::atomic</ref>&lt; T &gt; &amp;</type>
          <declname>v</declname>
        </param>
        <param>
          <type>const T &amp;</type>
          <declname>min_v</declname>
        </param>
        <briefdescription>
<para>updates an atomic variable with the minimum value </para>
        </briefdescription>
        <detaileddescription>
<para>This function atomically updates the provided atomic variable <computeroutput>v</computeroutput> to hold the minimum of its current value and <computeroutput>min_v</computeroutput>. The update is performed using a relaxed memory ordering for efficiency in non-synchronizing contexts.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the atomic variable. Must be trivially copyable and comparable. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>The atomic variable to update. </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>min_v</parametername>
</parameternamelist>
<parameterdescription>
<para>The value to compare with the current value of <computeroutput>v</computeroutput>.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="attention"><para>If multiple threads call this function concurrently, the value of <computeroutput>v</computeroutput> will be the minimum value seen across all threads. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/math.hpp" line="267" column="13" bodyfile="taskflow/utility/math.hpp" bodystart="267" bodyend="273"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a3f8e89aebc29d42259157723c874954d" prot="public" static="no" const="no" explicit="no" inline="yes" noexcept="yes" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T</type>
        <definition>T tf::seed</definition>
        <argsstring>() noexcept</argsstring>
        <name>seed</name>
        <briefdescription>
<para>generates a random seed based on the current system clock </para>
        </briefdescription>
        <detaileddescription>
<para>This function returns a seed value derived from the number of clock ticks since the epoch as measured by the system clock. The seed can be used to initialize random number generators.</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>The type of the returned seed. Must be an integral type. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>A seed value based on the system clock. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/math.hpp" line="287" column="10" bodyfile="taskflow/utility/math.hpp" bodystart="287" bodyend="289"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a0b8e46604b2d40f0a7f2cc4796003d49" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename</type>
            <defval>std::enable_if_t&lt;std::is_unsigned_v&lt;T&gt;&gt;</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto tf::ctz</definition>
        <argsstring>(T x)</argsstring>
        <name>ctz</name>
        <param>
          <type>T</type>
          <declname>x</declname>
        </param>
        <briefdescription>
<para>counts the number of trailing zeros in an integer. </para>
        </briefdescription>
        <detaileddescription>
<para>This function provides a portable implementation for counting the number of trailing zeros across different platforms and integer sizes (32-bit and 64-bit).</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>integer type (32-bit or 64-bit). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>x</parametername>
</parameternamelist>
<parameterdescription>
<para>non-zero integer to count trailing zeros from </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the number of trailing zeros in <computeroutput>x</computeroutput> </para>
</simplesect>
<simplesect kind="attention"><para>The behavior is undefined when <computeroutput>x</computeroutput> is 0. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/math.hpp" line="305" column="6" bodyfile="taskflow/utility/math.hpp" bodystart="305" bodyend="329"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a15c9131faea47635a65e6caf21b6f868" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr size_t</type>
        <definition>constexpr size_t tf::coprime</definition>
        <argsstring>(size_t N)</argsstring>
        <name>coprime</name>
        <param>
          <type>size_t</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>computes a coprime of a given number </para>
        </briefdescription>
        <detaileddescription>
<para>This function finds the largest number less than N that is coprime (i.e., has a greatest common divisor of 1) with <computeroutput>N</computeroutput>. If <computeroutput>N</computeroutput> is less than 3, it returns 1 as a default coprime.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>input number for which a coprime is to be found. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>the largest number &lt; <computeroutput>N</computeroutput> that is coprime to N </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/math.hpp" line="344" column="18" bodyfile="taskflow/utility/math.hpp" bodystart="344" bodyend="354"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1af96bfc2b11d1743ca2d344e08a484d5e" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>size_t</type>
            <declname>N</declname>
            <defname>N</defname>
          </param>
        </templateparamlist>
        <type>constexpr <ref refid="cpp/container/array" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::array</ref>&lt; size_t, N &gt;</type>
        <definition>constexpr std::array&lt;size_t, N&gt; tf::make_coprime_lut</definition>
        <argsstring>()</argsstring>
        <name>make_coprime_lut</name>
        <briefdescription>
<para>generates a compile-time array of coprimes for numbers from 0 to N-1 </para>
        </briefdescription>
        <detaileddescription>
<para>This function constructs a constexpr array where each element at index <computeroutput>i</computeroutput> contains a coprime of <computeroutput>i</computeroutput> (the largest number less than <computeroutput>i</computeroutput> that is coprime to it).</para>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>the size of the array to generate (should be greater than 0). </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a constexpr array of size <computeroutput>N</computeroutput> where each index holds a coprime of its value. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/math.hpp" line="366" column="22" bodyfile="taskflow/utility/math.hpp" bodystart="366" bodyend="373"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1abbef08f01c467fd4f746c3247af892bc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="cpp/string/basic_string" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::string</ref></type>
        <definition>std::string tf::get_env</definition>
        <argsstring>(const std::string &amp;str)</argsstring>
        <name>get_env</name>
        <param>
          <type>const <ref refid="cpp/string/basic_string" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::string</ref> &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>retrieves the value of an environment variable </para>
        </briefdescription>
        <detaileddescription>
<para>This function fetches the value of an environment variable by name. If the variable is not found, it returns an empty string.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>str</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the environment variable to retrieve. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>The value of the environment variable as a string, or an empty string if not found.</para>
</simplesect>
<simplesect kind="attention"><para>The implementation differs between Windows and POSIX platforms:<itemizedlist>
<listitem><para>On Windows, it uses <computeroutput>_dupenv_s</computeroutput> to fetch the value.</para>
</listitem><listitem><para>On POSIX, it uses <computeroutput>std::getenv</computeroutput>. </para>
</listitem></itemizedlist>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/os.hpp" line="191" column="20" bodyfile="taskflow/utility/os.hpp" bodystart="191" bodyend="207"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1adc9815b9f96b796675ba939078d25413" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool tf::has_env</definition>
        <argsstring>(const std::string &amp;str)</argsstring>
        <name>has_env</name>
        <param>
          <type>const <ref refid="cpp/string/basic_string" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::string</ref> &amp;</type>
          <declname>str</declname>
        </param>
        <briefdescription>
<para>checks whether an environment variable is defined </para>
        </briefdescription>
        <detaileddescription>
<para>This function determines if a specific environment variable exists in the current environment.</para>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>str</parametername>
</parameternamelist>
<parameterdescription>
<para>The name of the environment variable to check. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><computeroutput>true</computeroutput> if the environment variable exists, <computeroutput>false</computeroutput> otherwise.</para>
</simplesect>
<simplesect kind="attention"><para>The implementation differs between Windows and POSIX platforms:<itemizedlist>
<listitem><para>On Windows, it uses <computeroutput>_dupenv_s</computeroutput> to check for the variable&apos;s presence.</para>
</listitem><listitem><para>On POSIX, it uses <computeroutput>std::getenv</computeroutput> to check for the variable&apos;s presence. </para>
</listitem></itemizedlist>
</para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/os.hpp" line="221" column="13" bodyfile="taskflow/utility/os.hpp" bodystart="221" bodyend="237"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aef9af2433294beb7d41680e5b33eafdd" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>tf::pause</definition>
        <argsstring>()</argsstring>
        <name>pause</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
<para>This function is used in spin-wait loops to hint the CPU that the current thread is in a busy-wait state. It helps reduce power consumption and improves performance on hyper-threaded processors by preventing the CPU from consuming unnecessary cycles while waiting. It is particularly useful in low-contention scenarios, where the thread is likely to quickly acquire the lock or condition it&apos;s waiting for, avoiding an expensive context switch. On modern x86 processors, this instruction can be invoked using <computeroutput>__builtin_ia32_pause()</computeroutput> in GCC/Clang or <computeroutput>_mm_pause()</computeroutput> in MSVC. In non-x86 architectures, alternative mechanisms such as yielding the CPU may be used instead. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/os.hpp" line="254" column="13" bodyfile="taskflow/utility/os.hpp" bodystart="254" bodyend="277"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1ae9b372cf6337d0fd563fecc59a1915cc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::pause</definition>
        <argsstring>(size_t count)</argsstring>
        <name>pause</name>
        <param>
          <type>size_t</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>pause CPU for a specified number of iterations </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/os.hpp" line="282" column="13" bodyfile="taskflow/utility/os.hpp" bodystart="282" bodyend="284"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a3abe09ef55c4f46e64ba88bff175c4f6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::spin_until</definition>
        <argsstring>(P &amp;&amp;predicate)</argsstring>
        <name>spin_until</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>predicate</declname>
        </param>
        <briefdescription>
<para>spins until the given predicate becomes true </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>the type of the predicate function or callable. </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>predicate</parametername>
</parameternamelist>
<parameterdescription>
<para>the callable that returns a boolean value, which is checked in the loop.</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This function repeatedly checks the provided predicate in a spin-wait loop and uses a backoff strategy to minimize CPU waste during the wait. Initially, it uses the <computeroutput><ref refid="namespacetf_1aef9af2433294beb7d41680e5b33eafdd" kindref="member">pause()</ref></computeroutput> instruction for the first 100 iterations to hint to the CPU that the thread is waiting, thus reducing power consumption and avoiding unnecessary cycles. After 100 iterations, it switches to yielding the CPU using <computeroutput><ref refid="cpp/thread/yield" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::this_thread::yield()</ref></computeroutput> to allow other threads to run and improve system responsiveness.</para>
<para>The function operates as follows:<orderedlist>
<listitem><para>For the first 100 iterations, it invokes <computeroutput><ref refid="namespacetf_1aef9af2433294beb7d41680e5b33eafdd" kindref="member">pause()</ref></computeroutput> to reduce power consumption during the spin-wait.</para>
</listitem><listitem><para>After 100 iterations, it uses <computeroutput><ref refid="cpp/thread/yield" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::this_thread::yield()</ref></computeroutput> to relinquish the CPU, allowing other threads to execute.</para>
</listitem></orderedlist>
</para>
<para><simplesect kind="attention"><para>This function is useful when you need to wait for a condition to be true, but want to optimize CPU usage during the wait by using a busy-wait approach. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/os.hpp" line="311" column="6" bodyfile="taskflow/utility/os.hpp" bodystart="311" bodyend="316"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a5643bf94c64370ee721692e3e6d9dc80" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename S</type>
          </param>
        </templateparamlist>
        <type>constexpr std::enable_if_t&lt; std::is_integral_v&lt; std::decay_t&lt; B &gt; &gt; &amp;&amp;std::is_integral_v&lt; std::decay_t&lt; E &gt; &gt; &amp;&amp;std::is_integral_v&lt; std::decay_t&lt; S &gt; &gt;, bool &gt;</type>
        <definition>constexpr std::enable_if_t&lt;std::is_integral_v&lt;std::decay_t&lt;B&gt; &gt; &amp;&amp; std::is_integral_v&lt;std::decay_t&lt;E&gt; &gt; &amp;&amp; std::is_integral_v&lt;std::decay_t&lt;S&gt; &gt;, bool&gt; tf::is_index_range_invalid</definition>
        <argsstring>(B beg, E end, S step)</argsstring>
        <name>is_index_range_invalid</name>
        <param>
          <type>B</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>E</type>
          <declname>end</declname>
        </param>
        <param>
          <type>S</type>
          <declname>step</declname>
        </param>
        <briefdescription>
<para>checks if the given index range is invalid </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the beginning index </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the ending index </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>S</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the step size</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>starting index of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>ending index of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>step</parametername>
</parameternamelist>
<parameterdescription>
<para>step size to traverse the range</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>returns <computeroutput>true</computeroutput> if the range is invalid; <computeroutput>false</computeroutput> otherwise.</para>
</simplesect>
A range is considered invalid under the following conditions:<itemizedlist>
<listitem><para>The step is zero and the begin and end values are not equal.</para>
</listitem><listitem><para>A positive range (begin &lt; end) with a non-positive step.</para>
</listitem><listitem><para>A negative range (begin &gt; end) with a non-negative step. </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/iterator.hpp" line="30" column="1" bodyfile="taskflow/utility/iterator.hpp" bodystart="30" bodyend="34"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a02a73acf6a05a3a4c673068daaad866f" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename S</type>
          </param>
        </templateparamlist>
        <type>constexpr std::enable_if_t&lt; std::is_integral_v&lt; std::decay_t&lt; B &gt; &gt; &amp;&amp;std::is_integral_v&lt; std::decay_t&lt; E &gt; &gt; &amp;&amp;std::is_integral_v&lt; std::decay_t&lt; S &gt; &gt;, size_t &gt;</type>
        <definition>constexpr std::enable_if_t&lt;std::is_integral_v&lt;std::decay_t&lt;B&gt; &gt; &amp;&amp; std::is_integral_v&lt;std::decay_t&lt;E&gt; &gt; &amp;&amp; std::is_integral_v&lt;std::decay_t&lt;S&gt; &gt;, size_t&gt; tf::distance</definition>
        <argsstring>(B beg, E end, S step)</argsstring>
        <name>distance</name>
        <param>
          <type>B</type>
          <declname>beg</declname>
        </param>
        <param>
          <type>E</type>
          <declname>end</declname>
        </param>
        <param>
          <type>S</type>
          <declname>step</declname>
        </param>
        <briefdescription>
<para>calculates the number of iterations in the given index range </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the beginning index </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the ending index </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>S</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the step size</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>beg</parametername>
</parameternamelist>
<parameterdescription>
<para>starting index of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>end</parametername>
</parameternamelist>
<parameterdescription>
<para>ending index of the range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>step</parametername>
</parameternamelist>
<parameterdescription>
<para>step size to traverse the range</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>returns the number of required iterations to traverse the range</para>
</simplesect>
The distance of a range represents the number of required iterations to traverse the range from the beginning index to the ending index (exclusive) with the given step size.</para>
<para>Example 1: <programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>Range:<sp/>0<sp/>to<sp/>10<sp/>with<sp/>step<sp/>size<sp/>2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>dist<sp/>=<sp/><ref refid="namespacetf_1a02a73acf6a05a3a4c673068daaad866f" kindref="member">distance</ref>(0,<sp/>10,<sp/>2);<sp/><sp/></highlight><highlight class="comment">//<sp/>Returns<sp/>5,<sp/>the<sp/>sequence<sp/>is<sp/>[0,<sp/>2,<sp/>4,<sp/>6,<sp/>8]</highlight></codeline>
</programlisting></para>
<para>Example 2: <programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>Range:<sp/>10<sp/>to<sp/>0<sp/>with<sp/>step<sp/>size<sp/>-2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>dist<sp/>=<sp/><ref refid="namespacetf_1a02a73acf6a05a3a4c673068daaad866f" kindref="member">distance</ref>(10,<sp/>0,<sp/>-2);<sp/><sp/></highlight><highlight class="comment">//<sp/>Returns<sp/>5,<sp/>the<sp/>sequence<sp/>is<sp/>[10,<sp/>8,<sp/>6,<sp/>4,<sp/>2]</highlight></codeline>
</programlisting></para>
<para>Example 3: <programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>Range:<sp/>5<sp/>to<sp/>20<sp/>with<sp/>step<sp/>size<sp/>5</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>dist<sp/>=<sp/><ref refid="namespacetf_1a02a73acf6a05a3a4c673068daaad866f" kindref="member">distance</ref>(5,<sp/>20,<sp/>5);<sp/><sp/></highlight><highlight class="comment">//<sp/>Returns<sp/>3,<sp/>the<sp/>sequence<sp/>is<sp/>[5,<sp/>10,<sp/>15]</highlight></codeline>
</programlisting></para>
<para><simplesect kind="attention"><para>It is user&apos;s responsibility to ensure the given index range is valid. For instance, a range from 0 to 10 with a step size of -2 is invalid. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/utility/iterator.hpp" line="78" column="1" bodyfile="taskflow/utility/iterator.hpp" bodystart="78" bodyend="80"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a7f414301de196737b08e62431691feba" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>ArgsT</declname>
            <defname>ArgsT</defname>
          </param>
        </templateparamlist>
        <type>TF_FORCE_INLINE Node *</type>
        <definition>TF_FORCE_INLINE Node* tf::animate</definition>
        <argsstring>(ArgsT &amp;&amp;... args)</argsstring>
        <name>animate</name>
        <param>
          <type>ArgsT &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/graph.hpp" line="356" column="22" bodyfile="taskflow/core/graph.hpp" bodystart="356" bodyend="362"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a445fe5f14e30fe86b18bf7c35df34ad5" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>TF_FORCE_INLINE void</type>
        <definition>TF_FORCE_INLINE void tf::recycle</definition>
        <argsstring>(Node *ptr)</argsstring>
        <name>recycle</name>
        <param>
          <type>Node *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/graph.hpp" line="367" column="22" bodyfile="taskflow/core/graph.hpp" bodystart="367" bodyend="373"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a97960776f3c78e18e68c79c336ba4f2d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>ArgsT</declname>
            <defname>ArgsT</defname>
          </param>
        </templateparamlist>
        <type><ref refid="cpp/memory/unique_ptr" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::unique_ptr</ref>&lt; T &gt;</type>
        <definition>std::unique_ptr&lt;T&gt; tf::make_worker_interface</definition>
        <argsstring>(ArgsT &amp;&amp;... args)</argsstring>
        <name>make_worker_interface</name>
        <param>
          <type>ArgsT &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>helper function to create an instance derived from <ref refid="classtf_1_1WorkerInterface" kindref="compound">tf::WorkerInterface</ref> </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>type derived from <ref refid="classtf_1_1WorkerInterface" kindref="compound">tf::WorkerInterface</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ArgsT</parametername>
</parameternamelist>
<parameterdescription>
<para>argument types to construct <computeroutput>T</computeroutput> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>arguments to forward to the constructor of <computeroutput>T</computeroutput> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/worker.hpp" line="244" column="17" bodyfile="taskflow/core/worker.hpp" bodystart="244" bodyend="250"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a9ca58dc6c666698cc7373eb0262140ef" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const char *</type>
        <definition>const char* tf::to_string</definition>
        <argsstring>(TaskType type)</argsstring>
        <name>to_string</name>
        <param>
          <type><ref refid="namespacetf_1a1355048578785a80414707ff308b395a" kindref="member">TaskType</ref></type>
          <declname>type</declname>
        </param>
        <briefdescription>
<para>convert a task type to a human-readable string </para>
        </briefdescription>
        <detaileddescription>
<para>The name of each task type is the litte-case string of its characters.<itemizedlist>
<listitem><para><ref refid="namespacetf_1a1355048578785a80414707ff308b395aae54e6f6ba0c7cbb4eb7a2016e2f17842" kindref="member">TaskType::PLACEHOLDER</ref> is of string <computeroutput>placeholder</computeroutput></para>
</listitem><listitem><para><ref refid="namespacetf_1a1355048578785a80414707ff308b395aafe6f99ef1ec99efbdc19a9786cf1facc" kindref="member">TaskType::STATIC</ref> is of string <computeroutput>static</computeroutput></para>
</listitem><listitem><para><ref refid="namespacetf_1a1355048578785a80414707ff308b395aae5f5cd9fe71ac064a678f27c7d539ae8" kindref="member">TaskType::RUNTIME</ref> is of string <computeroutput>runtime</computeroutput></para>
</listitem><listitem><para><ref refid="namespacetf_1a1355048578785a80414707ff308b395aa46be697979903d784a70aeec45eb14ad" kindref="member">TaskType::SUBFLOW</ref> is of string <computeroutput>subflow</computeroutput></para>
</listitem><listitem><para><ref refid="namespacetf_1a1355048578785a80414707ff308b395aa9f768c0bb1c3e84ca086a85211e978ac" kindref="member">TaskType::CONDITION</ref> is of string <computeroutput>condition</computeroutput></para>
</listitem><listitem><para><ref refid="namespacetf_1a1355048578785a80414707ff308b395aa1cf5e1f5569acda3c4a88a91c5130a69" kindref="member">TaskType::MODULE</ref> is of string <computeroutput>module</computeroutput></para>
</listitem><listitem><para><ref refid="namespacetf_1a1355048578785a80414707ff308b395aabe553330beb7b3d994656e0a4e66cd96" kindref="member">TaskType::ASYNC</ref> is of string <computeroutput>async</computeroutput> </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/task.hpp" line="66" column="19" bodyfile="taskflow/core/task.hpp" bodystart="66" bodyend="82"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1ad216aea4d0f648e149e47374ad015b1f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostream</ref> &amp;</type>
        <definition>std::ostream&amp; tf::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const Task &amp;task)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostream</ref> &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classtf_1_1Task" kindref="compound">Task</ref> &amp;</type>
          <declname>task</declname>
        </param>
        <briefdescription>
<para>overload of ostream inserter operator for <ref refid="classtf_1_1Task" kindref="compound">Task</ref> </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/task.hpp" line="1183" column="8" bodyfile="taskflow/core/task.hpp" bodystart="1183" bodyend="1186"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aa3fc0699b2c2b8f2f76bb39f91be1acb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>const char *</type>
        <definition>const char* tf::to_string</definition>
        <argsstring>(ObserverType type)</argsstring>
        <name>to_string</name>
        <param>
          <type><ref refid="namespacetf_1a192f7cb0fab2eb6f1c84f6046706435d" kindref="member">ObserverType</ref></type>
          <declname>type</declname>
        </param>
        <briefdescription>
<para>convert an observer type to a human-readable string </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/observer.hpp" line="1041" column="19" bodyfile="taskflow/core/observer.hpp" bodystart="1041" bodyend="1047"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a8975fa5762088789adb0b60f38208309" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Input</type>
          </param>
          <param>
            <type>typename Output</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto tf::make_data_pipe</definition>
        <argsstring>(PipeType d, C &amp;&amp;callable)</argsstring>
        <name>make_data_pipe</name>
        <param>
          <type><ref refid="namespacetf_1abb7a11e41fd457f69e7ff45d4c769564" kindref="member">PipeType</ref></type>
          <declname>d</declname>
        </param>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>function to construct a data pipe (<ref refid="classtf_1_1DataPipe" kindref="compound">tf::DataPipe</ref>) </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Input</parametername>
</parameternamelist>
<parameterdescription>
<para>input data type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Output</parametername>
</parameternamelist>
<parameterdescription>
<para>output data type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<ref refid="namespacetf_1a8975fa5762088789adb0b60f38208309" kindref="member">tf::make_data_pipe</ref> is a helper function to create a data pipe (<ref refid="classtf_1_1DataPipe" kindref="compound">tf::DataPipe</ref>) in a data-parallel pipeline (<ref refid="classtf_1_1DataPipeline" kindref="compound">tf::DataPipeline</ref>). The first argument specifies the direction of the data pipe, either <ref refid="namespacetf_1abb7a11e41fd457f69e7ff45d4c769564a7b804a28d6154ab8007287532037f1d0" kindref="member">tf::PipeType::SERIAL</ref> or <ref refid="namespacetf_1abb7a11e41fd457f69e7ff45d4c769564adf13a99b035d6f0bce4f44ab18eec8eb" kindref="member">tf::PipeType::PARALLEL</ref>, and the second argument is a callable to invoke by the pipeline scheduler. Input and output data types are specified via template parameters, which will always be decayed by the library to its original form for storage purpose. The callable must take the input data type in its first argument and returns a value of the output data type.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">tf::make_data_pipe&lt;int,<sp/>std::string&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacetf_1abb7a11e41fd457f69e7ff45d4c769564a7b804a28d6154ab8007287532037f1d0" kindref="member">tf::PipeType::SERIAL</ref>,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[](</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">&amp;<sp/>input)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="namespacetf_1a9ca58dc6c666698cc7373eb0262140ef" kindref="member">std::to_string</ref>(input<sp/>+<sp/>100);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
</programlisting></para>
<para>The callable can additionally take a reference of <ref refid="classtf_1_1Pipeflow" kindref="compound">tf::Pipeflow</ref>, which allows you to query the runtime information of a stage task, such as its line number and token number.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">tf::make_data_pipe&lt;int,<sp/>std::string&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="namespacetf_1abb7a11e41fd457f69e7ff45d4c769564a7b804a28d6154ab8007287532037f1d0" kindref="member">tf::PipeType::SERIAL</ref>,<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[](</highlight><highlight class="keywordtype">int</highlight><highlight class="normal">&amp;<sp/>input,<sp/><ref refid="classtf_1_1Pipeflow" kindref="compound">tf::Pipeflow</ref>&amp;<sp/>pf)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;token=%lu,<sp/>line=%lu\n&quot;</highlight><highlight class="normal">,<sp/>pf.<ref refid="classtf_1_1Pipeflow_1a295e5d884665c076f4ef5d78139f7c51" kindref="member">token</ref>(),<sp/>pf.<ref refid="classtf_1_1Pipeflow_1afee054e6a99965d4b3e36ff903227e6c" kindref="member">line</ref>());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="namespacetf_1a9ca58dc6c666698cc7373eb0262140ef" kindref="member">std::to_string</ref>(input<sp/>+<sp/>100);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/algorithm/data_pipeline.hpp" line="171" column="6" bodyfile="taskflow/algorithm/data_pipeline.hpp" bodystart="171" bodyend="173"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a68bb6933d40ea4468cc08191a0822f10" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto tf::Algorithm::make_module_task</definition>
        <argsstring>(T &amp;&amp;graph)</argsstring>
        <name>make_module_task</name>
        <param>
          <type>T &amp;&amp;</type>
          <declname>graph</declname>
        </param>
        <briefdescription>
<para>creates a module task using the given graph </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>type of the graph object, which must define the method <computeroutput><ref refid="classtf_1_1Graph" kindref="compound">tf::Graph</ref>&amp; graph()</computeroutput> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>graph</parametername>
</parameternamelist>
<parameterdescription>
<para>the graph object used to create the module task </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a module task that can be used by Taskflow or asynchronous tasking</para>
</simplesect>
This example demonstrates how to create and launch multiple taskflows in parallel using modules with asynchronous tasking:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/>executor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>A;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>B;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>C;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>D;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">A.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;Taskflow<sp/>A\n&quot;</highlight><highlight class="normal">);<sp/>});<sp/></highlight></codeline>
<codeline><highlight class="normal">B.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;Taskflow<sp/>B\n&quot;</highlight><highlight class="normal">);<sp/>});<sp/></highlight></codeline>
<codeline><highlight class="normal">C.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;Taskflow<sp/>C\n&quot;</highlight><highlight class="normal">);<sp/>});<sp/></highlight></codeline>
<codeline><highlight class="normal">D.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;Taskflow<sp/>D\n&quot;</highlight><highlight class="normal">);<sp/>});<sp/></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>launch<sp/>the<sp/>four<sp/>taskflows<sp/>using<sp/>asynchronous<sp/>tasking</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1af960048056f7c6b5bc71f4f526f05df7" kindref="member">async</ref>(<ref refid="namespacetf_1a68bb6933d40ea4468cc08191a0822f10" kindref="member">tf::make_module_task</ref>(A));</highlight></codeline>
<codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1af960048056f7c6b5bc71f4f526f05df7" kindref="member">async</ref>(<ref refid="namespacetf_1a68bb6933d40ea4468cc08191a0822f10" kindref="member">tf::make_module_task</ref>(B));</highlight></codeline>
<codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1af960048056f7c6b5bc71f4f526f05df7" kindref="member">async</ref>(<ref refid="namespacetf_1a68bb6933d40ea4468cc08191a0822f10" kindref="member">tf::make_module_task</ref>(C));</highlight></codeline>
<codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1af960048056f7c6b5bc71f4f526f05df7" kindref="member">async</ref>(<ref refid="namespacetf_1a68bb6933d40ea4468cc08191a0822f10" kindref="member">tf::make_module_task</ref>(D));</highlight></codeline>
<codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1ab9aa252f70e9a40020a1e5a89d485b85" kindref="member">wait_for_all</ref>();<sp/><sp/></highlight></codeline>
</programlisting></para>
<para>The module task maker, <ref refid="namespacetf_1a68bb6933d40ea4468cc08191a0822f10" kindref="member">tf::make_module_task</ref>, is basically the same as <ref refid="classtf_1_1FlowBuilder_1ac6f22228d4c2ea2e643c4b0d42c0e92a" kindref="member">tf::Taskflow::composed_of</ref> but provides a more generic interface that can be used beyond Taskflow. For instance, the following two approaches achieve the same functionality.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>approach<sp/>1:<sp/>composition<sp/>using<sp/>composed_of</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>m1<sp/>=<sp/>taskflow1.<ref refid="classtf_1_1Task_1ab38be520fe700cb4ca1f312308a95585" kindref="member">composed_of</ref>(taskflow2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>approach<sp/>2:<sp/>composition<sp/>using<sp/>make_module_task</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>m1<sp/>=<sp/>taskflow1.emplace(<ref refid="namespacetf_1a68bb6933d40ea4468cc08191a0822f10" kindref="member">tf::make_module_task</ref>(taskflow2));</highlight></codeline>
</programlisting></para>
<para><simplesect kind="attention"><para>Users are responsible for ensuring that the given target remains valid throughout its execution. The executor does not assume ownership of the target object. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/algorithm/module.hpp" line="75" column="6" bodyfile="taskflow/algorithm/module.hpp" bodystart="75" bodyend="77"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1abffa70155a5f160b7ceb86ee52ab2136" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_num_devices</definition>
        <argsstring>()</argsstring>
        <name>cuda_get_num_devices</name>
        <briefdescription>
<para>queries the number of available devices </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_device.hpp" line="15" column="15" bodyfile="taskflow/cuda/cuda_device.hpp" bodystart="15" bodyend="19"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a235f5a9ce203d538eec1f4114221d473" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int tf::cuda_get_device</definition>
        <argsstring>()</argsstring>
        <name>cuda_get_device</name>
        <briefdescription>
<para>gets the current device associated with the caller thread </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_device.hpp" line="24" column="12" bodyfile="taskflow/cuda/cuda_device.hpp" bodystart="24" bodyend="28"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1ade2938289fa49aafc9b2b7b090deaa22" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::cuda_set_device</definition>
        <argsstring>(int id)</argsstring>
        <name>cuda_set_device</name>
        <param>
          <type>int</type>
          <declname>id</declname>
        </param>
        <briefdescription>
<para>switches to a given device context </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_device.hpp" line="33" column="13" bodyfile="taskflow/cuda/cuda_device.hpp" bodystart="33" bodyend="35"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a403b679694f4c85c857163b47e84d566" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::cuda_get_device_property</definition>
        <argsstring>(int i, cudaDeviceProp &amp;p)</argsstring>
        <name>cuda_get_device_property</name>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <param>
          <type>cudaDeviceProp &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>obtains the device property </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_device.hpp" line="40" column="13" bodyfile="taskflow/cuda/cuda_device.hpp" bodystart="40" bodyend="44"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a0e82b8a929e12349240276e34ec9f8c8" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>cudaDeviceProp</type>
        <definition>cudaDeviceProp tf::cuda_get_device_property</definition>
        <argsstring>(int i)</argsstring>
        <name>cuda_get_device_property</name>
        <param>
          <type>int</type>
          <declname>i</declname>
        </param>
        <briefdescription>
<para>obtains the device property </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_device.hpp" line="49" column="23" bodyfile="taskflow/cuda/cuda_device.hpp" bodystart="49" bodyend="55"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aff8073c78daa741df76b530a0e602287" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::cuda_dump_device_property</definition>
        <argsstring>(std::ostream &amp;os, const cudaDeviceProp &amp;p)</argsstring>
        <name>cuda_dump_device_property</name>
        <param>
          <type><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostream</ref> &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const cudaDeviceProp &amp;</type>
          <declname>p</declname>
        </param>
        <briefdescription>
<para>dumps the device property </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_device.hpp" line="60" column="13" bodyfile="taskflow/cuda/cuda_device.hpp" bodystart="60" bodyend="93"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1abf813f7ac4249d1b752d1b724f970deb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_threads_per_block</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_threads_per_block</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum threads per block on a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_device.hpp" line="98" column="15" bodyfile="taskflow/cuda/cuda_device.hpp" bodystart="98" bodyend="105"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1af8184bb128c446fe383315f3dc15acf6" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_x_dim_per_block</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_x_dim_per_block</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum x-dimension per block on a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_device.hpp" line="110" column="15" bodyfile="taskflow/cuda/cuda_device.hpp" bodystart="110" bodyend="117"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a9aba5f29135b9da29015c2a367ab1d70" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_y_dim_per_block</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_y_dim_per_block</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum y-dimension per block on a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_device.hpp" line="122" column="15" bodyfile="taskflow/cuda/cuda_device.hpp" bodystart="122" bodyend="129"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a5580f59e633625b2f344bbf477d17c2f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_z_dim_per_block</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_z_dim_per_block</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum z-dimension per block on a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_device.hpp" line="134" column="15" bodyfile="taskflow/cuda/cuda_device.hpp" bodystart="134" bodyend="141"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a597579c8a9ab31244418e30a5aa74491" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_x_dim_per_grid</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_x_dim_per_grid</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum x-dimension per grid on a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_device.hpp" line="146" column="15" bodyfile="taskflow/cuda/cuda_device.hpp" bodystart="146" bodyend="153"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a91d5c1609a7542949dd56d08b7c4c645" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_y_dim_per_grid</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_y_dim_per_grid</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum y-dimension per grid on a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_device.hpp" line="158" column="15" bodyfile="taskflow/cuda/cuda_device.hpp" bodystart="158" bodyend="165"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a0373e32a20c7fc90c4f0461ee41bb918" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_z_dim_per_grid</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_z_dim_per_grid</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum z-dimension per grid on a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_device.hpp" line="170" column="15" bodyfile="taskflow/cuda/cuda_device.hpp" bodystart="170" bodyend="177"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aeca46ac171c4941a75aafddfe7546bfa" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_max_shm_per_block</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_max_shm_per_block</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the maximum shared memory size in bytes per block on a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_device.hpp" line="182" column="15" bodyfile="taskflow/cuda/cuda_device.hpp" bodystart="182" bodyend="189"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aea1b2af1073496f047d6fb9984cff4f1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_device_warp_size</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_warp_size</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the warp size on a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_device.hpp" line="194" column="15" bodyfile="taskflow/cuda/cuda_device.hpp" bodystart="194" bodyend="201"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a1fb03793a6b8705026b80ef87599d4d5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int tf::cuda_get_device_compute_capability_major</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_compute_capability_major</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the major number of compute capability of a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_device.hpp" line="206" column="12" bodyfile="taskflow/cuda/cuda_device.hpp" bodystart="206" bodyend="213"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a71f5177665f4f7e18984ccc57d625602" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int tf::cuda_get_device_compute_capability_minor</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_compute_capability_minor</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the minor number of compute capability of a device </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_device.hpp" line="218" column="12" bodyfile="taskflow/cuda/cuda_device.hpp" bodystart="218" bodyend="225"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1ad389294b4d1c14219d8d098f796e27c5" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool tf::cuda_get_device_unified_addressing</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_device_unified_addressing</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries if the device supports unified addressing </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_device.hpp" line="230" column="13" bodyfile="taskflow/cuda/cuda_device.hpp" bodystart="230" bodyend="237"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a43ac57f0eca3aa83c04bec3c4da9ab82" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int tf::cuda_get_driver_version</definition>
        <argsstring>()</argsstring>
        <name>cuda_get_driver_version</name>
        <briefdescription>
<para>queries the latest CUDA version (1000 * major + 10 * minor) supported by the driver </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_device.hpp" line="246" column="12" bodyfile="taskflow/cuda/cuda_device.hpp" bodystart="246" bodyend="253"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a31258ad089c6f847c8cd636cd72d6949" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>int</type>
        <definition>int tf::cuda_get_runtime_version</definition>
        <argsstring>()</argsstring>
        <name>cuda_get_runtime_version</name>
        <briefdescription>
<para>queries the CUDA <ref refid="classtf_1_1Runtime" kindref="compound">Runtime</ref> version (1000 * major + 10 * minor) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_device.hpp" line="258" column="12" bodyfile="taskflow/cuda/cuda_device.hpp" bodystart="258" bodyend="264"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a1effcf929b7e488925f9e12d74c8c62b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_free_mem</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_free_mem</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the free memory (expensive call) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_memory.hpp" line="19" column="15" bodyfile="taskflow/cuda/cuda_memory.hpp" bodystart="19" bodyend="26"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a58bbc8d5d955582d6b5f7fdac51d010b" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_get_total_mem</definition>
        <argsstring>(int d)</argsstring>
        <name>cuda_get_total_mem</name>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>queries the total available memory (expensive call) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_memory.hpp" line="31" column="15" bodyfile="taskflow/cuda/cuda_memory.hpp" bodystart="31" bodyend="38"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a6f04fd3168c45eeb2dffb223e5c81e45" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T *</type>
        <definition>T* tf::cuda_malloc_device</definition>
        <argsstring>(size_t N, int d)</argsstring>
        <name>cuda_malloc_device</name>
        <param>
          <type>size_t</type>
          <declname>N</declname>
        </param>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>allocates memory on the given device for holding <computeroutput>N</computeroutput> elements of type <computeroutput>T</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para>The function calls <computeroutput>cudaMalloc</computeroutput> to allocate <computeroutput>N*sizeof(T)</computeroutput> bytes of memory on the given device <computeroutput>d</computeroutput> and returns a pointer to the starting address of the device memory. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_memory.hpp" line="48" column="3" bodyfile="taskflow/cuda/cuda_memory.hpp" bodystart="48" bodyend="56"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1ab9b68b8f4336f13b190d573969cb1cf7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T *</type>
        <definition>T* tf::cuda_malloc_device</definition>
        <argsstring>(size_t N)</argsstring>
        <name>cuda_malloc_device</name>
        <param>
          <type>size_t</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>allocates memory on the current device associated with the caller </para>
        </briefdescription>
        <detaileddescription>
<para>The function calls malloc_device from the current device associated with the caller. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_memory.hpp" line="65" column="3" bodyfile="taskflow/cuda/cuda_memory.hpp" bodystart="65" bodyend="72"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a8eed05685b030fc44703213a4ef86f11" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>T *</type>
        <definition>T* tf::cuda_malloc_shared</definition>
        <argsstring>(size_t N)</argsstring>
        <name>cuda_malloc_shared</name>
        <param>
          <type>size_t</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>allocates shared memory for holding <computeroutput>N</computeroutput> elements of type <computeroutput>T</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para>The function calls <computeroutput>cudaMallocManaged</computeroutput> to allocate <computeroutput>N*sizeof(T)</computeroutput> bytes of memory and returns a pointer to the starting address of the shared memory. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_memory.hpp" line="81" column="3" bodyfile="taskflow/cuda/cuda_memory.hpp" bodystart="81" bodyend="88"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1ac7a8fe7456b888d6072ba94783c5003c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_free</definition>
        <argsstring>(T *ptr, int d)</argsstring>
        <name>cuda_free</name>
        <param>
          <type>T *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>d</declname>
        </param>
        <briefdescription>
<para>frees memory on the GPU device </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer type </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>device pointer to memory to free </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>d</parametername>
</parameternamelist>
<parameterdescription>
<para>device context identifier</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This methods call <computeroutput>cudaFree</computeroutput> to free the memory space pointed to by <computeroutput>ptr</computeroutput> using the given device context. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_memory.hpp" line="101" column="6" bodyfile="taskflow/cuda/cuda_memory.hpp" bodystart="101" bodyend="104"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1ae174a3a49b91ef21554dac16806f0d72" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cuda_free</definition>
        <argsstring>(T *ptr)</argsstring>
        <name>cuda_free</name>
        <param>
          <type>T *</type>
          <declname>ptr</declname>
        </param>
        <briefdescription>
<para>frees memory on the GPU device </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer type </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>device pointer to memory to free</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This methods call <computeroutput>cudaFree</computeroutput> to free the memory space pointed to by <computeroutput>ptr</computeroutput> using the current device context of the caller. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_memory.hpp" line="116" column="6" bodyfile="taskflow/cuda/cuda_memory.hpp" bodystart="116" bodyend="118"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aa4266474b921f8ed7d9ec8071fded2a4" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::cuda_memcpy_async</definition>
        <argsstring>(cudaStream_t stream, void *dst, const void *src, size_t count)</argsstring>
        <name>cuda_memcpy_async</name>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>src</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>copies data between host and device asynchronously through a stream </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stream</parametername>
</parameternamelist>
<parameterdescription>
<para>stream identifier </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>destination memory address </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>source memory address </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>size in bytes to copy</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The method calls <computeroutput>cudaMemcpyAsync</computeroutput> with the given <computeroutput>stream</computeroutput> using <computeroutput>cudaMemcpyDefault</computeroutput> to infer the memory space of the source and the destination pointers. The memory areas may not overlap. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_memory.hpp" line="132" column="13" bodyfile="taskflow/cuda/cuda_memory.hpp" bodystart="132" bodyend="139"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a6615554d2954e895755411ee444d9760" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::cuda_memset_async</definition>
        <argsstring>(cudaStream_t stream, void *devPtr, int value, size_t count)</argsstring>
        <name>cuda_memset_async</name>
        <param>
          <type>cudaStream_t</type>
          <declname>stream</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>devPtr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>value</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>initializes or sets GPU memory to the given value byte by byte </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>stream</parametername>
</parameternamelist>
<parameterdescription>
<para>stream identifier </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>devPtr</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to GPU memory </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>value</parametername>
</parameternamelist>
<parameterdescription>
<para>value to set for each byte of the specified memory </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>size in bytes to set</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The method calls <computeroutput>cudaMemsetAsync</computeroutput> with the given <computeroutput>stream</computeroutput> to fill the first <computeroutput>count</computeroutput> bytes of the memory area pointed to by <computeroutput>devPtr</computeroutput> with the constant byte value <computeroutput>value</computeroutput>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_memory.hpp" line="153" column="13" bodyfile="taskflow/cuda/cuda_memory.hpp" bodystart="153" bodyend="160"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aebe9b7a5647bec130362384b5ef12e6f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt;!std::is_same_v&lt; T, void &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>cudaMemcpy3DParms</type>
        <definition>cudaMemcpy3DParms tf::cuda_get_copy_parms</definition>
        <argsstring>(T *tgt, const T *src, size_t num)</argsstring>
        <name>cuda_get_copy_parms</name>
        <param>
          <type>T *</type>
          <declname>tgt</declname>
        </param>
        <param>
          <type>const T *</type>
          <declname>src</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>num</declname>
        </param>
        <briefdescription>
<para>gets the memcpy node parameter of a copy task </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_graph.hpp" line="23" column="19" bodyfile="taskflow/cuda/cuda_graph.hpp" bodystart="23" bodyend="39"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a6d7fe7b199f0264b24a831100083f813" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>cudaMemcpy3DParms</type>
        <definition>cudaMemcpy3DParms tf::cuda_get_memcpy_parms</definition>
        <argsstring>(void *tgt, const void *src, size_t bytes)</argsstring>
        <name>cuda_get_memcpy_parms</name>
        <param>
          <type>void *</type>
          <declname>tgt</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>src</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>bytes</declname>
        </param>
        <briefdescription>
<para>gets the memcpy node parameter of a memcpy task (untyped) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_graph.hpp" line="44" column="26" bodyfile="taskflow/cuda/cuda_graph.hpp" bodystart="44" bodyend="64"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1abdd529e729947d7b3123de89e43eb871" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>cudaMemsetParams</type>
        <definition>cudaMemsetParams tf::cuda_get_memset_parms</definition>
        <argsstring>(void *dst, int ch, size_t count)</argsstring>
        <name>cuda_get_memset_parms</name>
        <param>
          <type>void *</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>int</type>
          <declname>ch</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>gets the memset node parameter of a memcpy task (untyped) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_graph.hpp" line="69" column="25" bodyfile="taskflow/cuda/cuda_graph.hpp" bodystart="69" bodyend="82"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1abf3eeb8a29df53ea51239159ebb08431" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; is_pod_v&lt; T &gt; &amp;&amp;(sizeof(T)==1||sizeof(T)==2||sizeof(T)==4), void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>cudaMemsetParams</type>
        <definition>cudaMemsetParams tf::cuda_get_fill_parms</definition>
        <argsstring>(T *dst, T value, size_t count)</argsstring>
        <name>cuda_get_fill_parms</name>
        <param>
          <type>T *</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>T</type>
          <declname>value</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>gets the memset node parameter of a fill task (typed) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_graph.hpp" line="90" column="18" bodyfile="taskflow/cuda/cuda_graph.hpp" bodystart="90" bodyend="106"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a2e7a47a53034abe3218bcc583b0e9a56" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; is_pod_v&lt; T &gt; &amp;&amp;(sizeof(T)==1||sizeof(T)==2||sizeof(T)==4), void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>cudaMemsetParams</type>
        <definition>cudaMemsetParams tf::cuda_get_zero_parms</definition>
        <argsstring>(T *dst, size_t count)</argsstring>
        <name>cuda_get_zero_parms</name>
        <param>
          <type>T *</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>gets the memset node parameter of a zero task (typed) </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_graph.hpp" line="114" column="18" bodyfile="taskflow/cuda/cuda_graph.hpp" bodystart="114" bodyend="125"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a8c9a4702aab3ce76a55c62ec276cd9fc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_graph_get_num_root_nodes</definition>
        <argsstring>(cudaGraph_t graph)</argsstring>
        <name>cuda_graph_get_num_root_nodes</name>
        <param>
          <type>cudaGraph_t</type>
          <declname>graph</declname>
        </param>
        <briefdescription>
<para>queries the number of root nodes in a native CUDA graph </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_graph.hpp" line="130" column="15" bodyfile="taskflow/cuda/cuda_graph.hpp" bodystart="130" bodyend="137"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a874ee3b3ee52d7cf6b6a7cc13859365f" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_graph_get_num_nodes</definition>
        <argsstring>(cudaGraph_t graph)</argsstring>
        <name>cuda_graph_get_num_nodes</name>
        <param>
          <type>cudaGraph_t</type>
          <declname>graph</declname>
        </param>
        <briefdescription>
<para>queries the number of nodes in a native CUDA graph </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_graph.hpp" line="142" column="15" bodyfile="taskflow/cuda/cuda_graph.hpp" bodystart="142" bodyend="149"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aeba4e3df08c4e04885440c334b7cffbb" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_graph_get_num_edges</definition>
        <argsstring>(cudaGraph_t graph, cudaGraphNode_t *from, cudaGraphNode_t *to)</argsstring>
        <name>cuda_graph_get_num_edges</name>
        <param>
          <type>cudaGraph_t</type>
          <declname>graph</declname>
        </param>
        <param>
          <type>cudaGraphNode_t *</type>
          <declname>from</declname>
        </param>
        <param>
          <type>cudaGraphNode_t *</type>
          <declname>to</declname>
        </param>
        <briefdescription>
<para>Handles compatibility with CUDA &lt;= 12.x and CUDA == 13.x. </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_graph.hpp" line="154" column="15" bodyfile="taskflow/cuda/cuda_graph.hpp" bodystart="154" bodyend="162"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a32839c07767b69cf976af9d42e951f02" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_graph_node_get_dependencies</definition>
        <argsstring>(cudaGraphNode_t node, cudaGraphNode_t *dependencies)</argsstring>
        <name>cuda_graph_node_get_dependencies</name>
        <param>
          <type>cudaGraphNode_t</type>
          <declname>node</declname>
        </param>
        <param>
          <type>cudaGraphNode_t *</type>
          <declname>dependencies</declname>
        </param>
        <briefdescription>
<para>Handles compatibility with CUDA &lt;= 12.x and CUDA 13. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>node</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dependencies</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_graph.hpp" line="170" column="15" bodyfile="taskflow/cuda/cuda_graph.hpp" bodystart="170" bodyend="177"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a390af398467aa859f2232afccf48e703" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_graph_node_get_dependent_nodes</definition>
        <argsstring>(cudaGraphNode_t node, cudaGraphNode_t *dependent_nodes)</argsstring>
        <name>cuda_graph_node_get_dependent_nodes</name>
        <param>
          <type>cudaGraphNode_t</type>
          <declname>node</declname>
        </param>
        <param>
          <type>cudaGraphNode_t *</type>
          <declname>dependent_nodes</declname>
        </param>
        <briefdescription>
<para>Handles compatibility with CUDA &lt;= 12.x and CUDA 13. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>node</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>dependent_nodes</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para></para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_graph.hpp" line="185" column="15" bodyfile="taskflow/cuda/cuda_graph.hpp" bodystart="185" bodyend="192"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1aecc218218edbbfadb617edce05a88b03" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::cuda_graph_add_dependencies</definition>
        <argsstring>(cudaGraph_t graph, const cudaGraphNode_t *from, const cudaGraphNode_t *to, size_t numDependencies)</argsstring>
        <name>cuda_graph_add_dependencies</name>
        <param>
          <type>cudaGraph_t</type>
          <declname>graph</declname>
        </param>
        <param>
          <type>const cudaGraphNode_t *</type>
          <declname>from</declname>
        </param>
        <param>
          <type>const cudaGraphNode_t *</type>
          <declname>to</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>numDependencies</declname>
        </param>
        <briefdescription>
<para>Handles compatibility with CUDA &lt;= 12.x and CUDA 13. </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>graph</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>from</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>to</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>numDependencies</parametername>
</parameternamelist>
<parameterdescription>
<para></para>
</parameterdescription>
</parameteritem>
</parameterlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_graph.hpp" line="201" column="13" bodyfile="taskflow/cuda/cuda_graph.hpp" bodystart="201" bodyend="207"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a8fc7af3adc7dd7e646bd5275d8ae3f56" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cuda_graph_get_num_edges</definition>
        <argsstring>(cudaGraph_t graph)</argsstring>
        <name>cuda_graph_get_num_edges</name>
        <param>
          <type>cudaGraph_t</type>
          <declname>graph</declname>
        </param>
        <briefdescription>
<para>queries the number of edges in a native CUDA graph </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_graph.hpp" line="212" column="15" bodyfile="taskflow/cuda/cuda_graph.hpp" bodystart="212" bodyend="214"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1ad5459c5551b8416d586bbbbac34a4e33" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="cpp/container/vector" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector</ref>&lt; cudaGraphNode_t &gt;</type>
        <definition>std::vector&lt;cudaGraphNode_t&gt; tf::cuda_graph_get_nodes</definition>
        <argsstring>(cudaGraph_t graph)</argsstring>
        <name>cuda_graph_get_nodes</name>
        <param>
          <type>cudaGraph_t</type>
          <declname>graph</declname>
        </param>
        <briefdescription>
<para>acquires the nodes in a native CUDA graph </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_graph.hpp" line="221" column="20" bodyfile="taskflow/cuda/cuda_graph.hpp" bodystart="221" bodyend="229"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1afee3e3a745757ec5b6ae36e2b0b0808d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="cpp/container/vector" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector</ref>&lt; cudaGraphNode_t &gt;</type>
        <definition>std::vector&lt;cudaGraphNode_t&gt; tf::cuda_graph_get_root_nodes</definition>
        <argsstring>(cudaGraph_t graph)</argsstring>
        <name>cuda_graph_get_root_nodes</name>
        <param>
          <type>cudaGraph_t</type>
          <declname>graph</declname>
        </param>
        <briefdescription>
<para>acquires the root nodes in a native CUDA graph </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_graph.hpp" line="234" column="20" bodyfile="taskflow/cuda/cuda_graph.hpp" bodystart="234" bodyend="242"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a007dfebb3ef1ab54da66cdd604494b38" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="cpp/container/vector" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector</ref>&lt; <ref refid="cpp/utility/pair" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::pair</ref>&lt; cudaGraphNode_t, cudaGraphNode_t &gt; &gt;</type>
        <definition>std::vector&lt;std::pair&lt;cudaGraphNode_t, cudaGraphNode_t&gt; &gt; tf::cuda_graph_get_edges</definition>
        <argsstring>(cudaGraph_t graph)</argsstring>
        <name>cuda_graph_get_edges</name>
        <param>
          <type>cudaGraph_t</type>
          <declname>graph</declname>
        </param>
        <briefdescription>
<para>acquires the edges in a native CUDA graph </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_graph.hpp" line="248" column="1" bodyfile="taskflow/cuda/cuda_graph.hpp" bodystart="248" bodyend="257"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1afb8f9fd1a826738ea95b4cf224c65cb0" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>cudaGraphNodeType</type>
        <definition>cudaGraphNodeType tf::cuda_get_graph_node_type</definition>
        <argsstring>(cudaGraphNode_t node)</argsstring>
        <name>cuda_get_graph_node_type</name>
        <param>
          <type>cudaGraphNode_t</type>
          <declname>node</declname>
        </param>
        <briefdescription>
<para>queries the type of a native CUDA graph node </para>
        </briefdescription>
        <detaileddescription>
<para>valid type values are:<itemizedlist>
<listitem><para>cudaGraphNodeTypeKernel = 0x00</para>
</listitem><listitem><para>cudaGraphNodeTypeMemcpy = 0x01</para>
</listitem><listitem><para>cudaGraphNodeTypeMemset = 0x02</para>
</listitem><listitem><para>cudaGraphNodeTypeHost = 0x03</para>
</listitem><listitem><para>cudaGraphNodeTypeGraph = 0x04</para>
</listitem><listitem><para>cudaGraphNodeTypeEmpty = 0x05</para>
</listitem><listitem><para>cudaGraphNodeTypeWaitEvent = 0x06</para>
</listitem><listitem><para>cudaGraphNodeTypeEventRecord = 0x07 </para>
</listitem></itemizedlist>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_graph.hpp" line="272" column="26" bodyfile="taskflow/cuda/cuda_graph.hpp" bodystart="272" bodyend="278"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a70a7cb15356a204af1b73b4ac0bbc64a" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr const char *</type>
        <definition>constexpr const char* tf::to_string</definition>
        <argsstring>(cudaGraphNodeType type)</argsstring>
        <name>to_string</name>
        <param>
          <type>cudaGraphNodeType</type>
          <declname>type</declname>
        </param>
        <briefdescription>
<para>convert a cuda_task type to a human-readable string </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_graph.hpp" line="287" column="22" bodyfile="taskflow/cuda/cuda_graph.hpp" bodystart="287" bodyend="304"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a9cca69f61d792afb3ad501b703d795c1" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostream</ref> &amp;</type>
        <definition>std::ostream&amp; tf::operator&lt;&lt;</definition>
        <argsstring>(std::ostream &amp;os, const cudaTask &amp;ct)</argsstring>
        <name>operator&lt;&lt;</name>
        <param>
          <type><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostream</ref> &amp;</type>
          <declname>os</declname>
        </param>
        <param>
          <type>const <ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref> &amp;</type>
          <declname>ct</declname>
        </param>
        <briefdescription>
<para>overload of ostream inserter operator for <ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref> </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/cuda/cuda_graph.hpp" line="448" column="8" bodyfile="taskflow/cuda/cuda_graph.hpp" bodystart="448" bodyend="451"/>
      </memberdef>
      <memberdef kind="function" id="namespacetf_1a30fa078dcf625e9eada5a95af1467588" prot="public" static="no" constexpr="yes" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>constexpr const char *</type>
        <definition>constexpr const char* tf::version</definition>
        <argsstring>()</argsstring>
        <name>version</name>
        <briefdescription>
<para>queries the version information in a string format <computeroutput>major.minor.patch</computeroutput> </para>
        </briefdescription>
        <detaileddescription>
<para>Release notes are available here: <ulink url="https://taskflow.github.io/taskflow/Releases.html">https://taskflow.github.io/taskflow/Releases.html</ulink> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/taskflow.hpp" line="98" column="22" bodyfile="taskflow/taskflow.hpp" bodystart="98" bodyend="100"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>taskflow namespace </para>
    </briefdescription>
    <detaileddescription>
    </detaileddescription>
    <location file="taskflow/utility/small_vector.hpp" line="22" column="1"/>
  </compounddef>
</doxygen>
