<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.14">
  <compounddef id="classtf_1_1cudaFlowCapturer" kind="class" language="C++" prot="public">
    <compoundname>tf::cudaFlowCapturer</compoundname>
    <includes refid="cuda__capturer_8hpp" local="no">cuda_capturer.hpp</includes>
    <innerclass refid="structtf_1_1cudaFlowCapturer_1_1External" prot="private">tf::cudaFlowCapturer::External</innerclass>
    <innerclass refid="structtf_1_1cudaFlowCapturer_1_1Internal" prot="private">tf::cudaFlowCapturer::Internal</innerclass>
      <sectiondef kind="private-type">
      <memberdef kind="typedef" id="classtf_1_1cudaFlowCapturer_1a5f92f6ccad52aed18441d80bc186049f" prot="private" static="no">
        <type>std::variant&lt; External, Internal &gt;</type>
        <definition>using tf::cudaFlowCapturer::handle_t =  std::variant&lt;External, Internal&gt;</definition>
        <argsstring></argsstring>
        <name>handle_t</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="115" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="115" bodyend="-1"/>
      </memberdef>
      <memberdef kind="typedef" id="classtf_1_1cudaFlowCapturer_1a2d360f36382310a3caeb750e1c546c17" prot="private" static="no">
        <type>std::variant&lt; <ref refid="classtf_1_1cudaSequentialCapturing" kindref="compound">cudaSequentialCapturing</ref>, <ref refid="classtf_1_1cudaRoundRobinCapturing" kindref="compound">cudaRoundRobinCapturing</ref> &gt;</type>
        <definition>using tf::cudaFlowCapturer::Optimizer =  std::variant&lt; cudaSequentialCapturing, cudaRoundRobinCapturing &gt;</definition>
        <argsstring></argsstring>
        <name>Optimizer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="117" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="121" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="friend">
      <memberdef kind="friend" id="classtf_1_1cudaFlowCapturer_1a9f64f729511a922781a59663ff1c6250" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend class</type>
        <definition>friend class cudaFlow</definition>
        <argsstring></argsstring>
        <name>cudaFlow</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="105" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="105" bodyend="-1"/>
      </memberdef>
      <memberdef kind="friend" id="classtf_1_1cudaFlowCapturer_1a763b2f90bc53f92d680a635fe28e858e" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend class</type>
        <definition>friend class Executor</definition>
        <argsstring></argsstring>
        <name>Executor</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="106" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="106" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classtf_1_1cudaFlowCapturer_1a86234fa25a7b2bbe6caaa9ecb2471c78" prot="private" static="no" mutable="no">
        <type>const size_t</type>
        <definition>const size_t tf::cudaFlowCapturer::_MAX_BLOCK_SIZE</definition>
        <argsstring></argsstring>
        <name>_MAX_BLOCK_SIZE</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="498" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="498" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtf_1_1cudaFlowCapturer_1acaf4f328d032558eb6ed4010f416f62a" prot="private" static="no" mutable="no">
        <type>handle_t</type>
        <definition>handle_t tf::cudaFlowCapturer::_handle</definition>
        <argsstring></argsstring>
        <name>_handle</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="500" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="500" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtf_1_1cudaFlowCapturer_1ad39f4248c8b66340b88a018b70483161" prot="private" static="no" mutable="no">
        <type>cudaGraph &amp;</type>
        <definition>cudaGraph&amp; tf::cudaFlowCapturer::_graph</definition>
        <argsstring></argsstring>
        <name>_graph</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="502" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="502" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtf_1_1cudaFlowCapturer_1acdc0ba0a1d25ca9f3c0780a62b68508a" prot="private" static="no" mutable="no">
        <type>Optimizer</type>
        <definition>Optimizer tf::cudaFlowCapturer::_optimizer</definition>
        <argsstring></argsstring>
        <name>_optimizer</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="504" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="504" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtf_1_1cudaFlowCapturer_1ae1bb9c3841bf9ce8784dae4bddcda437" prot="private" static="no" mutable="no">
        <type>cudaGraphExec_t</type>
        <definition>cudaGraphExec_t tf::cudaFlowCapturer::_executable</definition>
        <argsstring></argsstring>
        <name>_executable</name>
        <initializer>{nullptr}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="506" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="506" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtf_1_1cudaFlowCapturer_1a18b216ba712f8ad0e3d99efdfa8ac54d" prot="private" static="no" mutable="no">
        <type><ref refid="cpp/container/vector" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector</ref>&lt; <ref refid="cpp/memory/unique_ptr" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::unique_ptr</ref>&lt; <ref refid="classtf_1_1cudaFlowCapturerBase" kindref="compound">cudaFlowCapturerBase</ref> &gt; &gt;</type>
        <definition>std::vector&lt;std::unique_ptr&lt;cudaFlowCapturerBase&gt; &gt; tf::cudaFlowCapturer::_capturers</definition>
        <argsstring></argsstring>
        <name>_capturers</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="508" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="508" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1aab413b88bf73368f1e6dd98d19016bbc" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>tf::cudaFlowCapturer::cudaFlowCapturer</definition>
        <argsstring>()</argsstring>
        <name>cudaFlowCapturer</name>
        <briefdescription>
<para>constrcts a standalone <ref refid="classtf_1_1cudaFlowCapturer" kindref="compound">cudaFlowCapturer</ref> </para>        </briefdescription>
        <detaileddescription>
<para>A standalone cudaFlow capturer does not go through any taskflow and can be run by the caller thread using explicit offload methods (e.g., <ref refid="classtf_1_1cudaFlow_1a85789ed8a1f47704cf1f1a2b98969444" kindref="member">tf::cudaFlow::offload</ref>). </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="132" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="529" bodyend="535"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1ab2f3765cd2cd7368522011d37a294359" prot="public" static="no" const="no" explicit="no" inline="yes" virt="virtual">
        <type></type>
        <definition>tf::cudaFlowCapturer::~cudaFlowCapturer</definition>
        <argsstring>()</argsstring>
        <name>~cudaFlowCapturer</name>
        <briefdescription>
<para>destructs the <ref refid="classtf_1_1cudaFlowCapturer" kindref="compound">cudaFlowCapturer</ref> </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="137" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="537" bodyend="541"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a3413a20a7c8229365e1ee9fb5af4af1e" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>bool</type>
        <definition>bool tf::cudaFlowCapturer::empty</definition>
        <argsstring>() const</argsstring>
        <name>empty</name>
        <briefdescription>
<para>queries the emptiness of the graph </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="142" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="549" bodyend="551"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1aeb826786f1580bae1335d94ffbeb7e02" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cudaFlowCapturer::num_tasks</definition>
        <argsstring>() const</argsstring>
        <name>num_tasks</name>
        <briefdescription>
<para>queries the number of tasks </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="147" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="554" bodyend="556"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a06f1176b6a5590832f0e09a049f8a622" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::cudaFlowCapturer::clear</definition>
        <argsstring>()</argsstring>
        <name>clear</name>
        <briefdescription>
<para>clear this cudaFlow capturer </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="152" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="559" bodyend="562"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a90d1265bcc27647906bed6e6876c9aa7" prot="public" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::cudaFlowCapturer::dump</definition>
        <argsstring>(std::ostream &amp;os) const</argsstring>
        <name>dump</name>
        <param>
          <type><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostream</ref> &amp;</type>
          <declname>os</declname>
        </param>
        <briefdescription>
<para>dumps the capture graph into a DOT format through an output stream </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="158" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="565" bodyend="567"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a49dd9727aeb5bccd7d826c6b11a6882d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>ArgsT</declname>
            <defname>ArgsT</defname>
          </param>
        </templateparamlist>
        <type>T *</type>
        <definition>T * tf::cudaFlowCapturer::make_capturer</definition>
        <argsstring>(ArgsT &amp;&amp;... args)</argsstring>
        <name>make_capturer</name>
        <param>
          <type>ArgsT &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>creates a custom capturer derived from <ref refid="classtf_1_1cudaFlowCapturerBase" kindref="compound">tf::cudaFlowCapturerBase</ref> </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>custom capturer type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ArgsT</parametername>
</parameternamelist>
<parameterdescription>
<para>arguments types</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>arguments to forward to construct the custom capturer</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a pointer to the custom capturer</para></simplesect>
Each cudaFlow capturer keeps a list of custom capturers and manages their lifetimes. The lifetime of each custom capturer is the same as the capturer. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="175" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="830" bodyend="839"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1aa1d016b56c06cb28eabfebfdd7dbb24d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename OPT</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>ArgsT</declname>
            <defname>ArgsT</defname>
          </param>
        </templateparamlist>
        <type>OPT &amp;</type>
        <definition>OPT &amp; tf::cudaFlowCapturer::make_optimizer</definition>
        <argsstring>(ArgsT &amp;&amp;... args)</argsstring>
        <name>make_optimizer</name>
        <param>
          <type>ArgsT &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>enables different optimization algorithms </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>OPT</parametername>
</parameternamelist>
<parameterdescription>
<para>optimizer type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ArgsT</parametername>
</parameternamelist>
<parameterdescription>
<para>arguments types</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>arguments to forward to construct the optimizer</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a reference to the optimizer</para></simplesect>
We currently supports the following optimization algorithms to capture a user-described cudaFlow:<itemizedlist>
<listitem><para><ref refid="classtf_1_1cudaSequentialCapturing" kindref="compound">tf::cudaSequentialCapturing</ref></para></listitem><listitem><para><ref refid="classtf_1_1cudaRoundRobinCapturing" kindref="compound">tf::cudaRoundRobinCapturing</ref> </para></listitem></itemizedlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="194" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="843" bodyend="845"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1ad0d937ae0d77239f148b66a77e35db41" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_invocable_r_v&lt; void, C, cudaStream_t &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref></type>
        <definition>cudaTask tf::cudaFlowCapturer::on</definition>
        <argsstring>(C &amp;&amp;callable)</argsstring>
        <name>on</name>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>captures a sequential CUDA operations from the given callable </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type constructible with <computeroutput>std::function&lt;void(cudaStream_t)&gt;</computeroutput> </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable to capture CUDA operations with the stream</para></parameterdescription>
</parameteritem>
</parameterlist>
This methods applies a stream created by the flow to capture a sequence of CUDA operations defined in the callable. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="212" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="583" bodyend="588"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1ae84d097cdae9e2e8ce108dea760483ed" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref></type>
        <definition>cudaTask tf::cudaFlowCapturer::memcpy</definition>
        <argsstring>(void *dst, const void *src, size_t count)</argsstring>
        <name>memcpy</name>
        <param>
          <type>void *</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>src</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>copies data between host and device asynchronously through a stream </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>dst</parametername>
</parameternamelist>
<parameterdescription>
<para>destination memory address </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>source memory address </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>count</parametername>
</parameternamelist>
<parameterdescription>
<para>size in bytes to copy</para></parameterdescription>
</parameteritem>
</parameterlist>
The method captures a <computeroutput>cudaMemcpyAsync</computeroutput> operation through an internal stream. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="224" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="591" bodyend="600"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1ab70f12050e78b588f5c23d874aa4e538" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt;!std::is_same_v&lt; T, void &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref></type>
        <definition>cudaTask tf::cudaFlowCapturer::copy</definition>
        <argsstring>(T *tgt, const T *src, size_t num)</argsstring>
        <name>copy</name>
        <param>
          <type>T *</type>
          <declname>tgt</declname>
        </param>
        <param>
          <type>const T *</type>
          <declname>src</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>num</declname>
        </param>
        <briefdescription>
<para>captures a copy task of typed data </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>element type (non-void)</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tgt</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the target memory block </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>src</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the source memory block </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>num</parametername>
</parameternamelist>
<parameterdescription>
<para>number of elements to copy</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref> handle</para></simplesect>
A copy task transfers <computeroutput>num*sizeof(T)</computeroutput> bytes of data from a source location to a target location. Direction can be arbitrary among CPUs and GPUs. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="243" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="603" bodyend="610"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a0d38965b380f940bf6cfc6667a281052" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref></type>
        <definition>cudaTask tf::cudaFlowCapturer::memset</definition>
        <argsstring>(void *ptr, int v, size_t n)</argsstring>
        <name>memset</name>
        <param>
          <type>void *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>v</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>initializes or sets GPU memory to the given value byte by byte </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>ptr</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to GPU mempry </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>v</parametername>
</parameternamelist>
<parameterdescription>
<para>value to set for each byte of the specified memory </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>size in bytes to set</para></parameterdescription>
</parameteritem>
</parameterlist>
The method captures a <computeroutput>cudaMemsetAsync</computeroutput> operation through an internal stream to fill the first <computeroutput>count</computeroutput> bytes of the memory area pointed to by <computeroutput>devPtr</computeroutput> with the constant byte value <computeroutput>value</computeroutput>. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="256" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="613" bodyend="619"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1ad3c5c7847d668f2084cef0583f148eb9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>ArgsT</declname>
            <defname>ArgsT</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref></type>
        <definition>cudaTask tf::cudaFlowCapturer::kernel</definition>
        <argsstring>(dim3 g, dim3 b, size_t s, F &amp;&amp;f, ArgsT &amp;&amp;... args)</argsstring>
        <name>kernel</name>
        <param>
          <type>dim3</type>
          <declname>g</declname>
        </param>
        <param>
          <type>dim3</type>
          <declname>b</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>s</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>ArgsT &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>captures a kernel </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>kernel function type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ArgsT</parametername>
</parameternamelist>
<parameterdescription>
<para>kernel function parameters type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>g</parametername>
</parameternamelist>
<parameterdescription>
<para>configured grid </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>b</parametername>
</parameternamelist>
<parameterdescription>
<para>configured block </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>s</parametername>
</parameternamelist>
<parameterdescription>
<para>configured shared memory size in bytes </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>f</parametername>
</parameternamelist>
<parameterdescription>
<para>kernel function </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>arguments to forward to the kernel function by copy</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref> handle </para></simplesect>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="273" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="623" bodyend="629"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a01e187cf410a88cdc8174bc0215813ce" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref></type>
        <definition>cudaTask tf::cudaFlowCapturer::single_task</definition>
        <argsstring>(C &amp;&amp;callable)</argsstring>
        <name>single_task</name>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>capturers a kernel to runs the given callable with only one thread </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>callable to run by a single kernel thread </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="287" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="634" bodyend="638"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a2982cf89d4dffcf01bf9cce4a5c79f51" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref></type>
        <definition>cudaTask tf::cudaFlowCapturer::for_each</definition>
        <argsstring>(I first, I last, C &amp;&amp;callable)</argsstring>
        <name>for_each</name>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>captures a kernel that applies a callable to each dereferenced element of the data array </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning (inclusive) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end (exclusive) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object to apply to the dereferenced iterator</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref> handle</para></simplesect>
This method is equivalent to the parallel execution of the following loop on a GPU:</para><para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>itr<sp/>=<sp/>first;<sp/>itr<sp/>!=<sp/>last;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>callable(*itr);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="311" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="642" bodyend="649"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a802ddd94cb40b32daecec327d2ad6e52" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref></type>
        <definition>cudaTask tf::cudaFlowCapturer::for_each_index</definition>
        <argsstring>(I first, I last, I step, C &amp;&amp;callable)</argsstring>
        <name>for_each_index</name>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>I</type>
          <declname>step</declname>
        </param>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>captures a kernel that applies a callable to each index in the range with the step size </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>index type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning index </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>last index </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>step</parametername>
</parameternamelist>
<parameterdescription>
<para>step size </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>the callable to apply to each element in the data array</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref> handle</para></simplesect>
This method is equivalent to the parallel execution of the following loop on a GPU:</para><para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>step<sp/>is<sp/>positive<sp/>[first,<sp/>last)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>i=first;<sp/>i&lt;last;<sp/>i+=step)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>callable(i);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>step<sp/>is<sp/>negative<sp/>[first,<sp/>last)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>i=first;<sp/>i&gt;last;<sp/>i+=step)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>callable(i);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="342" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="653" bodyend="665"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a02e3ec6669c8571ad6888584e88c07fc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>S</declname>
            <defname>S</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref></type>
        <definition>cudaTask tf::cudaFlowCapturer::transform</definition>
        <argsstring>(I first, I last, C &amp;&amp;callable, S... srcs)</argsstring>
        <name>transform</name>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <param>
          <type>S...</type>
          <declname>srcs</declname>
        </param>
        <briefdescription>
<para>captures a kernel that applies a callable to a source range and stores the result in a target range </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>S</parametername>
</parameternamelist>
<parameterdescription>
<para>source types</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning (inclusive) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end (exclusive) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>the callable to apply to each element in the range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>srcs</parametername>
</parameternamelist>
<parameterdescription>
<para>iterators to the source ranges</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref> handle</para></simplesect>
This method is equivalent to the parallel execution of the following loop on a GPU:</para><para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(first<sp/>!=<sp/>last)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*first++<sp/>=<sp/>callable(*src1++,<sp/>*src2++,<sp/>*src3++,<sp/>...);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="368" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="669" bodyend="677"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1ad877003965b1e9e75ec10917190342e9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref></type>
        <definition>cudaTask tf::cudaFlowCapturer::reduce</definition>
        <argsstring>(I first, I last, T *result, C &amp;&amp;op)</argsstring>
        <name>reduce</name>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>result</declname>
        </param>
        <param>
          <type>C &amp;&amp;</type>
          <declname>op</declname>
        </param>
        <briefdescription>
<para>captures a kernel that performs parallel reduction over a range of items </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>input iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>value type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning (inclusive) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end (exclusive) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>result</parametername>
</parameternamelist>
<parameterdescription>
<para>pointer to the result with an initialized value </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>op</parametername>
</parameternamelist>
<parameterdescription>
<para>binary reduction operator</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1cudaTask" kindref="compound">tf::cudaTask</ref> handle</para></simplesect>
This method is equivalent to the parallel execution of the following loop on a GPU:</para><para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(first<sp/>!=<sp/>last)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*result<sp/>=<sp/>op(*result,<sp/>*first++);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="393" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="681" bodyend="695"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a9a6f54751165c1e5473652ad0ca222bb" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref></type>
        <definition>cudaTask tf::cudaFlowCapturer::uninitialized_reduce</definition>
        <argsstring>(I first, I last, T *result, C &amp;&amp;op)</argsstring>
        <name>uninitialized_reduce</name>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>result</declname>
        </param>
        <param>
          <type>C &amp;&amp;</type>
          <declname>op</declname>
        </param>
        <briefdescription>
<para>similar to tf::cudaFlowCapturerBase::reduce but does not assum any initial value to reduce </para>        </briefdescription>
        <detaileddescription>
<para>This method is equivalent to the parallel execution of the following loop on a GPU:</para><para><programlisting filename=".cpp"><codeline><highlight class="normal">*result<sp/>=<sp/>*first++;<sp/><sp/></highlight><highlight class="comment">//<sp/>no<sp/>initial<sp/>values<sp/>partitipcate<sp/>in<sp/>the<sp/>loop</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(first<sp/>!=<sp/>last)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*result<sp/>=<sp/>op(*result,<sp/>*first++);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="410" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="699" bodyend="715"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a6d3d355752017aadcb733a8afdd200e3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; std::is_invocable_r_v&lt; void, C, cudaStream_t &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref></type>
        <definition>cudaTask tf::cudaFlowCapturer::rebind_on</definition>
        <argsstring>(cudaTask task, C &amp;&amp;callable)</argsstring>
        <name>rebind_on</name>
        <param>
          <type><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref></type>
          <declname>task</declname>
        </param>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>rebinds a capture task to another sequential CUDA operations </para>        </briefdescription>
        <detaileddescription>
<para>The method is similar to cudaFlowCapturerBase::on but with an additional argument on a previously created capture task. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="425" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="767" bodyend="778"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a0675aec517ca99e6638b10d53e39a2ef" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref></type>
        <definition>cudaTask tf::cudaFlowCapturer::rebind_memcpy</definition>
        <argsstring>(cudaTask task, void *dst, const void *src, size_t count)</argsstring>
        <name>rebind_memcpy</name>
        <param>
          <type><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref></type>
          <declname>task</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>dst</declname>
        </param>
        <param>
          <type>const void *</type>
          <declname>src</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>count</declname>
        </param>
        <briefdescription>
<para>rebinds a capture task to a memcpy operation </para>        </briefdescription>
        <detaileddescription>
<para>The method is similar to cudaFlowCapturerBase::memcpy but with an additional argument on a previously created ceapture task. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="433" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="781" bodyend="790"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a53550f29e0cd6b2f75fa0dac80a4292f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>std::enable_if_t&lt;!std::is_same_v&lt; T, void &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref></type>
        <definition>cudaTask tf::cudaFlowCapturer::rebind_copy</definition>
        <argsstring>(cudaTask task, T *tgt, const T *src, size_t num)</argsstring>
        <name>rebind_copy</name>
        <param>
          <type><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref></type>
          <declname>task</declname>
        </param>
        <param>
          <type>T *</type>
          <declname>tgt</declname>
        </param>
        <param>
          <type>const T *</type>
          <declname>src</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>num</declname>
        </param>
        <briefdescription>
<para>rebinds a capture task to a copy operation </para>        </briefdescription>
        <detaileddescription>
<para>The method is similar to cudaFlowCapturerBase::copy but with an additional argument on a previously created ceapture task. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="444" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="796" bodyend="805"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a494942759d5edbaf68b2842da23a6d52" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref></type>
        <definition>cudaTask tf::cudaFlowCapturer::rebind_memset</definition>
        <argsstring>(cudaTask task, void *ptr, int value, size_t n)</argsstring>
        <name>rebind_memset</name>
        <param>
          <type><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref></type>
          <declname>task</declname>
        </param>
        <param>
          <type>void *</type>
          <declname>ptr</declname>
        </param>
        <param>
          <type>int</type>
          <declname>value</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>rebinds a capture task to a memset operation </para>        </briefdescription>
        <detaileddescription>
<para>The method is similar to cudaFlowCapturerBase::memset but with an additional argument on a previously created ceapture task. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="452" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="808" bodyend="816"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a74232699e7d170a737db6c724db4a35c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>ArgsT</declname>
            <defname>ArgsT</defname>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref></type>
        <definition>cudaTask tf::cudaFlowCapturer::rebind_kernel</definition>
        <argsstring>(cudaTask task, dim3 g, dim3 b, size_t s, F &amp;&amp;f, ArgsT &amp;&amp;... args)</argsstring>
        <name>rebind_kernel</name>
        <param>
          <type><ref refid="classtf_1_1cudaTask" kindref="compound">cudaTask</ref></type>
          <declname>task</declname>
        </param>
        <param>
          <type>dim3</type>
          <declname>g</declname>
        </param>
        <param>
          <type>dim3</type>
          <declname>b</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>s</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>f</declname>
        </param>
        <param>
          <type>ArgsT &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>rebinds a capture task to a kernel operation </para>        </briefdescription>
        <detaileddescription>
<para>The method is similar to cudaFlowCapturerBase::kernel but with an additional argument on a previously created ceapture task. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="461" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="820" bodyend="826"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a8678573f19e01f441a6b4108e62781f3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::cudaFlowCapturer::offload_until</definition>
        <argsstring>(P &amp;&amp;predicate)</argsstring>
        <name>offload_until</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>predicate</declname>
        </param>
        <briefdescription>
<para>offloads the captured cudaFlow onto a GPU and repeatedly runs it until the predicate becomes true </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>predicate type (a binary callable)</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>predicate</parametername>
</parameternamelist>
<parameterdescription>
<para>a binary predicate (returns <computeroutput>true</computeroutput> for stop)</para></parameterdescription>
</parameteritem>
</parameterlist>
Immediately offloads the cudaFlow captured so far onto a GPU and repeatedly runs it until the predicate returns <computeroutput>true</computeroutput>.</para><para>By default, if users do not offload the cudaFlow capturer, the executor will offload it once. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="482" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="726" bodyend="751"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a0bc6231cc6b1dbf5171b0bc421dc6577" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::cudaFlowCapturer::offload_n</definition>
        <argsstring>(size_t n)</argsstring>
        <name>offload_n</name>
        <param>
          <type>size_t</type>
          <declname>n</declname>
        </param>
        <briefdescription>
<para>offloads the captured cudaFlow and executes it by the given times </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>n</parametername>
</parameternamelist>
<parameterdescription>
<para>number of executions </para></parameterdescription>
</parameteritem>
</parameterlist>
</para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="489" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="754" bodyend="756"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a5959002af1cf1a1ada3d86a073682232" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::cudaFlowCapturer::offload</definition>
        <argsstring>()</argsstring>
        <name>offload</name>
        <briefdescription>
<para>offloads the captured cudaFlow and executes it once </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="494" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="759" bodyend="761"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a0ff3e4948c4861e62dd4ad52b88ba4ab" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>tf::cudaFlowCapturer::cudaFlowCapturer</definition>
        <argsstring>(cudaGraph &amp;)</argsstring>
        <name>cudaFlowCapturer</name>
        <param>
          <type>cudaGraph &amp;</type>
          <defname>g</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="510" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="520" bodyend="526"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a2fde4fe15f2e1471e0c6b1eb9bf22b12" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>cudaGraph_t</type>
        <definition>cudaGraph_t tf::cudaFlowCapturer::_capture</definition>
        <argsstring>()</argsstring>
        <name>_capture</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="512" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="718" bodyend="722"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a18aba23ae23ce8dbe47ef3022162a7bc" prot="private" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::cudaFlowCapturer::_destroy_executable</definition>
        <argsstring>()</argsstring>
        <name>_destroy_executable</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="514" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="570" bodyend="577"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1cudaFlowCapturer_1a1bab2ef6daf934629dfd13c8e77a7110" prot="private" static="no" const="yes" explicit="no" inline="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::cudaFlowCapturer::_default_block_size</definition>
        <argsstring>(size_t) const</argsstring>
        <name>_default_block_size</name>
        <param>
          <type>size_t</type>
          <defname>N</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="516" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="544" bodyend="546"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>class for building a CUDA task dependency graph through stream capture </para>    </briefdescription>
    <detaileddescription>
<para>A cudaFlowCapturer inherits all the base methods from <ref refid="classtf_1_1cudaFlowCapturerBase" kindref="compound">tf::cudaFlowCapturerBase</ref> to construct a CUDA task graph through <emphasis>stream capturer</emphasis>. This class also defines a factory interface <ref refid="classtf_1_1cudaFlowCapturer_1a49dd9727aeb5bccd7d826c6b11a6882d" kindref="member">tf::cudaFlowCapturer::make_capturer</ref> for users to create custom capturers with their lifetimes managed by the factory.</para><para>The usage of <ref refid="classtf_1_1cudaFlowCapturer" kindref="compound">tf::cudaFlowCapturer</ref> is similar to <ref refid="classtf_1_1cudaFlow" kindref="compound">tf::cudaFlow</ref>, except users can call the method <ref refid="classtf_1_1cudaFlowCapturer_1ad0d937ae0d77239f148b66a77e35db41" kindref="member">tf::cudaFlowCapturer::on</ref> to capture a sequence of asynchronous CUDA operations through the given stream. The following example creates a CUDA graph that captures two kernel tasks, <computeroutput>task_1</computeroutput> and <computeroutput>task_2</computeroutput>, where <computeroutput>task_1</computeroutput> runs before <computeroutput>task_2</computeroutput>.</para><para><programlisting filename=".cpp"><codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](<ref refid="classtf_1_1cudaFlowCapturer" kindref="compound">tf::cudaFlowCapturer</ref>&amp;<sp/>capturer){</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>capture<sp/>my_kernel_1<sp/>through<sp/>the<sp/>given<sp/>stream<sp/>managed<sp/>by<sp/>the<sp/>capturer</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>task_1<sp/>=<sp/>capturer.<ref refid="classtf_1_1cudaFlowCapturer_1ad0d937ae0d77239f148b66a77e35db41" kindref="member">on</ref>([&amp;](cudaStream_t<sp/>stream){<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>my_kernel_1&lt;&lt;&lt;grid_1,<sp/>block_1,<sp/>shm_size_1,<sp/>stream&gt;&gt;&gt;(my_parameters_1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>capture<sp/>my_kernel_2<sp/>through<sp/>the<sp/>given<sp/>stream<sp/>managed<sp/>by<sp/>the<sp/>capturer</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>task_2<sp/>=<sp/>capturer.<ref refid="classtf_1_1cudaFlowCapturer_1ad0d937ae0d77239f148b66a77e35db41" kindref="member">on</ref>([&amp;](cudaStream_t<sp/>stream){<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>my_kernel_2&lt;&lt;&lt;grid_2,<sp/>block_2,<sp/>shm_size_2,<sp/>stream&gt;&gt;&gt;(my_parameters_2);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>task_1.<ref refid="classtf_1_1cudaTask_1abdd68287ec4dff4216af34d1db44d1b4" kindref="member">precede</ref>(task_2);</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting></para><para>Similar to <ref refid="classtf_1_1cudaFlow" kindref="compound">tf::cudaFlow</ref>, a cudaFlowCapturer is a task (<ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref>) created from <ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref> and will be run by <emphasis>one</emphasis> worker thread in the executor. That is, the callable that describes a cudaFlowCapturer will be executed sequentially. Inside a cudaFlow capturer task, different GPU tasks (<ref refid="classtf_1_1cudaTask" kindref="compound">tf::cudaTask</ref>) may run in parallel scheduled by both our capturing algorithm and the CUDA runtime.</para><para>Please refer to <ref refid="GPUTaskingcudaFlowCapturer" kindref="compound">GPU Tasking (cudaFlowCapturer)</ref> for details. </para>    </detaileddescription>
    <location file="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" line="103" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_capturer.hpp" bodystart="103" bodyend="517"/>
    <listofallmembers>
      <member refid="classtf_1_1cudaFlowCapturer_1a2fde4fe15f2e1471e0c6b1eb9bf22b12" prot="private" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>_capture</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a18b216ba712f8ad0e3d99efdfa8ac54d" prot="private" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>_capturers</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a1bab2ef6daf934629dfd13c8e77a7110" prot="private" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>_default_block_size</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a18aba23ae23ce8dbe47ef3022162a7bc" prot="private" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>_destroy_executable</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1ae1bb9c3841bf9ce8784dae4bddcda437" prot="private" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>_executable</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1ad39f4248c8b66340b88a018b70483161" prot="private" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>_graph</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1acaf4f328d032558eb6ed4010f416f62a" prot="private" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>_handle</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a86234fa25a7b2bbe6caaa9ecb2471c78" prot="private" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>_MAX_BLOCK_SIZE</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1acdc0ba0a1d25ca9f3c0780a62b68508a" prot="private" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>_optimizer</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a06f1176b6a5590832f0e09a049f8a622" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>clear</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1ab70f12050e78b588f5c23d874aa4e538" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>copy</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a9f64f729511a922781a59663ff1c6250" prot="private" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>cudaFlow</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1aab413b88bf73368f1e6dd98d19016bbc" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>cudaFlowCapturer</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a0ff3e4948c4861e62dd4ad52b88ba4ab" prot="private" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>cudaFlowCapturer</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a90d1265bcc27647906bed6e6876c9aa7" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>dump</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a3413a20a7c8229365e1ee9fb5af4af1e" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>empty</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a763b2f90bc53f92d680a635fe28e858e" prot="private" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>Executor</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a2982cf89d4dffcf01bf9cce4a5c79f51" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>for_each</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a802ddd94cb40b32daecec327d2ad6e52" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>for_each_index</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a5f92f6ccad52aed18441d80bc186049f" prot="private" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>handle_t</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1ad3c5c7847d668f2084cef0583f148eb9" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>kernel</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a49dd9727aeb5bccd7d826c6b11a6882d" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>make_capturer</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1aa1d016b56c06cb28eabfebfdd7dbb24d" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>make_optimizer</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1ae84d097cdae9e2e8ce108dea760483ed" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>memcpy</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a0d38965b380f940bf6cfc6667a281052" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>memset</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1aeb826786f1580bae1335d94ffbeb7e02" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>num_tasks</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a5959002af1cf1a1ada3d86a073682232" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>offload</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a0bc6231cc6b1dbf5171b0bc421dc6577" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>offload_n</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a8678573f19e01f441a6b4108e62781f3" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>offload_until</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1ad0d937ae0d77239f148b66a77e35db41" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>on</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a2d360f36382310a3caeb750e1c546c17" prot="private" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>Optimizer</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a53550f29e0cd6b2f75fa0dac80a4292f" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>rebind_copy</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a74232699e7d170a737db6c724db4a35c" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>rebind_kernel</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a0675aec517ca99e6638b10d53e39a2ef" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>rebind_memcpy</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a494942759d5edbaf68b2842da23a6d52" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>rebind_memset</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a6d3d355752017aadcb733a8afdd200e3" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>rebind_on</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1ad877003965b1e9e75ec10917190342e9" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>reduce</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a01e187cf410a88cdc8174bc0215813ce" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>single_task</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a02e3ec6669c8571ad6888584e88c07fc" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>transform</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1a9a6f54751165c1e5473652ad0ca222bb" prot="public" virt="non-virtual"><scope>tf::cudaFlowCapturer</scope><name>uninitialized_reduce</name></member>
      <member refid="classtf_1_1cudaFlowCapturer_1ab2f3765cd2cd7368522011d37a294359" prot="public" virt="virtual"><scope>tf::cudaFlowCapturer</scope><name>~cudaFlowCapturer</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
