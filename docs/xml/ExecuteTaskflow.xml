<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="ExecuteTaskflow" kind="page">
    <compoundname>ExecuteTaskflow</compoundname>
    <title>Executor</title>
    <tableofcontents>
      <tocsect>
        <name>Create an Executor</name>
        <reference>ExecuteTaskflow_1CreateAnExecutor</reference>
    </tocsect>
      <tocsect>
        <name>Execute a Taskflow</name>
        <reference>ExecuteTaskflow_1ExecuteATaskflow</reference>
    </tocsect>
      <tocsect>
        <name>Execute a Taskflow with Transferred Ownership</name>
        <reference>ExecuteTaskflow_1ExecuteATaskflowWithTransferredOwnership</reference>
    </tocsect>
      <tocsect>
        <name>Execute a Taskflow from an Internal Worker</name>
        <reference>ExecuteTaskflow_1ExecuteATaskflowFromAnInternalWorker</reference>
    </tocsect>
      <tocsect>
        <name>Touch an Executor from Multiple Threads</name>
        <reference>ExecuteTaskflow_1ThreadSafety</reference>
    </tocsect>
      <tocsect>
        <name>Query the Worker ID</name>
        <reference>ExecuteTaskflow_1QueryTheWorkerID</reference>
    </tocsect>
      <tocsect>
        <name>Observe Thread Activities</name>
        <reference>ExecuteTaskflow_1ObserveThreadActivities</reference>
    </tocsect>
      <tocsect>
        <name>Modify Worker Property</name>
        <reference>ExecuteTaskflow_1ModifyWorkerProperty</reference>
    </tocsect>
    </tableofcontents>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>After you create a task dependency graph, you need to submit it to threads for execution. In this chapter, we will show you how to execute a task dependency graph.</para>
<sect1 id="ExecuteTaskflow_1CreateAnExecutor">
<title>Create an Executor</title>
<para>To execute a taskflow, you need to create an <emphasis>executor</emphasis> of type <ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref>. An executor is a <emphasis>thread-safe</emphasis> object that manages a set of worker threads and executes tasks through an efficient <emphasis>work-stealing</emphasis> algorithm. Issuing a call to run a taskflow creates a <emphasis>topology</emphasis>, a data structure to keep track of the execution status of a running graph. <ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref> takes an unsigned integer to construct with <computeroutput>N</computeroutput> worker threads. The default value is <ref refid="cpp/thread/thread/hardware_concurrency" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::thread::hardware_concurrency</ref>.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/>executor1;<sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>an<sp/>executor<sp/>with<sp/>the<sp/>number<sp/>of<sp/>workers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>equal<sp/>to<sp/>std::thread::hardware_concurrency</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/>executor2(4);<sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>an<sp/>executor<sp/>of<sp/>4<sp/>worker<sp/>threads</highlight></codeline>
</programlisting></para>
<para>An executor can be reused to execute multiple taskflows. In most workloads, you may need only one executor to run multiple taskflows where each taskflow represents a part of a parallel decomposition.</para>
</sect1>
<sect1 id="ExecuteTaskflow_1ExecuteATaskflow">
<title>Execute a Taskflow</title>
<para><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref> provides a set of <computeroutput>run_*</computeroutput> methods, <ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">tf::Executor::run</ref>, <ref refid="classtf_1_1Executor_1af15db5f7dde8e7ff1f86ef8fe825e9e2" kindref="member">tf::Executor::run_n</ref>, and <ref refid="classtf_1_1Executor_1ae4f9e214ea5ee873e8d90a70bc1c77e8" kindref="member">tf::Executor::run_until</ref> to run a taskflow for one time, multiple times, or until a given predicate evaluates to true. All methods accept an optional callback to invoke after the execution completes, and return a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> for users to access the execution status. The code below shows several ways to run a taskflow.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><sp/>1:<sp/></highlight><highlight class="comment">//<sp/>Declare<sp/>an<sp/>executor<sp/>and<sp/>a<sp/>taskflow</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/>2:<sp/><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/>executor;</highlight></codeline>
<codeline><highlight class="normal"><sp/>3:<sp/><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"><sp/>4:</highlight></codeline>
<codeline><highlight class="normal"><sp/>5:<sp/></highlight><highlight class="comment">//<sp/>Add<sp/>three<sp/>tasks<sp/>into<sp/>the<sp/>taskflow</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/>6:<sp/><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>A<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>is<sp/>TaskA\n&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/>7:<sp/><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>B<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>is<sp/>TaskB\n&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/>8:<sp/><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>C<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>is<sp/>TaskC\n&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/>9:<sp/></highlight></codeline>
<codeline><highlight class="normal">10:<sp/></highlight><highlight class="comment">//<sp/>Build<sp/>precedence<sp/>between<sp/>tasks</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">11:<sp/>A.<ref refid="classtf_1_1Task_1a8c78c453295a553c1c016e4062da8588" kindref="member">precede</ref>(B,<sp/>C);<sp/></highlight></codeline>
<codeline><highlight class="normal">12:<sp/></highlight></codeline>
<codeline><highlight class="normal">13:<sp/><ref refid="classtf_1_1Future" kindref="compound">tf::Future&lt;void&gt;</ref><sp/>fu<sp/>=<sp/>executor.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow);</highlight></codeline>
<codeline><highlight class="normal">14:<sp/>fu.wait();<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>block<sp/>until<sp/>the<sp/>execution<sp/>completes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">15:</highlight></codeline>
<codeline><highlight class="normal">16:<sp/>executor.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow,<sp/>[](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;end<sp/>of<sp/>1<sp/>run&quot;</highlight><highlight class="normal">;<sp/>}).wait();</highlight></codeline>
<codeline><highlight class="normal">17:<sp/>executor.<ref refid="classtf_1_1Executor_1af15db5f7dde8e7ff1f86ef8fe825e9e2" kindref="member">run_n</ref>(taskflow,<sp/>4);</highlight></codeline>
<codeline><highlight class="normal">18:<sp/>executor.<ref refid="classtf_1_1Executor_1ab9aa252f70e9a40020a1e5a89d485b85" kindref="member">wait_for_all</ref>();<sp/><sp/></highlight><highlight class="comment">//<sp/>block<sp/>until<sp/>all<sp/>associated<sp/>executions<sp/>finish</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">19:<sp/>executor.<ref refid="classtf_1_1Executor_1af15db5f7dde8e7ff1f86ef8fe825e9e2" kindref="member">run_n</ref>(taskflow,<sp/>4,<sp/>[](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;end<sp/>of<sp/>4<sp/>runs&quot;</highlight><highlight class="normal">;<sp/>}).wait();</highlight></codeline>
<codeline><highlight class="normal">20:<sp/>executor.<ref refid="classtf_1_1Executor_1ae4f9e214ea5ee873e8d90a70bc1c77e8" kindref="member">run_until</ref>(taskflow,<sp/>[cnt=0]<sp/>()<sp/></highlight><highlight class="keyword">mutable</highlight><highlight class="normal"><sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>++cnt<sp/>==<sp/>10;<sp/>});</highlight></codeline>
</programlisting></para>
<para>Debrief:</para>
<para><itemizedlist>
<listitem><para>Lines 6-8 create a taskflow of three tasks A, B, and C </para>
</listitem>
<listitem><para>Lines 13-14 run the taskflow once and wait for completion </para>
</listitem>
<listitem><para>Line 16 runs the taskflow once with a callback to invoke when the execution finishes </para>
</listitem>
<listitem><para>Lines 17-18 run the taskflow four times and use <ref refid="classtf_1_1Executor_1ab9aa252f70e9a40020a1e5a89d485b85" kindref="member">tf::Executor::wait_for_all</ref> to wait for completion </para>
</listitem>
<listitem><para>Line 19 runs the taskflow four times and invokes a callback at the end of the fourth execution </para>
</listitem>
<listitem><para>Line 20 keeps running the taskflow until the predicate returns true</para>
</listitem>
</itemizedlist>
Issuing multiple runs on the same taskflow will automatically <emphasis>synchronize</emphasis> to a sequential chain of executions in the order of run calls.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>execution<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1af15db5f7dde8e7ff1f86ef8fe825e9e2" kindref="member">run_n</ref>(taskflow,<sp/>10);<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>execution<sp/>2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>execution<sp/>3</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1ab9aa252f70e9a40020a1e5a89d485b85" kindref="member">wait_for_all</ref>();<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>execution<sp/>1<sp/>-&gt;<sp/>execution<sp/>2<sp/>-&gt;<sp/>execution<sp/>3</highlight></codeline>
</programlisting></para>
<para><simplesect kind="attention"><para>A running taskflow must remain alive during its execution. It is your responsibility to ensure a taskflow not being destructed when it is running. For example, the code below can result undefined behavior.</para>
</simplesect>
<programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/>executor;<sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>an<sp/>executor</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>create<sp/>a<sp/>taskflow<sp/>whose<sp/>lifetime<sp/>is<sp/>restricted<sp/>by<sp/>the<sp/>scope</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>add<sp/>tasks<sp/>to<sp/>the<sp/>taskflow</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>...<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>run<sp/>the<sp/>taskflow</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>executor.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="comment">//<sp/>leaving<sp/>the<sp/>scope<sp/>will<sp/>destroy<sp/>taskflow<sp/>while<sp/>it<sp/>is<sp/>running,<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>resulting<sp/>in<sp/>undefined<sp/>behavior</highlight></codeline>
</programlisting></para>
<para>Similarly, you should avoid touching a taskflow while it is running.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Add<sp/>tasks<sp/>into<sp/>the<sp/>taskflow</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Declare<sp/>an<sp/>executor</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/>executor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Future" kindref="compound">tf::Future&lt;void&gt;</ref><sp/>future<sp/>=<sp/>executor.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow);<sp/><sp/></highlight><highlight class="comment">//<sp/>non-blocking<sp/>return</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>alter<sp/>the<sp/>taskflow<sp/>while<sp/>running<sp/>leads<sp/>to<sp/>undefined<sp/>behavior<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Add<sp/>a<sp/>new<sp/>task\n&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
</programlisting></para>
<para>You must always keep a taskflow alive and must not modify it while it is running on an executor.</para>
</sect1>
<sect1 id="ExecuteTaskflow_1ExecuteATaskflowWithTransferredOwnership">
<title>Execute a Taskflow with Transferred Ownership</title>
<para>You can transfer the ownership of a taskflow to an executor and run it without wrangling with the lifetime issue of that taskflow. Each <computeroutput>run_*</computeroutput> method discussed in the previous section comes with an overload that takes a <emphasis>moved</emphasis> taskflow object.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/>executor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>let<sp/>the<sp/>executor<sp/>manage<sp/>the<sp/>lifetime<sp/>of<sp/>the<sp/>submitted<sp/>taskflow</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(std::move(taskflow));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>now<sp/>taskflow<sp/>has<sp/>no<sp/>tasks</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">assert(taskflow.<ref refid="classtf_1_1Taskflow_1af4f03bca084deb5c2228ac8936d33649" kindref="member">num_tasks</ref>()<sp/>==<sp/>0);</highlight></codeline>
</programlisting></para>
<para>However, you should avoid moving a <emphasis>running</emphasis> taskflow which can result in undefined behavior.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/>executor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>executor<sp/>does<sp/>not<sp/>manage<sp/>the<sp/>lifetime<sp/>of<sp/>taskflow</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>error!<sp/>you<sp/>cannot<sp/>move<sp/>a<sp/>taskflow<sp/>while<sp/>it<sp/>is<sp/>running</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(std::move(taskflow));<sp/><sp/></highlight></codeline>
</programlisting></para>
<para>The correct way to submit a taskflow with moved ownership to an executor is to ensure all previous runs have completed. The executor will automatically release the resources of a moved taskflow right <emphasis>after</emphasis> its execution completes.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>submit<sp/>the<sp/>taskflow<sp/>and<sp/>wait<sp/>until<sp/>it<sp/>completes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow).wait();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>now<sp/>it&apos;s<sp/>safe<sp/>to<sp/>move<sp/>the<sp/>taskflow<sp/>to<sp/>the<sp/>executor<sp/>and<sp/>run<sp/>it</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(std::move(taskflow));<sp/><sp/></highlight></codeline>
</programlisting></para>
<para>Likewise, you cannot move a taskflow that is running on an executor. You must wait until all the previous fires of runs on that taskflow complete before calling move.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>submit<sp/>the<sp/>taskflow<sp/>and<sp/>wait<sp/>until<sp/>it<sp/>completes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow).wait();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>now<sp/>it&apos;s<sp/>safe<sp/>to<sp/>move<sp/>the<sp/>taskflow<sp/>to<sp/>another</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>moved_taskflow(std::move(taskflow));<sp/><sp/></highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="ExecuteTaskflow_1ExecuteATaskflowFromAnInternalWorker">
<title>Execute a Taskflow from an Internal Worker</title>
<para>Each run variant of <ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref> returns a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> object which allows you to wait for the result to complete. When calling <computeroutput>tf::Future::wait</computeroutput>, the caller blocks without doing anything until the associated state is written to be ready. This design, however, can introduce deadlock problem especially when you need to run multiple taskflows from the internal workers of an executor. For example, the code below creates a taskflow of 1000 tasks with each task running a taskflow of 500 tasks in a blocking fashion:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/>executor(2);</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/container/array" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::array&lt;tf::Taskflow, 1000&gt;</ref><sp/>others;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/atomic/atomic" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::atomic&lt;size_t&gt;</ref><sp/>counter{0};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>n=0;<sp/>n&lt;1000;<sp/>n++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;500;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>others[n].emplace([&amp;](){<sp/>counter++;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([&amp;executor,<sp/>&amp;<ref refid="namespacetf" kindref="compound">tf</ref>=others[n]](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>blocking<sp/>the<sp/>worker<sp/>can<sp/>introduce<sp/>deadlock<sp/>where</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>all<sp/>workers<sp/>are<sp/>waiting<sp/>for<sp/>their<sp/>taskflows<sp/>to<sp/>finish</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>executor.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(<ref refid="namespacetf" kindref="compound">tf</ref>).wait();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow).wait();</highlight></codeline>
</programlisting></para>
<para>To avoid this problem, the executor has a method, <ref refid="classtf_1_1Executor_1a8fcd9e0557922bb8194999f0cd433ea8" kindref="member">tf::Executor::corun</ref>, to execute a taskflow from a worker of that executor. The worker will not block but co-run the taskflow with other tasks in its work-stealing loop.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/>executor(2);</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/container/array" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::array&lt;tf::Taskflow, 1000&gt;</ref><sp/>others;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/atomic/atomic" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::atomic&lt;size_t&gt;</ref><sp/>counter{0};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>n=0;<sp/>n&lt;1000;<sp/>n++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;500;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>others[n].emplace([&amp;](){<sp/>counter++;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([&amp;executor,<sp/>&amp;<ref refid="namespacetf" kindref="compound">tf</ref>=others[n]](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>caller<sp/>worker<sp/>will<sp/>not<sp/>block<sp/>but<sp/>corun<sp/>these</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>taskflows<sp/>through<sp/>its<sp/>work-stealing<sp/>loop</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>executor.<ref refid="classtf_1_1Executor_1a8fcd9e0557922bb8194999f0cd433ea8" kindref="member">corun</ref>(<ref refid="namespacetf" kindref="compound">tf</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow).wait();</highlight></codeline>
</programlisting></para>
<para>Similar to <ref refid="classtf_1_1Executor_1a8fcd9e0557922bb8194999f0cd433ea8" kindref="member">tf::Executor::corun</ref>, the method <ref refid="classtf_1_1Executor_1a0fc6eb19f168dc4a9cd0a7c6187c1d2d" kindref="member">tf::Executor::corun_until</ref> is another variant that keeps the calling worker in the work-stealing loop until the given predicate becomes true. You can use this method to prevent blocking a worker from doing useful things, such as being blocked when submitting an outstanding task (e.g., a GPU operation).</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([&amp;](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>fu<sp/>=<sp/><ref refid="cpp/thread/async" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::async</ref>([](){<sp/>std::sleep(100s);<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>executor.<ref refid="classtf_1_1Executor_1a0fc6eb19f168dc4a9cd0a7c6187c1d2d" kindref="member">corun_until</ref>([](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>fu.wait_for(<ref refid="cpp/chrono/duration" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::chrono::seconds</ref>(0))<sp/>==<sp/>future_status::ready;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting></para>
<para><simplesect kind="attention"><para>You must call <ref refid="classtf_1_1Executor_1a0fc6eb19f168dc4a9cd0a7c6187c1d2d" kindref="member">tf::Executor::corun_until</ref> and <ref refid="classtf_1_1Executor_1a8fcd9e0557922bb8194999f0cd433ea8" kindref="member">tf::Executor::corun</ref> from a worker of the calling executor or an exception will be thrown.</para>
</simplesect>
</para>
</sect1>
<sect1 id="ExecuteTaskflow_1ThreadSafety">
<title>Touch an Executor from Multiple Threads</title>
<para>All <computeroutput>run_*</computeroutput> methods are <emphasis>thread-safe</emphasis>. You can have multiple threads call these methods from an executor to run different taskflows. However, the order which taskflow runs first is non-deterministic and is up to the runtime.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><sp/>1:<sp/><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/>executor;</highlight></codeline>
<codeline><highlight class="normal"><sp/>2:</highlight></codeline>
<codeline><highlight class="normal"><sp/>3:<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;10;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>4:<sp/><sp/><sp/><ref refid="cpp/thread/thread" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::thread</ref>([i,<sp/>&amp;](){</highlight></codeline>
<codeline><highlight class="normal"><sp/>5:<sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>...<sp/>modify<sp/>my<sp/>taskflow<sp/>at<sp/>i</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/>6:<sp/><sp/><sp/><sp/><sp/>executor.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflows[i]);<sp/><sp/></highlight><highlight class="comment">//<sp/>run<sp/>my<sp/>taskflow<sp/>at<sp/>i</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/>7:<sp/><sp/><sp/>}).detach();</highlight></codeline>
<codeline><highlight class="normal"><sp/>8:<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/>9:</highlight></codeline>
<codeline><highlight class="normal">10:<sp/>executor.<ref refid="classtf_1_1Executor_1ab9aa252f70e9a40020a1e5a89d485b85" kindref="member">wait_for_all</ref>();</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="ExecuteTaskflow_1QueryTheWorkerID">
<title>Query the Worker ID</title>
<para>Each worker in an executor has an unique integer identifier in the range <computeroutput>[0, N)</computeroutput> that can be queried by the caller thread using <ref refid="classtf_1_1Executor_1a6487d589cb1f6b078b69fd3bb1082345" kindref="member">tf::Executor::this_worker_id</ref>. If the caller thread is not a worker in the executor, <computeroutput>-1</computeroutput> is returned. This method is convenient for users to maintain a one-to-one mapping between a worker and its application data structure.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;int&gt;</ref><sp/>worker_vectors[8];<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>one<sp/>vector<sp/>per<sp/>worker</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/>executor(8);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>an<sp/>executor<sp/>of<sp/>eight<sp/>workers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">assert(executor.<ref refid="classtf_1_1Executor_1a6487d589cb1f6b078b69fd3bb1082345" kindref="member">this_worker_id</ref>()<sp/>==<sp/>-1);<sp/><sp/></highlight><highlight class="comment">//<sp/>master<sp/>thread<sp/>is<sp/>not<sp/>a<sp/>worker</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([&amp;](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal"><sp/>=<sp/>executor.<ref refid="classtf_1_1Executor_1a6487d589cb1f6b078b69fd3bb1082345" kindref="member">this_worker_id</ref>();<sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>in<sp/>the<sp/>range<sp/>[0,<sp/>8)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>vec<sp/>=<sp/>worker_vectors[worker_id];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="ExecuteTaskflow_1ObserveThreadActivities">
<title>Observe Thread Activities</title>
<para>You can observe thread activities in an executor when a worker thread participates in executing a task and leaves the execution using <ref refid="classtf_1_1ObserverInterface" kindref="compound">tf::ObserverInterface</ref> <ndash/> an <emphasis>interface</emphasis> class that provides a set of methods for you to define what to do when a thread enters and leaves the execution context of a task.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">ObserverInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/><ref refid="classtf_1_1ObserverInterface_1adfd71c3af3ae2ea4f41eed26c1b6f604" kindref="member">~ObserverInterface</ref>()<sp/>=<sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classtf_1_1ObserverInterface_1a41e6e62f12bf9d9dc4fa74632f6825d9" kindref="member">set_up</ref>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>num_workers)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classtf_1_1ObserverInterface_1a8225fcacb03089677a1efc4b16b734cc" kindref="member">on_entry</ref>(<ref refid="classtf_1_1WorkerView" kindref="compound">tf::WorkerView</ref><sp/>worker_view,<sp/><ref refid="classtf_1_1TaskView" kindref="compound">tf::TaskView</ref><sp/>task_view)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classtf_1_1ObserverInterface_1aa22f5378154653f08d9a58326bda4754" kindref="member">on_exit</ref>(<ref refid="classtf_1_1WorkerView" kindref="compound">tf::WorkerView</ref><sp/>worker_view,<sp/><ref refid="classtf_1_1TaskView" kindref="compound">tf::TaskView</ref><sp/>task_view)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>There are three methods you must define in your derived class, <ref refid="classtf_1_1ObserverInterface_1a41e6e62f12bf9d9dc4fa74632f6825d9" kindref="member">tf::ObserverInterface::set_up</ref>, <ref refid="classtf_1_1ObserverInterface_1a8225fcacb03089677a1efc4b16b734cc" kindref="member">tf::ObserverInterface::on_entry</ref>, and <ref refid="classtf_1_1ObserverInterface_1aa22f5378154653f08d9a58326bda4754" kindref="member">tf::ObserverInterface::on_exit</ref>. The method, <ref refid="classtf_1_1ObserverInterface_1a41e6e62f12bf9d9dc4fa74632f6825d9" kindref="member">tf::ObserverInterface::set_up</ref>, is a constructor-like method that will be called by the executor when the observer is constructed. It passes an argument of the number of workers to observer in the executor. You may use it to preallocate or initialize data storage, e.g., an independent vector for each worker. The methods, <ref refid="classtf_1_1ObserverInterface_1a8225fcacb03089677a1efc4b16b734cc" kindref="member">tf::ObserverInterface::on_entry</ref> and <ref refid="classtf_1_1ObserverInterface_1aa22f5378154653f08d9a58326bda4754" kindref="member">tf::ObserverInterface::on_exit</ref>, are called by a worker thread before and after the execution context of a task, respectively. Both methods provide immutable access to the underlying worker and the running task using <ref refid="classtf_1_1WorkerView" kindref="compound">tf::WorkerView</ref> and <ref refid="classtf_1_1TaskView" kindref="compound">tf::TaskView</ref>. You may use them to record timepoints and calculate the elapsed time of a task.</para>
<para>You can associate an executor with one or multiple observers (though one is common) using <ref refid="classtf_1_1Executor_1ab5a793a0f2ce41cd49ca45e9f0a6962c" kindref="member">tf::Executor::make_observer</ref>. We use <ref refid="cpp/memory/shared_ptr" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::shared_ptr</ref> to manage the ownership of an observer. The executor loops through each observer and invoke the corresponding methods accordingly.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="taskflow_8hpp" kindref="compound">taskflow/taskflow.hpp</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">MyObserver<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classtf_1_1ObserverInterface" kindref="compound">tf::ObserverInterface</ref><sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MyObserver(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="cpp/string/basic_string" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::string</ref>&amp;<sp/>name)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;constructing<sp/>observer<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>name<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;\n&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>set_up(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>num_workers)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">final</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;setting<sp/>up<sp/>observer<sp/>with<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>num_workers<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>workers\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>on_entry(<ref refid="classtf_1_1WorkerView" kindref="compound">tf::WorkerView</ref><sp/>w,<sp/><ref refid="classtf_1_1TaskView" kindref="compound">tf::TaskView</ref><sp/>tv)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">final</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/basic_ostringstream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostringstream</ref><sp/>oss;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>oss<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;worker<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>w.id()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>ready<sp/>to<sp/>run<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>tv.name()<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;\n&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/>oss.str();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>on_exit(<ref refid="classtf_1_1WorkerView" kindref="compound">tf::WorkerView</ref><sp/>w,<sp/><ref refid="classtf_1_1TaskView" kindref="compound">tf::TaskView</ref><sp/>tv)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">final</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/basic_ostringstream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostringstream</ref><sp/>oss;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>oss<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;worker<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>w.id()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>finished<sp/>running<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>tv.name()<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;\n&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/>oss.str();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/>executor(4);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>taskflow<sp/>of<sp/>eight<sp/>tasks</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>A<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;1\n&quot;</highlight><highlight class="normal">;<sp/>}).name(</highlight><highlight class="stringliteral">&quot;A&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>B<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;2\n&quot;</highlight><highlight class="normal">;<sp/>}).name(</highlight><highlight class="stringliteral">&quot;B&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>C<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;3\n&quot;</highlight><highlight class="normal">;<sp/>}).name(</highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>D<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;4\n&quot;</highlight><highlight class="normal">;<sp/>}).name(</highlight><highlight class="stringliteral">&quot;D&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>E<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;5\n&quot;</highlight><highlight class="normal">;<sp/>}).name(</highlight><highlight class="stringliteral">&quot;E&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>F<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;6\n&quot;</highlight><highlight class="normal">;<sp/>}).name(</highlight><highlight class="stringliteral">&quot;F&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>G<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;7\n&quot;</highlight><highlight class="normal">;<sp/>}).name(</highlight><highlight class="stringliteral">&quot;G&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>H<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;8\n&quot;</highlight><highlight class="normal">;<sp/>}).name(</highlight><highlight class="stringliteral">&quot;H&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>an<sp/>observer</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="cpp/memory/shared_ptr" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::shared_ptr&lt;MyObserver&gt;</ref><sp/>observer<sp/>=<sp/>executor.<ref refid="classtf_1_1Executor_1ab5a793a0f2ce41cd49ca45e9f0a6962c" kindref="member">make_observer</ref>&lt;MyObserver&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;MyObserver&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>run<sp/>the<sp/>taskflow</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>executor.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow).get();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>remove<sp/>the<sp/>observer<sp/>(optional)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>executor.<ref refid="classtf_1_1Executor_1a31081f492c376f7b798de0e430534531" kindref="member">remove_observer</ref>(std::move(observer));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The above code produces the following output:</para>
<para><programlisting filename=".bash"><codeline><highlight class="normal">constructing<sp/>observer<sp/>MyObserver</highlight></codeline>
<codeline><highlight class="normal">setting<sp/>up<sp/>observer<sp/>with<sp/>4<sp/>workers</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>2<sp/>ready<sp/>to<sp/>run<sp/>A</highlight></codeline>
<codeline><highlight class="normal">1</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>2<sp/>finished<sp/>running<sp/>A</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>2<sp/>ready<sp/>to<sp/>run<sp/>B</highlight></codeline>
<codeline><highlight class="normal">2</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>1<sp/>ready<sp/>to<sp/>run<sp/>C</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>2<sp/>finished<sp/>running<sp/>B</highlight></codeline>
<codeline><highlight class="normal">3</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>2<sp/>ready<sp/>to<sp/>run<sp/>D</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>3<sp/>ready<sp/>to<sp/>run<sp/>E</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>1<sp/>finished<sp/>running<sp/>C</highlight></codeline>
<codeline><highlight class="normal">4</highlight></codeline>
<codeline><highlight class="normal">5</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>1<sp/>ready<sp/>to<sp/>run<sp/>F</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>2<sp/>finished<sp/>running<sp/>D</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>3<sp/>finished<sp/>running<sp/>E</highlight></codeline>
<codeline><highlight class="normal">6</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>2<sp/>ready<sp/>to<sp/>run<sp/>G</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>3<sp/>ready<sp/>to<sp/>run<sp/>H</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>1<sp/>finished<sp/>running<sp/>F</highlight></codeline>
<codeline><highlight class="normal">7</highlight></codeline>
<codeline><highlight class="normal">8</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>2<sp/>finished<sp/>running<sp/>G</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>3<sp/>finished<sp/>running<sp/>H</highlight></codeline>
</programlisting></para>
<para>It is expected each line of <ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref> interleaves with each other as there are four workers participating in task scheduling. However, the <emphasis>ready</emphasis> message always appears before the corresponding task message (e.g., numbers) and then the <emphasis>finished</emphasis> message.</para>
</sect1>
<sect1 id="ExecuteTaskflow_1ModifyWorkerProperty">
<title>Modify Worker Property</title>
<para>You can change the property of each worker thread from its executor, such as assigning thread-processor affinity before the worker enters the scheduler loop and post-processing additional information after the worker leaves the scheduler loop, by passing an instance derived from <ref refid="classtf_1_1WorkerInterface" kindref="compound">tf::WorkerInterface</ref> to the executor. The example demonstrates the usage of <ref refid="classtf_1_1WorkerInterface" kindref="compound">tf::WorkerInterface</ref> to affine a worker to a specific CPU core equal to its id on a linux platform:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>affine<sp/>the<sp/>given<sp/>thread<sp/>to<sp/>the<sp/>given<sp/>core<sp/>index<sp/>(linux-specific)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">bool</highlight><highlight class="normal"><sp/>affine(<ref refid="cpp/thread/thread" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::thread</ref>&amp;<sp/>thread,<sp/></highlight><highlight class="keywordtype">unsigned</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>core_id)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>cpu_set_t<sp/>cpuset;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CPU_ZERO(&amp;cpuset);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>CPU_SET(core_id,<sp/>&amp;cpuset);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>pthread_t<sp/>native_handle<sp/>=<sp/>thread.native_handle();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>pthread_setaffinity_np(native_handle,<sp/></highlight><highlight class="keyword">sizeof</highlight><highlight class="normal">(cpu_set_t),<sp/>&amp;cpuset)<sp/>==<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">class<sp/></highlight><highlight class="normal">CustomWorkerBehavior<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classtf_1_1WorkerInterface" kindref="compound">tf::WorkerInterface</ref><sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal">:</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>to<sp/>call<sp/>before<sp/>the<sp/>worker<sp/>enters<sp/>the<sp/>scheduling<sp/>loop</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>scheduler_prologue(<ref refid="classtf_1_1Worker" kindref="compound">tf::Worker</ref>&amp;<sp/>w)</highlight><highlight class="keyword"><sp/>override<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;worker<sp/>%lu<sp/>prepares<sp/>to<sp/>enter<sp/>the<sp/>work-stealing<sp/>loop\n&quot;</highlight><highlight class="normal">,<sp/>w.<ref refid="classtf_1_1Worker_1a0180ea51cc46551157eaae451b50c7d8" kindref="member">id</ref>());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>now<sp/>affine<sp/>the<sp/>worker<sp/>to<sp/>a<sp/>particular<sp/>CPU<sp/>core<sp/>equal<sp/>to<sp/>its<sp/>id</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal">(affine(w.<ref refid="classtf_1_1Worker_1a8ece561266a54409268856ec5768a3c5" kindref="member">thread</ref>(),<sp/>w.<ref refid="classtf_1_1Worker_1a0180ea51cc46551157eaae451b50c7d8" kindref="member">id</ref>()))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;successfully<sp/>affines<sp/>worker<sp/>%lu<sp/>to<sp/>CPU<sp/>core<sp/>%lu\n&quot;</highlight><highlight class="normal">,<sp/>w.<ref refid="classtf_1_1Worker_1a0180ea51cc46551157eaae451b50c7d8" kindref="member">id</ref>(),<sp/>w.<ref refid="classtf_1_1Worker_1a0180ea51cc46551157eaae451b50c7d8" kindref="member">id</ref>());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">else</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;failed<sp/>to<sp/>affine<sp/>worker<sp/>%lu<sp/>to<sp/>CPU<sp/>core<sp/>%lu\n&quot;</highlight><highlight class="normal">,<sp/>w.<ref refid="classtf_1_1Worker_1a0180ea51cc46551157eaae451b50c7d8" kindref="member">id</ref>(),<sp/>w.<ref refid="classtf_1_1Worker_1a0180ea51cc46551157eaae451b50c7d8" kindref="member">id</ref>());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>to<sp/>call<sp/>after<sp/>the<sp/>worker<sp/>leaves<sp/>the<sp/>scheduling<sp/>loop</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>scheduler_epilogue(<ref refid="classtf_1_1Worker" kindref="compound">tf::Worker</ref>&amp;<sp/>w,<sp/><ref refid="cpp/error/exception_ptr" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::exception_ptr</ref>)</highlight><highlight class="keyword"><sp/>override<sp/></highlight><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;worker<sp/>%lu<sp/>left<sp/>the<sp/>work-stealing<sp/>loop\n&quot;</highlight><highlight class="normal">,<sp/>w.<ref refid="classtf_1_1Worker_1a0180ea51cc46551157eaae451b50c7d8" kindref="member">id</ref>());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/>executor(4,<sp/>tf::make_worker_interface&lt;CustomWorkerBehavior&gt;());</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>When running the program, we see the following one possible output:</para>
<para><programlisting filename=".shell-session"><codeline><highlight class="normal">worker<sp/>3<sp/>prepares<sp/>to<sp/>enter<sp/>the<sp/>work-stealing<sp/>loop</highlight></codeline>
<codeline><highlight class="normal">successfully<sp/>affines<sp/>worker<sp/>3<sp/>to<sp/>CPU<sp/>core<sp/>3</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>3<sp/>left<sp/>the<sp/>work-stealing<sp/>loop</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>0<sp/>prepares<sp/>to<sp/>enter<sp/>the<sp/>work-stealing<sp/>loop</highlight></codeline>
<codeline><highlight class="normal">successfully<sp/>affines<sp/>worker<sp/>0<sp/>to<sp/>CPU<sp/>core<sp/>0</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>0<sp/>left<sp/>the<sp/>work-stealing<sp/>loop</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>1<sp/>prepares<sp/>to<sp/>enter<sp/>the<sp/>work-stealing<sp/>loop</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>2<sp/>prepares<sp/>to<sp/>enter<sp/>the<sp/>work-stealing<sp/>loop</highlight></codeline>
<codeline><highlight class="normal">successfully<sp/>affines<sp/>worker<sp/>1<sp/>to<sp/>CPU<sp/>core<sp/>1</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>1<sp/>left<sp/>the<sp/>work-stealing<sp/>loop</highlight></codeline>
<codeline><highlight class="normal">successfully<sp/>affines<sp/>worker<sp/>2<sp/>to<sp/>CPU<sp/>core<sp/>2</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>2<sp/>left<sp/>the<sp/>work-stealing<sp/>loop</highlight></codeline>
</programlisting></para>
<para>When you create an executor, it spawns a set of worker threads to run tasks using a work-stealing scheduling algorithm. The execution logic of the scheduler and its interaction with each spawned worker via <ref refid="classtf_1_1WorkerInterface" kindref="compound">tf::WorkerInterface</ref> is given below:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>n=0;<sp/>n&lt;num_workers;<sp/>n++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>create_thread([](Worker&amp;<sp/>worker)</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>pre-processing<sp/>executor-specific<sp/>worker<sp/>information</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>enter<sp/>the<sp/>scheduling<sp/>loop</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Here,<sp/>WorkerInterface::scheduler_prologue<sp/>is<sp/>invoked,<sp/>if<sp/>any</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>worker_interface-&gt;scheduler_prologue(worker);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">try</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>while(1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>perform_work_stealing_algorithm();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>if(stop)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>break;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}<sp/></highlight><highlight class="keywordflow">catch</highlight><highlight class="normal">(...)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>exception_ptr<sp/>=<sp/><ref refid="cpp/error/current_exception" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::current_exception</ref>();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>leaves<sp/>the<sp/>scheduling<sp/>loop<sp/>and<sp/>joins<sp/>this<sp/>worker<sp/>thread</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>Here,<sp/>WorkerInterface::scheduler_epilogue<sp/>is<sp/>invoked,<sp/>if<sp/>any</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>worker_interface-&gt;scheduler_epilogue(worker,<sp/>exception_ptr);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para><simplesect kind="attention"><para><ref refid="classtf_1_1WorkerInterface_1a41c3b931a36bde8eff4aa8d375e8888a" kindref="member">tf::WorkerInterface::scheduler_prologue</ref> and tf::WorkerInterface::scheduler_eiplogue are invoked by each worker simultaneously. </para>
</simplesect>
</para>
</sect1>
    </detaileddescription>
    <location file="doxygen/cookbook/executor.dox"/>
  </compounddef>
</doxygen>
