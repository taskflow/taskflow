<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="ExecuteTaskflow" kind="page">
    <compoundname>ExecuteTaskflow</compoundname>
    <title>Executor</title>
    <tableofcontents>
      <tocsect>
        <name>Create an Executor</name>
        <reference>ExecuteTaskflow_1CreateAnExecutor</reference>
    </tocsect>
      <tocsect>
        <name>Execute a Taskflow</name>
        <reference>ExecuteTaskflow_1ExecuteATaskflow</reference>
    </tocsect>
      <tocsect>
        <name>Execute a Taskflow with Transferred Ownership</name>
        <reference>ExecuteTaskflow_1ExecuteATaskflowWithTransferredOwnership</reference>
    </tocsect>
      <tocsect>
        <name>Execute a Taskflow from an Internal Worker</name>
        <reference>ExecuteTaskflow_1ExecuteATaskflowFromAnInternalWorker</reference>
    </tocsect>
      <tocsect>
        <name>Touch an Executor from Multiple Threads</name>
        <reference>ExecuteTaskflow_1ThreadSafety</reference>
    </tocsect>
      <tocsect>
        <name>Query the Worker ID</name>
        <reference>ExecuteTaskflow_1QueryTheWorkerID</reference>
    </tocsect>
      <tocsect>
        <name>Observe Thread Activities</name>
        <reference>ExecuteTaskflow_1ObserveThreadActivities</reference>
    </tocsect>
    </tableofcontents>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>After you create a task dependency graph, you need to submit it to threads for execution. In this chapter, we will show you how to execute a task dependency graph.</para>
<sect1 id="ExecuteTaskflow_1CreateAnExecutor">
<title>Create an Executor</title>
<para>To execute a taskflow, you need to create an <emphasis>executor</emphasis> of type tf::Executor. An executor is a <emphasis>thread-safe</emphasis> object that manages a set of worker threads and executes tasks through an efficient <emphasis>work-stealing</emphasis> algorithm. Issuing a call to run a taskflow creates a <emphasis>topology</emphasis>, a data structure to keep track of the execution status of a running graph. tf::Executor takes an unsigned integer to construct with <computeroutput>N</computeroutput> worker threads. The default value is <ref refid="cpp/thread/thread/hardware_concurrency" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::thread::hardware_concurrency</ref>.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">tf::Executor<sp/>executor1;<sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>an<sp/>executor<sp/>with<sp/>the<sp/>number<sp/>of<sp/>workers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>equal<sp/>to<sp/>std::thread::hardware_concurrency</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">tf::Executor<sp/>executor2(4);<sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>an<sp/>executor<sp/>of<sp/>4<sp/>worker<sp/>threads</highlight></codeline>
</programlisting></para>
<para>An executor can be reused to execute multiple taskflows. In most workloads, you may need only one executor to run multiple taskflows where each taskflow represents a part of a parallel decomposition.</para>
</sect1>
<sect1 id="ExecuteTaskflow_1ExecuteATaskflow">
<title>Execute a Taskflow</title>
<para>tf::Executor provides a set of <computeroutput>run_*</computeroutput> methods, tf::Executor::run, tf::Executor::run_n, and tf::Executor::run_until to run a taskflow for one time, multiple times, or until a given predicate evaluates to true. All methods accept an optional callback to invoke after the execution completes, and return a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> for users to access the execution status. The code below shows several ways to run a taskflow.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><sp/>1:<sp/></highlight><highlight class="comment">//<sp/>Declare<sp/>an<sp/>executor<sp/>and<sp/>a<sp/>taskflow</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/>2:<sp/>tf::Executor<sp/>executor;</highlight></codeline>
<codeline><highlight class="normal"><sp/>3:<sp/><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"><sp/>4:</highlight></codeline>
<codeline><highlight class="normal"><sp/>5:<sp/></highlight><highlight class="comment">//<sp/>Add<sp/>three<sp/>tasks<sp/>into<sp/>the<sp/>taskflow</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/>6:<sp/><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>A<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>is<sp/>TaskA\n&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/>7:<sp/><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>B<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>is<sp/>TaskB\n&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/>8:<sp/><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>C<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>is<sp/>TaskC\n&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/>9:<sp/></highlight></codeline>
<codeline><highlight class="normal">10:<sp/></highlight><highlight class="comment">//<sp/>Build<sp/>precedence<sp/>between<sp/>tasks</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">11:<sp/>A.<ref refid="classtf_1_1Task_1a8c78c453295a553c1c016e4062da8588" kindref="member">precede</ref>(B,<sp/>C);<sp/></highlight></codeline>
<codeline><highlight class="normal">12:<sp/></highlight></codeline>
<codeline><highlight class="normal">13:<sp/><ref refid="classtf_1_1Future" kindref="compound">tf::Future&lt;void&gt;</ref><sp/>fu<sp/>=<sp/>executor.run(taskflow);</highlight></codeline>
<codeline><highlight class="normal">14:<sp/>fu.wait();<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>block<sp/>until<sp/>the<sp/>execution<sp/>completes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">15:</highlight></codeline>
<codeline><highlight class="normal">16:<sp/>executor.run(taskflow,<sp/>[](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;end<sp/>of<sp/>1<sp/>run&quot;</highlight><highlight class="normal">;<sp/>}).wait();</highlight></codeline>
<codeline><highlight class="normal">17:<sp/>executor.run_n(taskflow,<sp/>4);</highlight></codeline>
<codeline><highlight class="normal">18:<sp/>executor.wait_for_all();<sp/><sp/></highlight><highlight class="comment">//<sp/>block<sp/>until<sp/>all<sp/>associated<sp/>executions<sp/>finish</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">19:<sp/>executor.run_n(taskflow,<sp/>4,<sp/>[](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;end<sp/>of<sp/>4<sp/>runs&quot;</highlight><highlight class="normal">;<sp/>}).wait();</highlight></codeline>
<codeline><highlight class="normal">20:<sp/>executor.run_until(taskflow,<sp/>[cnt=0]<sp/>()<sp/></highlight><highlight class="keyword">mutable</highlight><highlight class="normal"><sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>++cnt<sp/>==<sp/>10;<sp/>});</highlight></codeline>
</programlisting></para>
<para>Debrief:</para>
<para><itemizedlist>
<listitem><para>Lines 6-8 create a taskflow of three tasks A, B, and C </para>
</listitem>
<listitem><para>Lines 13-14 run the taskflow once and wait for completion </para>
</listitem>
<listitem><para>Line 16 runs the taskflow once with a callback to invoke when the execution finishes </para>
</listitem>
<listitem><para>Lines 17-18 run the taskflow four times and use tf::Executor::wait_for_all to wait for completion </para>
</listitem>
<listitem><para>Line 19 runs the taskflow four times and invokes a callback at the end of the forth execution </para>
</listitem>
<listitem><para>Line 20 keeps running the taskflow until the predicate returns true</para>
</listitem>
</itemizedlist>
Issuing multiple runs on the same taskflow will automatically <emphasis>synchronize</emphasis> to a sequential chain of executions in the order of run calls.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">executor.run(taskflow);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>execution<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.run_n(taskflow,<sp/>10);<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>execution<sp/>2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.run(taskflow);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>execution<sp/>3</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.wait_for_all();<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>execution<sp/>1<sp/>-&gt;<sp/>execution<sp/>2<sp/>-&gt;<sp/>execution<sp/>3</highlight></codeline>
</programlisting></para>
<para><simplesect kind="attention"><para>A running taskflow must remain alive during its execution. It is your responsibility to ensure a taskflow not being destructed when it is running. For example, the code below can result undefined behavior.</para>
</simplesect>
<programlisting filename=".cpp"><codeline><highlight class="normal">tf::Executor<sp/>executor;<sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>an<sp/>executor</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>create<sp/>a<sp/>taskflow<sp/>whose<sp/>lifetime<sp/>is<sp/>restricted<sp/>by<sp/>the<sp/>scope</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>add<sp/>tasks<sp/>to<sp/>the<sp/>taskflow</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>...<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>run<sp/>the<sp/>taskflow</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>executor.run(f);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">}<sp/></highlight><highlight class="comment">//<sp/>leaving<sp/>the<sp/>scope<sp/>will<sp/>destroy<sp/>taskflow<sp/>while<sp/>it<sp/>is<sp/>running,<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>resulting<sp/>in<sp/>undefined<sp/>behavior</highlight></codeline>
</programlisting></para>
<para>Similarly, you should avoid touching a taskflow while it is running.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Add<sp/>tasks<sp/>into<sp/>the<sp/>taskflow</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Declare<sp/>an<sp/>executor</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">tf::Executor<sp/>executor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Future" kindref="compound">tf::Future&lt;void&gt;</ref><sp/>future<sp/>=<sp/>taskflow.run(f);<sp/><sp/></highlight><highlight class="comment">//<sp/>non-blocking<sp/>return</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>alter<sp/>the<sp/>taskflow<sp/>while<sp/>running<sp/>leads<sp/>to<sp/>undefined<sp/>behavior<sp/></highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">f.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;Add<sp/>a<sp/>new<sp/>task\n&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
</programlisting></para>
<para>You must always keep a taskflow alive and must not modify it while it is running on an executor.</para>
</sect1>
<sect1 id="ExecuteTaskflow_1ExecuteATaskflowWithTransferredOwnership">
<title>Execute a Taskflow with Transferred Ownership</title>
<para>You can transfer the ownership of a taskflow to an executor and run it without wrangling with the lifetime issue of that taskflow. Each <computeroutput>run_*</computeroutput> method discussed in the previous section comes with an overload that takes a <emphasis>moved</emphasis> taskflow object.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal">tf::Executor<sp/>executor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>let<sp/>the<sp/>executor<sp/>manage<sp/>the<sp/>lifetime<sp/>of<sp/>the<sp/>submitted<sp/>taskflow</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.run(std::move(taskflow));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>now<sp/>taskflow<sp/>has<sp/>no<sp/>tasks</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">assert(taskflow.<ref refid="classtf_1_1Taskflow_1af4f03bca084deb5c2228ac8936d33649" kindref="member">num_tasks</ref>()<sp/>==<sp/>0);</highlight></codeline>
</programlisting></para>
<para>However, you should avoid moving a <emphasis>running</emphasis> taskflow which can result in undefined behavior.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal">tf::Executor<sp/>executor;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>executor<sp/>does<sp/>not<sp/>manage<sp/>the<sp/>lifetime<sp/>of<sp/>taskflow</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.run(taskflow);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>error!<sp/>you<sp/>cannot<sp/>move<sp/>a<sp/>taskflow<sp/>while<sp/>it<sp/>is<sp/>running</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.run(std::move(taskflow));<sp/><sp/></highlight></codeline>
</programlisting></para>
<para>The correct way to submit a taskflow with moved ownership to an executor is to ensure all previous runs have completed. The executor will automatically release the resources of a moved taskflow right <emphasis>after</emphasis> its execution completes.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>submit<sp/>the<sp/>taskflow<sp/>and<sp/>wait<sp/>until<sp/>it<sp/>completes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.run(taskflow).wait();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>now<sp/>it&apos;s<sp/>safe<sp/>to<sp/>move<sp/>the<sp/>taskflow<sp/>to<sp/>the<sp/>executor<sp/>and<sp/>run<sp/>it</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.run(std::move(taskflow));<sp/><sp/></highlight></codeline>
</programlisting></para>
<para>Likewise, you cannot move a taskflow that is running on an executor. You must wait until all the previous fires of runs on that taskflow complete before calling move.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>submit<sp/>the<sp/>taskflow<sp/>and<sp/>wait<sp/>until<sp/>it<sp/>completes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.run(taskflow).wait();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>now<sp/>it&apos;s<sp/>safe<sp/>to<sp/>move<sp/>the<sp/>taskflow<sp/>to<sp/>another</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>moved_taskflow(std::move(taskflow));<sp/><sp/></highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="ExecuteTaskflow_1ExecuteATaskflowFromAnInternalWorker">
<title>Execute a Taskflow from an Internal Worker</title>
<para>Each run variant of tf::Executor returns a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> object which allows you to wait for the result to complete. When calling <computeroutput>tf::Future::wait</computeroutput>, the caller blocks without doing anything until the associated state is written to be ready. This design, however, can introduce deadlock problem especially when you need to run multiple taskflows from the internal workers of an executor. For example, the code below creates a taskflow of 1000 tasks with each task running a taskflow of 500 tasks in a blocking fashion:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">tf::Executor<sp/>executor(2);</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/container/array" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::array&lt;tf::Taskflow, 1000&gt;</ref><sp/>others;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/atomic/atomic" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::atomic&lt;size_t&gt;</ref><sp/>counter{0};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>n=0;<sp/>n&lt;1000;<sp/>n++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;500;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>others[n].emplace([&amp;](){<sp/>counter++;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([&amp;executor,<sp/>&amp;<ref refid="namespacetf" kindref="compound">tf</ref>=others[n]](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>blocking<sp/>the<sp/>worker<sp/>can<sp/>introduce<sp/>deadlock<sp/>where</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>all<sp/>workers<sp/>are<sp/>waiting<sp/>for<sp/>their<sp/>taskflows<sp/>to<sp/>finish</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>executor.run(<ref refid="namespacetf" kindref="compound">tf</ref>).wait();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">executor.run(taskflow).wait();</highlight></codeline>
</programlisting></para>
<para>To avoid this problem, the executor has a method, tf::Executor::corun, to execute a taskflow from a worker of that executor. The worker will not block but co-run the taskflow with other tasks in its work-stealing loop.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">tf::Executor<sp/>executor(2);</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/container/array" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::array&lt;tf::Taskflow, 1000&gt;</ref><sp/>others;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/atomic/atomic" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::atomic&lt;size_t&gt;</ref><sp/>counter{0};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>n=0;<sp/>n&lt;1000;<sp/>n++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;500;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>others[n].emplace([&amp;](){<sp/>counter++;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([&amp;executor,<sp/>&amp;<ref refid="namespacetf" kindref="compound">tf</ref>=others[n]](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>caller<sp/>worker<sp/>will<sp/>not<sp/>block<sp/>but<sp/>corun<sp/>these</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>taskflows<sp/>through<sp/>its<sp/>work-stealing<sp/>loop</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>executor.corun(<ref refid="namespacetf" kindref="compound">tf</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">executor.run(taskflow).wait();</highlight></codeline>
</programlisting></para>
<para>Similar to tf::Executor::corun, the method tf::Executor::corun_until is another variant that keeps the calling worker in the work-stealing loop until the given predicate becomes true. You can use this method to prevent blocking a worker from doing useful things, such as being blocked when submitting an outstanding task (e.g., a GPU operation).</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([&amp;](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>fu<sp/>=<sp/><ref refid="cpp/thread/async" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::async</ref>([](){<sp/>std::sleep(100s);<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>executor.corun_until([](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>fu.wait_for(<ref refid="cpp/chrono/duration" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::chrono::seconds</ref>(0))<sp/>==<sp/>future_status::ready;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting></para>
<para><simplesect kind="attention"><para>You must call tf::Executor::corun_until and tf::Executor::corun from a worker of the calling executor or an exception will be thrown.</para>
</simplesect>
</para>
</sect1>
<sect1 id="ExecuteTaskflow_1ThreadSafety">
<title>Touch an Executor from Multiple Threads</title>
<para>All <computeroutput>run_*</computeroutput> methods are <emphasis>thread-safe</emphasis>. You can have multiple threads call these methods from an executor to run different taskflows. However, the order which taskflow runs first is non-deterministic and is up to the runtime.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><sp/>1:<sp/>tf::Executor<sp/>executor;</highlight></codeline>
<codeline><highlight class="normal"><sp/>2:</highlight></codeline>
<codeline><highlight class="normal"><sp/>3:<sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;10;<sp/>++i)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/>4:<sp/><sp/><sp/><ref refid="cpp/thread/thread" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::thread</ref>([i,<sp/>&amp;](){</highlight></codeline>
<codeline><highlight class="normal"><sp/>5:<sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>...<sp/>modify<sp/>my<sp/>taskflow<sp/>at<sp/>i</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/>6:<sp/><sp/><sp/><sp/><sp/>executor.run(taskflows[i]);<sp/><sp/></highlight><highlight class="comment">//<sp/>run<sp/>my<sp/>taskflow<sp/>at<sp/>i</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/>7:<sp/><sp/><sp/>}).detach();</highlight></codeline>
<codeline><highlight class="normal"><sp/>8:<sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/>9:</highlight></codeline>
<codeline><highlight class="normal">10:<sp/>executor.wait_for_all();</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="ExecuteTaskflow_1QueryTheWorkerID">
<title>Query the Worker ID</title>
<para>Each worker in an executor has an unique integer identifier in the range <computeroutput>[0, N)</computeroutput> that can be queried by the caller thread using tf::Executor::this_worker_id. If the caller thread is not a worker in the executor, <computeroutput>-1</computeroutput> is returned. This method is convenient for users to maintain a one-to-one mapping between a worker and its application data structure.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;int&gt;</ref><sp/>worker_vectors[8];<sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>one<sp/>vector<sp/>per<sp/>worker</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal">tf::Executor<sp/>executor(8);<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>an<sp/>executor<sp/>of<sp/>eight<sp/>workers</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">assert(executor.this_worker_id()<sp/>==<sp/>-1);<sp/><sp/></highlight><highlight class="comment">//<sp/>master<sp/>thread<sp/>is<sp/>not<sp/>a<sp/>worker</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([&amp;](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">id</highlight><highlight class="normal"><sp/>=<sp/>executor.this_worker_id();<sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>in<sp/>the<sp/>range<sp/>[0,<sp/>8)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>vec<sp/>=<sp/>worker_vectors[worker_id];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>...</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting></para>
</sect1>
<sect1 id="ExecuteTaskflow_1ObserveThreadActivities">
<title>Observe Thread Activities</title>
<para>You can observe thread activities in an executor when a worker thread participates in executing a task and leaves the execution using <ref refid="classtf_1_1ObserverInterface" kindref="compound">tf::ObserverInterface</ref> <ndash/> an <emphasis>interface</emphasis> class that provides a set of methods for you to define what to do when a thread enters and leaves the execution context of a task.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">class<sp/></highlight><highlight class="normal">ObserverInterface<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/><ref refid="classtf_1_1ObserverInterface_1adfd71c3af3ae2ea4f41eed26c1b6f604" kindref="member">~ObserverInterface</ref>()<sp/>=<sp/></highlight><highlight class="keywordflow">default</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classtf_1_1ObserverInterface_1a41e6e62f12bf9d9dc4fa74632f6825d9" kindref="member">set_up</ref>(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>num_workers)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classtf_1_1ObserverInterface_1a8225fcacb03089677a1efc4b16b734cc" kindref="member">on_entry</ref>(<ref refid="classtf_1_1WorkerView" kindref="compound">tf::WorkerView</ref><sp/>worker_view,<sp/><ref refid="classtf_1_1TaskView" kindref="compound">tf::TaskView</ref><sp/>task_view)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">virtual</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/><ref refid="classtf_1_1ObserverInterface_1aa22f5378154653f08d9a58326bda4754" kindref="member">on_exit</ref>(<ref refid="classtf_1_1WorkerView" kindref="compound">tf::WorkerView</ref><sp/>worker_view,<sp/><ref refid="classtf_1_1TaskView" kindref="compound">tf::TaskView</ref><sp/>task_view)<sp/>=<sp/>0;</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
</programlisting></para>
<para>There are three methods you must define in your derived class, <ref refid="classtf_1_1ObserverInterface_1a41e6e62f12bf9d9dc4fa74632f6825d9" kindref="member">tf::ObserverInterface::set_up</ref>, <ref refid="classtf_1_1ObserverInterface_1a8225fcacb03089677a1efc4b16b734cc" kindref="member">tf::ObserverInterface::on_entry</ref>, and <ref refid="classtf_1_1ObserverInterface_1aa22f5378154653f08d9a58326bda4754" kindref="member">tf::ObserverInterface::on_exit</ref>. The method, <ref refid="classtf_1_1ObserverInterface_1a41e6e62f12bf9d9dc4fa74632f6825d9" kindref="member">tf::ObserverInterface::set_up</ref>, is a constructor-like method that will be called by the executor when the observer is constructed. It passes an argument of the number of workers to observer in the executor. You may use it to preallocate or initialize data storage, e.g., an independent vector for each worker. The methods, <ref refid="classtf_1_1ObserverInterface_1a8225fcacb03089677a1efc4b16b734cc" kindref="member">tf::ObserverInterface::on_entry</ref> and <ref refid="classtf_1_1ObserverInterface_1aa22f5378154653f08d9a58326bda4754" kindref="member">tf::ObserverInterface::on_exit</ref>, are called by a worker thread before and after the execution context of a task, respectively. Both methods provide immutable access to the underlying worker and the running task using <ref refid="classtf_1_1WorkerView" kindref="compound">tf::WorkerView</ref> and <ref refid="classtf_1_1TaskView" kindref="compound">tf::TaskView</ref>. You may use them to record timepoints and calculate the elapsed time of a task.</para>
<para>You can associate an executor with one or multiple observers (though one is common) using tf::Executor::make_observer. We use <ref refid="cpp/memory/shared_ptr" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::shared_ptr</ref> to manage the ownership of an observer. The executor loops through each observer and invoke the corresponding methods accordingly.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="preprocessor">#include<sp/>&lt;<ref refid="taskflow_8hpp" kindref="compound">taskflow/taskflow.hpp</ref>&gt;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">MyObserver<sp/>:<sp/></highlight><highlight class="keyword">public</highlight><highlight class="normal"><sp/><ref refid="classtf_1_1ObserverInterface" kindref="compound">tf::ObserverInterface</ref><sp/>{</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MyObserver(</highlight><highlight class="keyword">const</highlight><highlight class="normal"><sp/><ref refid="cpp/string/basic_string" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::string</ref>&amp;<sp/>name)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;constructing<sp/>observer<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>name<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;\n&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>set_up(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>num_workers)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">final</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;setting<sp/>up<sp/>observer<sp/>with<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>num_workers<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>workers\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>on_entry(<ref refid="classtf_1_1WorkerView" kindref="compound">tf::WorkerView</ref><sp/>w,<sp/><ref refid="classtf_1_1TaskView" kindref="compound">tf::TaskView</ref><sp/>tv)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">final</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/basic_ostringstream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostringstream</ref><sp/>oss;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>oss<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;worker<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>w.id()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>ready<sp/>to<sp/>run<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>tv.name()<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;\n&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/>oss.str();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordtype">void</highlight><highlight class="normal"><sp/>on_exit(<ref refid="classtf_1_1WorkerView" kindref="compound">tf::WorkerView</ref><sp/>w,<sp/><ref refid="classtf_1_1TaskView" kindref="compound">tf::TaskView</ref><sp/>tv)<sp/></highlight><highlight class="keyword">override</highlight><highlight class="normal"><sp/></highlight><highlight class="keyword">final</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/basic_ostringstream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::ostringstream</ref><sp/>oss;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>oss<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;worker<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>w.id()<sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;<sp/>finished<sp/>running<sp/>&quot;</highlight><highlight class="normal"><sp/>&lt;&lt;<sp/>tv.name()<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;\n&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/>oss.str();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>main(){</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tf::Executor<sp/>executor(4);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>Create<sp/>a<sp/>taskflow<sp/>of<sp/>eight<sp/>tasks</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>A<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;1\n&quot;</highlight><highlight class="normal">;<sp/>}).name(</highlight><highlight class="stringliteral">&quot;A&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>B<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;2\n&quot;</highlight><highlight class="normal">;<sp/>}).name(</highlight><highlight class="stringliteral">&quot;B&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>C<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;3\n&quot;</highlight><highlight class="normal">;<sp/>}).name(</highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>D<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;4\n&quot;</highlight><highlight class="normal">;<sp/>}).name(</highlight><highlight class="stringliteral">&quot;D&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>E<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;5\n&quot;</highlight><highlight class="normal">;<sp/>}).name(</highlight><highlight class="stringliteral">&quot;E&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>F<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;6\n&quot;</highlight><highlight class="normal">;<sp/>}).name(</highlight><highlight class="stringliteral">&quot;F&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>G<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;7\n&quot;</highlight><highlight class="normal">;<sp/>}).name(</highlight><highlight class="stringliteral">&quot;G&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>H<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;8\n&quot;</highlight><highlight class="normal">;<sp/>}).name(</highlight><highlight class="stringliteral">&quot;H&quot;</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>an<sp/>observer</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="cpp/memory/shared_ptr" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::shared_ptr&lt;MyObserver&gt;</ref><sp/>observer<sp/>=<sp/>executor.make_observer&lt;MyObserver&gt;(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="stringliteral">&quot;MyObserver&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>run<sp/>the<sp/>taskflow</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>executor.run(taskflow).get();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>remove<sp/>the<sp/>observer<sp/>(optional)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>executor.remove_observer(std::move(observer));</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>The above code produces the following output:</para>
<para><programlisting filename=".bash"><codeline><highlight class="normal">constructing<sp/>observer<sp/>MyObserver</highlight></codeline>
<codeline><highlight class="normal">setting<sp/>up<sp/>observer<sp/>with<sp/>4<sp/>workers</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>2<sp/>ready<sp/>to<sp/>run<sp/>A</highlight></codeline>
<codeline><highlight class="normal">1</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>2<sp/>finished<sp/>running<sp/>A</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>2<sp/>ready<sp/>to<sp/>run<sp/>B</highlight></codeline>
<codeline><highlight class="normal">2</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>1<sp/>ready<sp/>to<sp/>run<sp/>C</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>2<sp/>finished<sp/>running<sp/>B</highlight></codeline>
<codeline><highlight class="normal">3</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>2<sp/>ready<sp/>to<sp/>run<sp/>D</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>3<sp/>ready<sp/>to<sp/>run<sp/>E</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>1<sp/>finished<sp/>running<sp/>C</highlight></codeline>
<codeline><highlight class="normal">4</highlight></codeline>
<codeline><highlight class="normal">5</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>1<sp/>ready<sp/>to<sp/>run<sp/>F</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>2<sp/>finished<sp/>running<sp/>D</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>3<sp/>finished<sp/>running<sp/>E</highlight></codeline>
<codeline><highlight class="normal">6</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>2<sp/>ready<sp/>to<sp/>run<sp/>G</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>3<sp/>ready<sp/>to<sp/>run<sp/>H</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>1<sp/>finished<sp/>running<sp/>F</highlight></codeline>
<codeline><highlight class="normal">7</highlight></codeline>
<codeline><highlight class="normal">8</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>2<sp/>finished<sp/>running<sp/>G</highlight></codeline>
<codeline><highlight class="normal">worker<sp/>3<sp/>finished<sp/>running<sp/>H</highlight></codeline>
</programlisting></para>
<para>It is expected each line of <ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref> interleaves with each other as there are four workers participating in task scheduling. However, the <emphasis>ready</emphasis> message always appears before the corresponding task message (e.g., numbers) and then the <emphasis>finished</emphasis> message. </para>
</sect1>
    </detaileddescription>
    <location file="cookbook/executor.dox"/>
  </compounddef>
</doxygen>
