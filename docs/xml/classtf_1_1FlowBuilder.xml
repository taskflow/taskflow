<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.14">
  <compounddef id="classtf_1_1FlowBuilder" kind="class" language="C++" prot="public">
    <compoundname>tf::FlowBuilder</compoundname>
    <derivedcompoundref refid="classtf_1_1Subflow" prot="public" virt="non-virtual">tf::Subflow</derivedcompoundref>
    <derivedcompoundref refid="classtf_1_1Taskflow" prot="public" virt="non-virtual">tf::Taskflow</derivedcompoundref>
    <includes refid="flow__builder_8hpp" local="no">flow_builder.hpp</includes>
      <sectiondef kind="friend">
      <memberdef kind="friend" id="classtf_1_1FlowBuilder_1a763b2f90bc53f92d680a635fe28e858e" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>friend class</type>
        <definition>friend class Executor</definition>
        <argsstring></argsstring>
        <name>Executor</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="23" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" bodystart="23" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classtf_1_1FlowBuilder_1a9404a57d9d37a4d49d20b686e4e5f68f" prot="protected" static="no" mutable="no">
        <type>Graph &amp;</type>
        <definition>Graph&amp; tf::FlowBuilder::_graph</definition>
        <argsstring></argsstring>
        <name>_graph</name>
        <briefdescription>
<para>associated graph object </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="726" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" bodystart="726" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a67d023d5493da1594a1d2eaea89da179" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>tf::FlowBuilder::FlowBuilder</definition>
        <argsstring>(Graph &amp;graph)</argsstring>
        <name>FlowBuilder</name>
        <param>
          <type>Graph &amp;</type>
          <declname>graph</declname>
        </param>
        <briefdescription>
<para>constructs a flow builder with a graph </para>        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="30" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" bodystart="735" bodyend="737"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1a11fc9c98eb3a0d3a9aa55598b1f4d614" kindref="member">is_static_task_v</ref>&lt; C &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::emplace</definition>
        <argsstring>(C &amp;&amp;callable)</argsstring>
        <name>emplace</name>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>creates a static task </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type constructible from std::function&lt;void()&gt;</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>callable to construct a static task</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para></simplesect>
The following example creates a static task.</para><para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>static_task<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){});</highlight></codeline>
</programlisting></para><para>Please refer to <ref refid="StaticTasking" kindref="compound">Static Tasking</ref> for details. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="52" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" bodystart="741" bodyend="745"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1a1eea7593f25ab348cfb656dbdf4e5b05" kindref="member">is_dynamic_task_v</ref>&lt; C &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::emplace</definition>
        <argsstring>(C &amp;&amp;callable)</argsstring>
        <name>emplace</name>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>creates a dynamic task </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type constructible from std::function&lt;void(tf::Subflow&amp;)&gt;</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>callable to construct a dynamic task</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para></simplesect>
The following example creates a dynamic task (<ref refid="classtf_1_1Subflow" kindref="compound">tf::Subflow</ref>) that spawns two static tasks.</para><para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>dynamic_task<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](<ref refid="classtf_1_1Subflow" kindref="compound">tf::Subflow</ref>&amp;<sp/>sf){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>static_task1<sp/>=<sp/>sf.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>static_task2<sp/>=<sp/>sf.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){});</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting></para><para>Please refer to <ref refid="DynamicTasking" kindref="compound">Dynamic Tasking</ref> for details. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="78" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1a00ca2fc2de0e679a7d9b8039340343df" kindref="member">is_condition_task_v</ref>&lt; C &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::emplace</definition>
        <argsstring>(C &amp;&amp;callable)</argsstring>
        <name>emplace</name>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>creates a condition task </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type constructible from std::function&lt;int()&gt;</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>callable to construct a condition task</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para></simplesect>
The following example creates an if-else block using one condition task and three static tasks.</para><para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>[init,<sp/>cond,<sp/>yes,<sp/>no]<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;yes\n&quot;</highlight><highlight class="normal">;<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;no\n&quot;</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>executes<sp/>yes<sp/>if<sp/>cond<sp/>returns<sp/>0,<sp/>or<sp/>no<sp/>if<sp/>cond<sp/>returns<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">cond.<ref refid="classtf_1_1Task_1a8c78c453295a553c1c016e4062da8588" kindref="member">precede</ref>(yes,<sp/>no);</highlight></codeline>
<codeline><highlight class="normal">cond.<ref refid="classtf_1_1Task_1a331b1b726555072e7c7d10941257f664" kindref="member">succeed</ref>(init);</highlight></codeline>
</programlisting></para><para>Please refer to <ref refid="ConditionalTasking" kindref="compound">Conditional Tasking</ref> for details. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="112" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1a78c40dc8776735b0f2c27cd446481aff" kindref="member">is_multi_condition_task_v</ref>&lt; C &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::emplace</definition>
        <argsstring>(C &amp;&amp;callable)</argsstring>
        <name>emplace</name>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>creates a multi-condition task </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type constructible from <ref refid="cpp/utility/functional/function" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::function</ref>&lt;tf::SmallVector&lt;int&gt;()&gt;</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>callable to construct a multi-condition task</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para></simplesect>
The following example creates a multi-condition task that selectively jumps to two successor tasks.</para><para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>[init,<sp/>cond,<sp/>branch1,<sp/>branch2,<sp/>branch3]<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="classtf_1_1SmallVector" kindref="compound">tf::SmallVector</ref>{0,<sp/>2};<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;branch1\n&quot;</highlight><highlight class="normal">;<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;branch2\n&quot;</highlight><highlight class="normal">;<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;branch3\n&quot;</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>executes<sp/>branch1<sp/>and<sp/>branch3<sp/>when<sp/>cond<sp/>returns<sp/>0<sp/>and<sp/>2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">cond.<ref refid="classtf_1_1Task_1a8c78c453295a553c1c016e4062da8588" kindref="member">precede</ref>(branch1,<sp/>branch2,<sp/>branch3);</highlight></codeline>
<codeline><highlight class="normal">cond.<ref refid="classtf_1_1Task_1a331b1b726555072e7c7d10941257f664" kindref="member">succeed</ref>(init);</highlight></codeline>
</programlisting></para><para>Please refer to <ref refid="ConditionalTasking" kindref="compound">Conditional Tasking</ref> for details. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="148" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a1f6118326ad434f6c839007a1a79fe1b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>C</declname>
            <defname>C</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt;(sizeof...(C)&gt;</type>
            <declname>1</declname>
            <defname>1</defname>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto tf::FlowBuilder::emplace</definition>
        <argsstring>(C &amp;&amp;... callables)</argsstring>
        <name>emplace</name>
        <param>
          <type>C &amp;&amp;...</type>
          <declname>callables</declname>
        </param>
        <briefdescription>
<para>creates multiple tasks from a list of callable objects </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable types</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>callables</parametername>
</parameternamelist>
<parameterdescription>
<para>one or multiple callable objects constructible from each task category</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para></simplesect>
The method returns a tuple of tasks each corresponding to the given callable target. You can use structured binding to get the return tasks one by one. The following example creates four static tasks and assign them to <computeroutput>A</computeroutput>, <computeroutput>B</computeroutput>, <computeroutput>C</computeroutput>, and <computeroutput>D</computeroutput> using structured binding.</para><para><programlisting filename=".cpp"><codeline><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>[A,<sp/>B,<sp/>C,<sp/>D]<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;A&quot;</highlight><highlight class="normal">;<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;B&quot;</highlight><highlight class="normal">;<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal">;<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;D&quot;</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="175" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" bodystart="781" bodyend="783"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a5627f7962099ac7c4986993cffa7b909" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::FlowBuilder::erase</definition>
        <argsstring>(Task task)</argsstring>
        <name>erase</name>
        <param>
          <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
          <declname>task</declname>
        </param>
        <briefdescription>
<para>removes a task from a taskflow </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>task</parametername>
</parameternamelist>
<parameterdescription>
<para>task to remove</para></parameterdescription>
</parameteritem>
</parameterlist>
Removes a task and its input and output dependencies from this graph. If the task does not belong to this graph, nothing will happen.</para><para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>A<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;A&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>B<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;B&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>C<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>D<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;D&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal">A.<ref refid="classtf_1_1Task_1a8c78c453295a553c1c016e4062da8588" kindref="member">precede</ref>(B,<sp/>C,<sp/>D);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>erase<sp/>A<sp/>from<sp/>the<sp/>taskflow<sp/>and<sp/>its<sp/>dependencies<sp/>to<sp/>B,<sp/>C,<sp/>and<sp/>D</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1a5627f7962099ac7c4986993cffa7b909" kindref="member">erase</ref>(A);</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="196" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" bodystart="786" bodyend="807"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1ac6f22228d4c2ea2e643c4b0d42c0e92a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::composed_of</definition>
        <argsstring>(T &amp;object)</argsstring>
        <name>composed_of</name>
        <param>
          <type>T &amp;</type>
          <declname>object</declname>
        </param>
        <briefdescription>
<para>creates a module task from a taskflow </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>custom object type </para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>object</parametername>
</parameternamelist>
<parameterdescription>
<para>a custom object that defines <computeroutput>T::graph()</computeroutput> method</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para></simplesect>
The example below demonstrates a taskflow composition using the <computeroutput>composed_of</computeroutput> method.</para><para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>t1,<sp/>t2;</highlight></codeline>
<codeline><highlight class="normal">t1.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;t1&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>t2<sp/>is<sp/>partially<sp/>composed<sp/>of<sp/>t1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>comp<sp/>=<sp/>t2.<ref refid="classtf_1_1FlowBuilder_1ac6f22228d4c2ea2e643c4b0d42c0e92a" kindref="member">composed_of</ref>(t1);</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>init<sp/>=<sp/>t2.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;t2&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal">init.<ref refid="classtf_1_1Task_1a8c78c453295a553c1c016e4062da8588" kindref="member">precede</ref>(comp);</highlight></codeline>
</programlisting></para><para>The taskflow object <computeroutput>t2</computeroutput> is composed of another taskflow object <computeroutput>t1</computeroutput>, preceded by another static task <computeroutput>init</computeroutput>. When taskflow <computeroutput>t2</computeroutput> is submitted to an executor, <computeroutput>init</computeroutput> will run first and then <computeroutput>comp</computeroutput> which spwans its definition in taskflow <computeroutput>t1</computeroutput>.</para><para>The target <computeroutput>object</computeroutput> being composed must define the method <computeroutput>T::graph()</computeroutput> that returns a reference to a graph object of type tf::Graph such that it can interact with the executor. For example:</para><para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>custom<sp/>struct</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">MyObj<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>tf::Graph<sp/>graph;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MyObj()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classtf_1_1FlowBuilder" kindref="compound">tf::FlowBuilder</ref><sp/>builder(graph);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>task<sp/>=<sp/>builder.emplace([](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;a<sp/>task\n&quot;</highlight><highlight class="normal">;<sp/><sp/></highlight><highlight class="comment">//<sp/>static<sp/>task</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Graph&amp;<sp/>graph()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>graph;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">MyObj<sp/>obj;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>comp<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1ac6f22228d4c2ea2e643c4b0d42c0e92a" kindref="member">composed_of</ref>(obj);</highlight></codeline>
</programlisting></para><para>Please refer to <ref refid="ComposableTasking" kindref="compound">Composable Tasking</ref> for details. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="250" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" bodystart="811" bodyend="816"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1acab0b4ac82260f47fdb36a3244ee3aaf" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::placeholder</definition>
        <argsstring>()</argsstring>
        <name>placeholder</name>
        <briefdescription>
<para>creates a placeholder task </para>        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para></simplesect>
A placeholder task maps to a node in the taskflow graph, but it does not have any callable work assigned yet. A placeholder task is different from an empty task handle that does not point to any node in a graph.</para><para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>create<sp/>a<sp/>placeholder<sp/>task<sp/>with<sp/>no<sp/>callable<sp/>target<sp/>assigned</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/><ref refid="classtf_1_1FlowBuilder_1acab0b4ac82260f47fdb36a3244ee3aaf" kindref="member">placeholder</ref><sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1acab0b4ac82260f47fdb36a3244ee3aaf" kindref="member">placeholder</ref>();<sp/></highlight></codeline>
<codeline><highlight class="normal">assert(<ref refid="classtf_1_1FlowBuilder_1acab0b4ac82260f47fdb36a3244ee3aaf" kindref="member">placeholder</ref>.<ref refid="classtf_1_1Task_1a8149edcf9ec2bfac18dd171f7a55ce06" kindref="member">empty</ref>()<sp/>==<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal"><sp/>&amp;&amp;<sp/><ref refid="classtf_1_1FlowBuilder_1acab0b4ac82260f47fdb36a3244ee3aaf" kindref="member">placeholder</ref>.<ref refid="classtf_1_1Task_1afc4ecb89dd4e4645b3ec3fb7c1bb0ec5" kindref="member">has_work</ref>()<sp/>==<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>create<sp/>an<sp/>empty<sp/>task<sp/>handle</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>task;</highlight></codeline>
<codeline><highlight class="normal">assert(task.empty()<sp/>==<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>assign<sp/>the<sp/>task<sp/>handle<sp/>to<sp/>the<sp/>placeholder<sp/>task</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">task<sp/>=<sp/><ref refid="classtf_1_1FlowBuilder_1acab0b4ac82260f47fdb36a3244ee3aaf" kindref="member">placeholder</ref>;</highlight></codeline>
<codeline><highlight class="normal">assert(task.empty()<sp/>==<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal"><sp/>&amp;&amp;<sp/>task.has_work()<sp/>==<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="276" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" bodystart="819" bodyend="822"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1adb8433555d8cdc0b3c5d95e8d51a90f0" kindref="member">is_cudaflow_task_v</ref>&lt; C &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::emplace</definition>
        <argsstring>(C &amp;&amp;callable)</argsstring>
        <name>emplace</name>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>creates a cudaFlow task on the caller&apos;s GPU device context </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type constructible from <computeroutput>std::function&lt;void(tf::cudaFlow&amp;)&gt;</computeroutput> </para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para></simplesect>
This method is equivalent to calling tf::FlowBuilder::emplace_on(callable, d) where <computeroutput>d</computeroutput> is the caller&apos;s device context. The following example creates a cudaFlow of two kernel tasks, <computeroutput>task1</computeroutput> and <computeroutput>task2</computeroutput>, where <computeroutput>task1</computeroutput> runs before <computeroutput>task2</computeroutput>.</para><para><programlisting filename=".cpp"><codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([&amp;](<ref refid="classtf_1_1cudaFlow" kindref="compound">tf::cudaFlow</ref>&amp;<sp/>cf){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>two<sp/>kernel<sp/>tasks</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1cudaTask" kindref="compound">tf::cudaTask</ref><sp/>task1<sp/>=<sp/>cf.<ref refid="classtf_1_1cudaFlow_1adb731be71bdd436dfb5e36e6213a9a17" kindref="member">kernel</ref>(grid1,<sp/>block1,<sp/>shm1,<sp/>kernel1,<sp/>args1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1cudaTask" kindref="compound">tf::cudaTask</ref><sp/>task2<sp/>=<sp/>cf.<ref refid="classtf_1_1cudaFlow_1adb731be71bdd436dfb5e36e6213a9a17" kindref="member">kernel</ref>(grid2,<sp/>block2,<sp/>shm2,<sp/>kernel2,<sp/>args2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>kernel1<sp/>runs<sp/>before<sp/>kernel2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>task1.<ref refid="classtf_1_1cudaTask_1abdd68287ec4dff4216af34d1db44d1b4" kindref="member">precede</ref>(task2);</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting></para><para>Please refer to <ref refid="GPUTaskingcudaFlow" kindref="compound">GPU Tasking (cudaFlow)</ref> and <ref refid="GPUTaskingcudaFlowCapturer" kindref="compound">GPU Tasking (cudaFlowCapturer)</ref> for details. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="307" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1afdf47fd1a358fb64f8c1b89e2a393169" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>typename D</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1adb8433555d8cdc0b3c5d95e8d51a90f0" kindref="member">is_cudaflow_task_v</ref>&lt; C &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::emplace_on</definition>
        <argsstring>(C &amp;&amp;callable, D &amp;&amp;device)</argsstring>
        <name>emplace_on</name>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <param>
          <type>D &amp;&amp;</type>
          <declname>device</declname>
        </param>
        <briefdescription>
<para>creates a cudaFlow task on the given device </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type constructible from std::function&lt;void(tf::cudaFlow&amp;)&gt; </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>D</parametername>
</parameternamelist>
<parameterdescription>
<para>device type, either <computeroutput>int</computeroutput> or <computeroutput>std::ref&lt;int&gt;</computeroutput> (stateful)</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para></simplesect>
The following example creates a cudaFlow of two kernel tasks, <computeroutput>task1</computeroutput> and <computeroutput>task2</computeroutput> on GPU <computeroutput>2</computeroutput>, where <computeroutput>task1</computeroutput> runs before <computeroutput>task2</computeroutput> </para><para><programlisting filename=".cpp"><codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1afdf47fd1a358fb64f8c1b89e2a393169" kindref="member">emplace_on</ref>([&amp;](<ref refid="classtf_1_1cudaFlow" kindref="compound">tf::cudaFlow</ref>&amp;<sp/>cf){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>two<sp/>kernel<sp/>tasks</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1cudaTask" kindref="compound">tf::cudaTask</ref><sp/>task1<sp/>=<sp/>cf.<ref refid="classtf_1_1cudaFlow_1adb731be71bdd436dfb5e36e6213a9a17" kindref="member">kernel</ref>(grid1,<sp/>block1,<sp/>shm1,<sp/>kernel1,<sp/>args1);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1cudaTask" kindref="compound">tf::cudaTask</ref><sp/>task2<sp/>=<sp/>cf.<ref refid="classtf_1_1cudaFlow_1adb731be71bdd436dfb5e36e6213a9a17" kindref="member">kernel</ref>(grid2,<sp/>block2,<sp/>shm2,<sp/>kernel2,<sp/>args2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>kernel1<sp/>runs<sp/>before<sp/>kernel2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>task1.<ref refid="classtf_1_1cudaTask_1abdd68287ec4dff4216af34d1db44d1b4" kindref="member">precede</ref>(task2);</highlight></codeline>
<codeline><highlight class="normal">},<sp/>2);</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="334" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/cuda/cuda_flow.hpp" bodystart="1664" bodyend="1674"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1a574038aaa99e0220eedca4e8ea9389cf" kindref="member">is_syclflow_task_v</ref>&lt; C &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::emplace</definition>
        <argsstring>(C &amp;&amp;callable)</argsstring>
        <name>emplace</name>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>creates a syclFlow task on the default queue </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type constructible from std::function&lt;void(tf::syclFlow&amp;)&gt;</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable that takes a referenced <ref refid="classtf_1_1syclFlow" kindref="compound">tf::syclFlow</ref> object</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para></simplesect>
The following example creates a syclFlow on the default queue to submit two kernel tasks, <computeroutput>task1</computeroutput> and <computeroutput>task2</computeroutput>, where <computeroutput>task1</computeroutput> runs before <computeroutput>task2</computeroutput>.</para><para><programlisting filename=".cpp"><codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([&amp;](<ref refid="classtf_1_1syclFlow" kindref="compound">tf::syclFlow</ref>&amp;<sp/>cf){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>two<sp/>single-thread<sp/>kernel<sp/>tasks</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1syclTask" kindref="compound">tf::syclTask</ref><sp/>task1<sp/>=<sp/>cf.<ref refid="classtf_1_1syclFlow_1a05ff6f331b6cf48e21ae7f0d6aea9094" kindref="member">single_task</ref>([](){});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1syclTask" kindref="compound">tf::syclTask</ref><sp/>task2<sp/>=<sp/>cf.<ref refid="classtf_1_1syclFlow_1a05ff6f331b6cf48e21ae7f0d6aea9094" kindref="member">single_task</ref>([](){});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>kernel1<sp/>runs<sp/>before<sp/>kernel2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>task1.<ref refid="classtf_1_1syclTask_1a92d0dd0929b9ac4e46baf4d546497389" kindref="member">precede</ref>(task2);</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="360" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1af7c878fa6f0c4539ab88c0a85e6052d8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>typename Q</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1a574038aaa99e0220eedca4e8ea9389cf" kindref="member">is_syclflow_task_v</ref>&lt; C &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::emplace_on</definition>
        <argsstring>(C &amp;&amp;callable, Q &amp;&amp;queue)</argsstring>
        <name>emplace_on</name>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <param>
          <type>Q &amp;&amp;</type>
          <declname>queue</declname>
        </param>
        <briefdescription>
<para>creates a syclFlow task on the given queue </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type constructible from std::function&lt;void(tf::syclFlow&amp;)&gt; </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Q</parametername>
</parameternamelist>
<parameterdescription>
<para>queue type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable that takes a referenced <ref refid="classtf_1_1syclFlow" kindref="compound">tf::syclFlow</ref> object </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>queue</parametername>
</parameternamelist>
<parameterdescription>
<para>a queue of type sycl::queue</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para></simplesect>
The following example creates a syclFlow on the given queue to submit two kernel tasks, <computeroutput>task1</computeroutput> and <computeroutput>task2</computeroutput>, where <computeroutput>task1</computeroutput> runs before <computeroutput>task2</computeroutput>.</para><para><programlisting filename=".cpp"><codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1afdf47fd1a358fb64f8c1b89e2a393169" kindref="member">emplace_on</ref>([&amp;](<ref refid="classtf_1_1syclFlow" kindref="compound">tf::syclFlow</ref>&amp;<sp/>cf){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>create<sp/>two<sp/>single-thread<sp/>kernel<sp/>tasks</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1syclTask" kindref="compound">tf::syclTask</ref><sp/>task1<sp/>=<sp/>cf.<ref refid="classtf_1_1syclFlow_1a05ff6f331b6cf48e21ae7f0d6aea9094" kindref="member">single_task</ref>([](){});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1syclTask" kindref="compound">tf::syclTask</ref><sp/>task2<sp/>=<sp/>cf.<ref refid="classtf_1_1syclFlow_1a05ff6f331b6cf48e21ae7f0d6aea9094" kindref="member">single_task</ref>([](){});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>kernel1<sp/>runs<sp/>before<sp/>kernel2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>task1.<ref refid="classtf_1_1syclTask_1a92d0dd0929b9ac4e46baf4d546497389" kindref="member">precede</ref>(task2);</highlight></codeline>
<codeline><highlight class="normal">},<sp/>queue);</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="390" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/sycl/sycl_flow.hpp" bodystart="780" bodyend="790"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1af3d94f0be0f7b49e195c4e92737b1f85" kindref="member">is_runtime_task_v</ref>&lt; C &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::emplace</definition>
        <argsstring>(C &amp;&amp;callable)</argsstring>
        <name>emplace</name>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>creates a runtime task </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type constructible from std::function&lt;void(tf::Runtime&amp;)&gt;</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>callable to construct a runtime task</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para></simplesect>
The following example creates a runtime task that enables in-task control over the running executor.</para><para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>runtime_task<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](tf::Runtime&amp;<sp/>rt){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keyword">auto</highlight><highlight class="normal">&amp;<sp/>executor<sp/>=<sp/>rt.executor();</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/>executor.<ref refid="classtf_1_1Executor_1a9d2d464ab2a84ecb3b3ea7747e8e276b" kindref="member">num_workers</ref>()<sp/>&lt;&lt;<sp/></highlight><highlight class="charliteral">&apos;\n&apos;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting></para><para>Please refer to RuntimeTasking for details. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="416" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a90f3d9b9d6fcf4df8e7d7878dfdd130d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::FlowBuilder::linearize</definition>
        <argsstring>(std::vector&lt; Task &gt; &amp;tasks)</argsstring>
        <name>linearize</name>
        <param>
          <type><ref refid="cpp/container/vector" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector</ref>&lt; <ref refid="classtf_1_1Task" kindref="compound">Task</ref> &gt; &amp;</type>
          <declname>tasks</declname>
        </param>
        <briefdescription>
<para>adds adjacent dependency links to a linear list of tasks </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tasks</parametername>
</parameternamelist>
<parameterdescription>
<para>a vector of tasks</para></parameterdescription>
</parameteritem>
</parameterlist>
This member function creates linear dependencies over a vector of tasks.</para><para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>A<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;A&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>B<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;B&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>C<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>D<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;D&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;tf::Task&gt;</ref><sp/>tasks<sp/>{A,<sp/>B,<sp/>C,<sp/>D}</highlight></codeline>
<codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1a90f3d9b9d6fcf4df8e7d7878dfdd130d" kindref="member">linearize</ref>(tasks);<sp/><sp/></highlight><highlight class="comment">//<sp/>A-&gt;B-&gt;C-&gt;D</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="435" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" bodystart="843" bodyend="845"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a4ec89b554d15ad5fb96f4fdb10dbbb16" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::FlowBuilder::linearize</definition>
        <argsstring>(std::initializer_list&lt; Task &gt; tasks)</argsstring>
        <name>linearize</name>
        <param>
          <type><ref refid="cpp/utility/initializer_list" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::initializer_list</ref>&lt; <ref refid="classtf_1_1Task" kindref="compound">Task</ref> &gt;</type>
          <declname>tasks</declname>
        </param>
        <briefdescription>
<para>adds adjacent dependency links to a linear list of tasks </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tasks</parametername>
</parameternamelist>
<parameterdescription>
<para>an initializer list of tasks</para></parameterdescription>
</parameteritem>
</parameterlist>
This member function creates linear dependencies over a list of tasks.</para><para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>A<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;A&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>B<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;B&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>C<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>D<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;D&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal">taskflow.<ref refid="classtf_1_1FlowBuilder_1a90f3d9b9d6fcf4df8e7d7878dfdd130d" kindref="member">linearize</ref>({A,<sp/>B,<sp/>C,<sp/>D});<sp/><sp/></highlight><highlight class="comment">//<sp/>A-&gt;B-&gt;C-&gt;D</highlight></codeline>
</programlisting> </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="452" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" bodystart="848" bodyend="850"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1ab405d7b10040530d8b04c11767b4960d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::for_each</definition>
        <argsstring>(B first, E last, C callable)</argsstring>
        <name>for_each</name>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <param>
          <type>C</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>constructs a STL-styled parallel-for task </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning (inclusive) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end (exclusive) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object to apply to the dereferenced iterator</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para></simplesect>
The task spawns a subflow that applies the callable object to each object obtained by dereferencing every iterator in the range <computeroutput>[first, last)</computeroutput>. This method is equivalent to the parallel execution of the following loop:</para><para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>itr=first;<sp/>itr!=last;<sp/>itr++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>callable(*itr);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Arguments templated to enable stateful range using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref>. The callable needs to take a single argument of the dereferenced iterator type.</para><para>Please refer to <ref refid="ParallelIterations" kindref="compound">Parallel Iterations</ref> for details. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="488" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a38ffe176bc3ae1827b9964322e3769d4" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename S</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::for_each_index</definition>
        <argsstring>(B first, E last, S step, C callable)</argsstring>
        <name>for_each_index</name>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <param>
          <type>S</type>
          <declname>step</declname>
        </param>
        <param>
          <type>C</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>constructs a parallel-transform task </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning index type (must be integral) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending index type (must be integral) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>S</parametername>
</parameternamelist>
<parameterdescription>
<para>step type (must be integral) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>index of the beginning (inclusive) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>index of the end (exclusive) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>step</parametername>
</parameternamelist>
<parameterdescription>
<para>step size </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object to apply to each valid index</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para></simplesect>
The task spawns a subflow that applies the callable object to each index in the range <computeroutput>[first, last)</computeroutput> with the step size. This method is equivalent to the parallel execution of the following loop:</para><para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>case<sp/>1:<sp/>step<sp/>size<sp/>is<sp/>positive</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>i=first;<sp/>i&lt;last;<sp/>i+=step)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>callable(i);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>case<sp/>2:<sp/>step<sp/>size<sp/>is<sp/>negative</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>i=first,<sp/>i&gt;last;<sp/>i+=step)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>callable(i);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Arguments are templated to enable stateful range using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref>. The callable needs to take a single argument of the integral index type.</para><para>Please refer to <ref refid="ParallelIterations" kindref="compound">Parallel Iterations</ref> for details. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="527" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1abd813bd7afcbd8e6f56dc67883917d1a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::transform</definition>
        <argsstring>(B first1, E last1, O d_first, C c)</argsstring>
        <name>transform</name>
        <param>
          <type>B</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>O</type>
          <declname>d_first</declname>
        </param>
        <param>
          <type>C</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>constructs a parallel-transform task </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning input iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending input iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>output iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the first range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the first range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>d_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>an unary callable to apply to dereferenced input elements</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para></simplesect>
The task spawns a subflow that applies the callable object to an input range and stores the result in another output range. This method is equivalent to the parallel execution of the following loop:</para><para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(first1<sp/>!=<sp/>last1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*d_first++<sp/>=<sp/>c(*first1++);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Arguments are templated to enable stateful range using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref>. The callable needs to take a single argument of the dereferenced iterator type. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="563" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1aa0b3271b34317710a1e32053a9abc3cf" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B1</type>
          </param>
          <param>
            <type>typename E1</type>
          </param>
          <param>
            <type>typename B2</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::transform</definition>
        <argsstring>(B1 first1, E1 last1, B2 first2, O d_first, C c)</argsstring>
        <name>transform</name>
        <param>
          <type>B1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>E1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>B2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>O</type>
          <declname>d_first</declname>
        </param>
        <param>
          <type>C</type>
          <declname>c</declname>
        </param>
        <briefdescription>
<para>constructs a parallel-transform task </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B1</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning input iterator type for the first input range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E1</parametername>
</parameternamelist>
<parameterdescription>
<para>ending input iterator type for the first input range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B2</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning input iterator type for the first second range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>output iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the first input range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the first input range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the second input range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>d_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output range </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>a binary operator to apply to dereferenced input elements</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para></simplesect>
The task spawns a subflow that applies the callable object to two input ranges and stores the result in another output range. This method is equivalent to the parallel execution of the following loop:</para><para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(first1<sp/>!=<sp/>last1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*d_first++<sp/>=<sp/>c(*first1++,<sp/>*first2++);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Arguments are templated to enable stateful range using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref>. The callable needs to take two arguments of dereferenced elements from the two input ranges. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="597" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1aa9494fe7b862fc832884ce318e8a37f5" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::reduce</definition>
        <argsstring>(B first, E last, T &amp;init, O bop)</argsstring>
        <name>reduce</name>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>O</type>
          <declname>bop</declname>
        </param>
        <briefdescription>
<para>constructs a STL-styled parallel-reduce task </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>result type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>binary reducer type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning (inclusive) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end (exclusive) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>initial value of the reduction and the storage for the reduced result </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bop</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator that will be applied</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para></simplesect>
The task spawns a subflow to perform parallel reduction over <computeroutput>init</computeroutput> and the elements in the range <computeroutput>[first, last)</computeroutput>. The reduced result is store in <computeroutput>init</computeroutput>. This method is equivalent to the parallel execution of the following loop:</para><para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>itr=first;<sp/>itr!=last;<sp/>itr++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>init<sp/>=<sp/>bop(init,<sp/>*itr);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Arguments are templated to enable stateful range using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref>.</para><para>Please refer to <ref refid="ParallelReduction" kindref="compound">Parallel Reduction</ref> for details. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="634" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a024a1e5b4f138b6caebb427411fb0a2d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename BOP</type>
          </param>
          <param>
            <type>typename UOP</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::transform_reduce</definition>
        <argsstring>(B first, E last, T &amp;init, BOP bop, UOP uop)</argsstring>
        <name>transform_reduce</name>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>BOP</type>
          <declname>bop</declname>
        </param>
        <param>
          <type>UOP</type>
          <declname>uop</declname>
        </param>
        <briefdescription>
<para>constructs a STL-styled parallel transform-reduce task </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending iterator type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>result type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BOP</parametername>
</parameternamelist>
<parameterdescription>
<para>binary reducer type </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UOP</parametername>
</parameternamelist>
<parameterdescription>
<para>unary transformion type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning (inclusive) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end (exclusive) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>initial value of the reduction and the storage for the reduced result </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bop</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator that will be applied in unspecified order to the results of <computeroutput>uop</computeroutput> </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>uop</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator that will be applied to transform each element in the range to the result type</para></parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para></simplesect>
The task spawns a subflow to perform parallel reduction over <computeroutput>init</computeroutput> and the transformed elements in the range <computeroutput>[first, last)</computeroutput>. The reduced result is store in <computeroutput>init</computeroutput>. This method is equivalent to the parallel execution of the following loop:</para><para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>itr=first;<sp/>itr!=last;<sp/>itr++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>init<sp/>=<sp/>bop(init,<sp/>uop(*itr));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para><para>Arguments are templated to enable stateful range using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref>.</para><para>Please refer to <ref refid="ParallelReduction" kindref="compound">Parallel Reduction</ref> for details. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="673" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a35e180eb63de6c9f28e43185e837a4fa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::sort</definition>
        <argsstring>(B first, E last, C cmp)</argsstring>
        <name>sort</name>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <param>
          <type>C</type>
          <declname>cmp</declname>
        </param>
        <briefdescription>
<para>constructs a dynamic task to perform STL-styled parallel sort </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning iterator type (random-accessible) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending iterator type (random-accessible) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>comparator type</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning (inclusive) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end (exclusive) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmp</parametername>
</parameternamelist>
<parameterdescription>
<para>comparison function object</para></parameterdescription>
</parameteritem>
</parameterlist>
The task spawns a subflow to parallelly sort elements in the range <computeroutput>[first, last)</computeroutput>.</para><para>Arguments are templated to enable stateful range using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref>.</para><para>Please refer to <ref refid="ParallelSort" kindref="compound">Parallel Sort</ref> for details. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="698" column="1"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a7d844e9856c7c65b26ccdb83ffdab1d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::sort</definition>
        <argsstring>(B first, E last)</argsstring>
        <name>sort</name>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>constructs a dynamic task to perform STL-styled parallel sort using the <computeroutput>std::less&lt;T&gt;</computeroutput> comparator, where <computeroutput>T</computeroutput> is the element type </para>        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning iterator type (random-accessible) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending iterator type (random-accessible)</para></parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning (inclusive) </para></parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end (exclusive)</para></parameterdescription>
</parameteritem>
</parameterlist>
The task spawns a subflow to parallelly sort elements in the range <computeroutput>[first, last)</computeroutput> using the <computeroutput>std::less&lt;T&gt;</computeroutput> comparator, where <computeroutput>T</computeroutput> is the dereferenced iterator type.</para><para>Arguments are templated to enable stateful range using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/home/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref>.</para><para>Please refer to <ref refid="ParallelSort" kindref="compound">Parallel Sort</ref> for details. </para>        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="719" column="1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a04115519f61efc42d018ea697054135d" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::FlowBuilder::_linearize</definition>
        <argsstring>(L &amp;)</argsstring>
        <name>_linearize</name>
        <param>
          <type>L &amp;</type>
          <defname>keys</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="731" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" bodystart="826" bodyend="840"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>class to build a task dependency graph </para>    </briefdescription>
    <detaileddescription>
<para>The class provides essential methods to construct a task dependency graph from which <ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref> and <ref refid="classtf_1_1Subflow" kindref="compound">tf::Subflow</ref> are derived. </para>    </detaileddescription>
    <inheritancegraph>
      <node id="101">
        <label>tf::FlowBuilder</label>
        <link refid="classtf_1_1FlowBuilder"/>
      </node>
      <node id="102">
        <label>tf::Subflow</label>
        <link refid="classtf_1_1Subflow"/>
        <childnode refid="101" relation="public-inheritance">
        </childnode>
      </node>
      <node id="103">
        <label>tf::Taskflow</label>
        <link refid="classtf_1_1Taskflow"/>
        <childnode refid="101" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <location file="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" line="21" column="1" bodyfile="/home/twhuang/Code/taskflow/taskflow/core/flow_builder.hpp" bodystart="21" bodyend="732"/>
    <listofallmembers>
      <member refid="classtf_1_1FlowBuilder_1a9404a57d9d37a4d49d20b686e4e5f68f" prot="protected" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>_graph</name></member>
      <member refid="classtf_1_1FlowBuilder_1a04115519f61efc42d018ea697054135d" prot="private" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>_linearize</name></member>
      <member refid="classtf_1_1FlowBuilder_1ac6f22228d4c2ea2e643c4b0d42c0e92a" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>composed_of</name></member>
      <member refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>emplace</name></member>
      <member refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>emplace</name></member>
      <member refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>emplace</name></member>
      <member refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>emplace</name></member>
      <member refid="classtf_1_1FlowBuilder_1a1f6118326ad434f6c839007a1a79fe1b" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>emplace</name></member>
      <member refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>emplace</name></member>
      <member refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>emplace</name></member>
      <member refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>emplace</name></member>
      <member refid="classtf_1_1FlowBuilder_1afdf47fd1a358fb64f8c1b89e2a393169" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>emplace_on</name></member>
      <member refid="classtf_1_1FlowBuilder_1af7c878fa6f0c4539ab88c0a85e6052d8" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>emplace_on</name></member>
      <member refid="classtf_1_1FlowBuilder_1a5627f7962099ac7c4986993cffa7b909" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>erase</name></member>
      <member refid="classtf_1_1FlowBuilder_1a763b2f90bc53f92d680a635fe28e858e" prot="private" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>Executor</name></member>
      <member refid="classtf_1_1FlowBuilder_1a67d023d5493da1594a1d2eaea89da179" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>FlowBuilder</name></member>
      <member refid="classtf_1_1FlowBuilder_1ab405d7b10040530d8b04c11767b4960d" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>for_each</name></member>
      <member refid="classtf_1_1FlowBuilder_1a38ffe176bc3ae1827b9964322e3769d4" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>for_each_index</name></member>
      <member refid="classtf_1_1FlowBuilder_1a90f3d9b9d6fcf4df8e7d7878dfdd130d" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>linearize</name></member>
      <member refid="classtf_1_1FlowBuilder_1a4ec89b554d15ad5fb96f4fdb10dbbb16" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>linearize</name></member>
      <member refid="classtf_1_1FlowBuilder_1acab0b4ac82260f47fdb36a3244ee3aaf" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>placeholder</name></member>
      <member refid="classtf_1_1FlowBuilder_1aa9494fe7b862fc832884ce318e8a37f5" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>reduce</name></member>
      <member refid="classtf_1_1FlowBuilder_1a35e180eb63de6c9f28e43185e837a4fa" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>sort</name></member>
      <member refid="classtf_1_1FlowBuilder_1a7d844e9856c7c65b26ccdb83ffdab1d6" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>sort</name></member>
      <member refid="classtf_1_1FlowBuilder_1abd813bd7afcbd8e6f56dc67883917d1a" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>transform</name></member>
      <member refid="classtf_1_1FlowBuilder_1aa0b3271b34317710a1e32053a9abc3cf" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>transform</name></member>
      <member refid="classtf_1_1FlowBuilder_1a024a1e5b4f138b6caebb427411fb0a2d" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>transform_reduce</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
