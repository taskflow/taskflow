<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.12.0" xml:lang="en-US">
  <compounddef id="classtf_1_1FlowBuilder" kind="class" language="C++" prot="public">
    <compoundname>tf::FlowBuilder</compoundname>
    <derivedcompoundref refid="classtf_1_1Subflow" prot="public" virt="non-virtual">tf::Subflow</derivedcompoundref>
    <derivedcompoundref refid="classtf_1_1Taskflow" prot="public" virt="non-virtual">tf::Taskflow</derivedcompoundref>
    <includes refid="flow__builder_8hpp" local="no">taskflow/core/flow_builder.hpp</includes>
    <sectiondef kind="friend">
      <memberdef kind="friend" id="classtf_1_1FlowBuilder_1a763b2f90bc53f92d680a635fe28e858e" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>class</type>
        <definition>friend class Executor</definition>
        <argsstring></argsstring>
        <name>Executor</name>
        <qualifiedname>tf::FlowBuilder::Executor</qualifiedname>
        <param>
          <type><ref refid="classtf_1_1Executor" kindref="compound">Executor</ref></type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="24" column="16" bodyfile="taskflow/core/flow_builder.hpp" bodystart="24" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="protected-attrib">
      <memberdef kind="variable" id="classtf_1_1FlowBuilder_1a9404a57d9d37a4d49d20b686e4e5f68f" prot="protected" static="no" mutable="no">
        <type><ref refid="classtf_1_1Graph" kindref="compound">Graph</ref> &amp;</type>
        <definition>Graph&amp; tf::FlowBuilder::_graph</definition>
        <argsstring></argsstring>
        <name>_graph</name>
        <qualifiedname>tf::FlowBuilder::_graph</qualifiedname>
        <briefdescription>
<para>associated graph object </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="1269" column="9" bodyfile="taskflow/core/flow_builder.hpp" bodystart="1269" bodyend="-1"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="public-func">
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a67d023d5493da1594a1d2eaea89da179" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type></type>
        <definition>tf::FlowBuilder::FlowBuilder</definition>
        <argsstring>(Graph &amp;graph)</argsstring>
        <name>FlowBuilder</name>
        <qualifiedname>tf::FlowBuilder::FlowBuilder</qualifiedname>
        <param>
          <type><ref refid="classtf_1_1Graph" kindref="compound">Graph</ref> &amp;</type>
          <declname>graph</declname>
        </param>
        <briefdescription>
<para>constructs a flow builder with a graph </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="31" column="3" bodyfile="taskflow/core/flow_builder.hpp" bodystart="1278" bodyend="1280"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1a11fc9c98eb3a0d3a9aa55598b1f4d614" kindref="member">is_static_task_v</ref>&lt; C &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::emplace</definition>
        <argsstring>(C &amp;&amp;callable)</argsstring>
        <name>emplace</name>
        <qualifiedname>tf::FlowBuilder::emplace</qualifiedname>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>creates a static task </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type constructible from <ref refid="cpp/utility/functional/function" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::function&lt;void()&gt;</ref></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>callable to construct a static task</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para>
</simplesect>
The following example creates a static task.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>static_task<sp/>=<sp/>taskflow.emplace([](){});</highlight></codeline>
</programlisting></para>
<para><simplesect kind="note"><para>Please refer to <ref refid="StaticTasking" kindref="compound">Static Tasking</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="54" column="8" bodyfile="taskflow/core/flow_builder.hpp" bodystart="1284" bodyend="1288"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1af3d94f0be0f7b49e195c4e92737b1f85" kindref="member">is_runtime_task_v</ref>&lt; C &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::emplace</definition>
        <argsstring>(C &amp;&amp;callable)</argsstring>
        <name>emplace</name>
        <qualifiedname>tf::FlowBuilder::emplace</qualifiedname>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>creates a runtime task </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type constructible from <ref refid="cpp/utility/functional/function" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::function&lt;void(tf::Runtime&amp;)&gt;</ref></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>callable to construct a runtime task</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para>
</simplesect>
The following example creates a runtime task.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>static_task<sp/>=<sp/>taskflow.emplace([](<ref refid="classtf_1_1Runtime" kindref="compound">tf::Runtime</ref>&amp;){});</highlight></codeline>
</programlisting></para>
<para><simplesect kind="note"><para>Please refer to <ref refid="RuntimeTasking" kindref="compound">Runtime Tasking</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="77" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1aefeb96086f4a99f0e58a0f321012a52c" kindref="member">is_subflow_task_v</ref>&lt; C &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::emplace</definition>
        <argsstring>(C &amp;&amp;callable)</argsstring>
        <name>emplace</name>
        <qualifiedname>tf::FlowBuilder::emplace</qualifiedname>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>creates a dynamic task </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type constructible from <ref refid="cpp/utility/functional/function" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::function&lt;void(tf::Subflow&amp;)&gt;</ref></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>callable to construct a dynamic task</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para>
</simplesect>
The following example creates a dynamic task (<ref refid="classtf_1_1Subflow" kindref="compound">tf::Subflow</ref>) that spawns two static tasks.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>dynamic_task<sp/>=<sp/>taskflow.emplace([](<ref refid="classtf_1_1Subflow" kindref="compound">tf::Subflow</ref>&amp;<sp/>sf){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>static_task1<sp/>=<sp/>sf.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>static_task2<sp/>=<sp/>sf.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){});</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting></para>
<para><simplesect kind="note"><para>Please refer to <ref refid="SubflowTasking" kindref="compound">Subflow Tasking</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="104" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1a00ca2fc2de0e679a7d9b8039340343df" kindref="member">is_condition_task_v</ref>&lt; C &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::emplace</definition>
        <argsstring>(C &amp;&amp;callable)</argsstring>
        <name>emplace</name>
        <qualifiedname>tf::FlowBuilder::emplace</qualifiedname>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>creates a condition task </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type constructible from <ref refid="cpp/utility/functional/function" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::function&lt;int()&gt;</ref></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>callable to construct a condition task</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para>
</simplesect>
The following example creates an if-else block using one condition task and three static tasks.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>[init,<sp/>cond,<sp/>yes,<sp/>no]<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>0;<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;yes\n&quot;</highlight><highlight class="normal">;<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;no\n&quot;</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>executes<sp/>yes<sp/>if<sp/>cond<sp/>returns<sp/>0,<sp/>or<sp/>no<sp/>if<sp/>cond<sp/>returns<sp/>1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">cond.<ref refid="classtf_1_1Task_1a8c78c453295a553c1c016e4062da8588" kindref="member">precede</ref>(yes,<sp/>no);</highlight></codeline>
<codeline><highlight class="normal">cond.<ref refid="classtf_1_1Task_1a331b1b726555072e7c7d10941257f664" kindref="member">succeed</ref>(init);</highlight></codeline>
</programlisting></para>
<para><simplesect kind="note"><para>Please refer to <ref refid="ConditionalTasking" kindref="compound">Conditional Tasking</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="139" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1a78c40dc8776735b0f2c27cd446481aff" kindref="member">is_multi_condition_task_v</ref>&lt; C &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::emplace</definition>
        <argsstring>(C &amp;&amp;callable)</argsstring>
        <name>emplace</name>
        <qualifiedname>tf::FlowBuilder::emplace</qualifiedname>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>creates a multi-condition task </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type constructible from <ref refid="cpp/utility/functional/function" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::function</ref>&lt;tf::SmallVector&lt;int&gt;()&gt;</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>callable to construct a multi-condition task</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para>
</simplesect>
The following example creates a multi-condition task that selectively jumps to two successor tasks.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>[init,<sp/>cond,<sp/>branch1,<sp/>branch2,<sp/>branch3]<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="classtf_1_1SmallVector" kindref="compound">tf::SmallVector</ref>{0,<sp/>2};<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;branch1\n&quot;</highlight><highlight class="normal">;<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;branch2\n&quot;</highlight><highlight class="normal">;<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;branch3\n&quot;</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>executes<sp/>branch1<sp/>and<sp/>branch3<sp/>when<sp/>cond<sp/>returns<sp/>0<sp/>and<sp/>2</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">cond.<ref refid="classtf_1_1Task_1a8c78c453295a553c1c016e4062da8588" kindref="member">precede</ref>(branch1,<sp/>branch2,<sp/>branch3);</highlight></codeline>
<codeline><highlight class="normal">cond.<ref refid="classtf_1_1Task_1a331b1b726555072e7c7d10941257f664" kindref="member">succeed</ref>(init);</highlight></codeline>
</programlisting></para>
<para><simplesect kind="note"><para>Please refer to <ref refid="ConditionalTasking" kindref="compound">Conditional Tasking</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="176" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a1f6118326ad434f6c839007a1a79fe1b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename...</type>
            <declname>C</declname>
            <defname>C</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt;(sizeof...(C)&gt;1), void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto tf::FlowBuilder::emplace</definition>
        <argsstring>(C &amp;&amp;... callables)</argsstring>
        <name>emplace</name>
        <qualifiedname>tf::FlowBuilder::emplace</qualifiedname>
        <param>
          <type>C &amp;&amp;...</type>
          <declname>callables</declname>
        </param>
        <briefdescription>
<para>creates multiple tasks from a list of callable objects </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable types</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>callables</parametername>
</parameternamelist>
<parameterdescription>
<para>one or multiple callable objects constructible from each task category</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para>
</simplesect>
The method returns a tuple of tasks each corresponding to the given callable target. You can use structured binding to get the return tasks one by one. The following example creates four static tasks and assign them to <computeroutput>A</computeroutput>, <computeroutput>B</computeroutput>, <computeroutput>C</computeroutput>, and <computeroutput>D</computeroutput> using structured binding.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>[A,<sp/>B,<sp/>C,<sp/>D]<sp/>=<sp/>taskflow.emplace(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;A&quot;</highlight><highlight class="normal">;<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;B&quot;</highlight><highlight class="normal">;<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal">;<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;D&quot;</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="203" column="8" bodyfile="taskflow/core/flow_builder.hpp" bodystart="1341" bodyend="1343"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a5627f7962099ac7c4986993cffa7b909" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::FlowBuilder::erase</definition>
        <argsstring>(Task task)</argsstring>
        <name>erase</name>
        <qualifiedname>tf::FlowBuilder::erase</qualifiedname>
        <param>
          <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
          <declname>task</declname>
        </param>
        <briefdescription>
<para>removes a task from a taskflow </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>task</parametername>
</parameternamelist>
<parameterdescription>
<para>task to remove</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Removes a task and its input and output dependencies from the graph associated with the flow builder. If the task does not belong to the graph, nothing will happen.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>A<sp/>=<sp/>taskflow.emplace([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;A&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>B<sp/>=<sp/>taskflow.emplace([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;B&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>C<sp/>=<sp/>taskflow.emplace([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>D<sp/>=<sp/>taskflow.emplace([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;D&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal">A.<ref refid="classtf_1_1Task_1a8c78c453295a553c1c016e4062da8588" kindref="member">precede</ref>(B,<sp/>C,<sp/>D);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>erase<sp/>A<sp/>from<sp/>the<sp/>taskflow<sp/>and<sp/>its<sp/>dependencies<sp/>to<sp/>B,<sp/>C,<sp/>and<sp/>D</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">taskflow.erase(A);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="225" column="8" bodyfile="taskflow/core/flow_builder.hpp" bodystart="1346" bodyend="1363"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1ac6f22228d4c2ea2e643c4b0d42c0e92a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::composed_of</definition>
        <argsstring>(T &amp;object)</argsstring>
        <name>composed_of</name>
        <qualifiedname>tf::FlowBuilder::composed_of</qualifiedname>
        <param>
          <type>T &amp;</type>
          <declname>object</declname>
        </param>
        <briefdescription>
<para>creates a module task for the target object </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>target object type </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>object</parametername>
</parameternamelist>
<parameterdescription>
<para>a custom object that defines the method <computeroutput>T::graph()</computeroutput> </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para>
</simplesect>
The example below demonstrates a taskflow composition using the <computeroutput>composed_of</computeroutput> method.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>t1,<sp/>t2;</highlight></codeline>
<codeline><highlight class="normal">t1.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;t1&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>t2<sp/>is<sp/>partially<sp/>composed<sp/>of<sp/>t1</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>comp<sp/>=<sp/>t2.<ref refid="classtf_1_1FlowBuilder_1ac6f22228d4c2ea2e643c4b0d42c0e92a" kindref="member">composed_of</ref>(t1);</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>init<sp/>=<sp/>t2.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;t2&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal">init.<ref refid="classtf_1_1Task_1a8c78c453295a553c1c016e4062da8588" kindref="member">precede</ref>(comp);</highlight></codeline>
</programlisting></para>
<para>The taskflow object <computeroutput>t2</computeroutput> is composed of another taskflow object <computeroutput>t1</computeroutput>, preceded by another static task <computeroutput>init</computeroutput>. When taskflow <computeroutput>t2</computeroutput> is submitted to an executor, <computeroutput>init</computeroutput> will run first and then <computeroutput>comp</computeroutput> which spawns its definition in taskflow <computeroutput>t1</computeroutput>.</para>
<para>The target <computeroutput>object</computeroutput> being composed must define the method <computeroutput>T::graph()</computeroutput> that returns a reference to a graph object of type <ref refid="classtf_1_1Graph" kindref="compound">tf::Graph</ref> such that it can interact with the executor. For example:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>custom<sp/>struct</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">struct<sp/></highlight><highlight class="normal">MyObj<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1Graph" kindref="compound">tf::Graph</ref><sp/>graph;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>MyObj()<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classtf_1_1FlowBuilder" kindref="compound">tf::FlowBuilder</ref><sp/>builder(graph);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>task<sp/>=<sp/>builder.emplace([](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;a<sp/>task\n&quot;</highlight><highlight class="normal">;<sp/><sp/></highlight><highlight class="comment">//<sp/>static<sp/>task</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>Graph&amp;<sp/>graph()<sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>graph;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">MyObj<sp/>obj;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>comp<sp/>=<sp/>taskflow.<ref refid="classtf_1_1Task_1ab38be520fe700cb4ca1f312308a95585" kindref="member">composed_of</ref>(obj);</highlight></codeline>
</programlisting></para>
<para><simplesect kind="note"><para>Please refer to <ref refid="ComposableTasking" kindref="compound">Composable Tasking</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="280" column="8" bodyfile="taskflow/core/flow_builder.hpp" bodystart="1324" bodyend="1329"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1acab0b4ac82260f47fdb36a3244ee3aaf" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::placeholder</definition>
        <argsstring>()</argsstring>
        <name>placeholder</name>
        <qualifiedname>tf::FlowBuilder::placeholder</qualifiedname>
        <briefdescription>
<para>creates a placeholder task </para>
        </briefdescription>
        <detaileddescription>
<para><simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para>
</simplesect>
A placeholder task maps to a node in the taskflow graph, but it does not have any callable work assigned yet. A placeholder task is different from an empty task handle that does not point to any node in a graph.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>create<sp/>a<sp/>placeholder<sp/>task<sp/>with<sp/>no<sp/>callable<sp/>target<sp/>assigned</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/><ref refid="classtf_1_1FlowBuilder_1acab0b4ac82260f47fdb36a3244ee3aaf" kindref="member">placeholder</ref><sp/>=<sp/>taskflow.placeholder();</highlight></codeline>
<codeline><highlight class="normal">assert(<ref refid="classtf_1_1FlowBuilder_1acab0b4ac82260f47fdb36a3244ee3aaf" kindref="member">placeholder</ref>.<ref refid="classtf_1_1Task_1a8149edcf9ec2bfac18dd171f7a55ce06" kindref="member">empty</ref>()<sp/>==<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal"><sp/>&amp;&amp;<sp/><ref refid="classtf_1_1FlowBuilder_1acab0b4ac82260f47fdb36a3244ee3aaf" kindref="member">placeholder</ref>.<ref refid="classtf_1_1Task_1afc4ecb89dd4e4645b3ec3fb7c1bb0ec5" kindref="member">has_work</ref>()<sp/>==<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>create<sp/>an<sp/>empty<sp/>task<sp/>handle</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>task;</highlight></codeline>
<codeline><highlight class="normal">assert(task.<ref refid="classtf_1_1Task_1a8149edcf9ec2bfac18dd171f7a55ce06" kindref="member">empty</ref>()<sp/>==<sp/></highlight><highlight class="keyword">true</highlight><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>assign<sp/>the<sp/>task<sp/>handle<sp/>to<sp/>the<sp/>placeholder<sp/>task</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">task<sp/>=<sp/><ref refid="classtf_1_1FlowBuilder_1acab0b4ac82260f47fdb36a3244ee3aaf" kindref="member">placeholder</ref>;</highlight></codeline>
<codeline><highlight class="normal">assert(task.<ref refid="classtf_1_1Task_1a8149edcf9ec2bfac18dd171f7a55ce06" kindref="member">empty</ref>()<sp/>==<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal"><sp/>&amp;&amp;<sp/>task.<ref refid="classtf_1_1Task_1afc4ecb89dd4e4645b3ec3fb7c1bb0ec5" kindref="member">has_work</ref>()<sp/>==<sp/></highlight><highlight class="keyword">false</highlight><highlight class="normal">);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="306" column="8" bodyfile="taskflow/core/flow_builder.hpp" bodystart="1332" bodyend="1337"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a90f3d9b9d6fcf4df8e7d7878dfdd130d" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::FlowBuilder::linearize</definition>
        <argsstring>(std::vector&lt; Task &gt; &amp;tasks)</argsstring>
        <name>linearize</name>
        <qualifiedname>tf::FlowBuilder::linearize</qualifiedname>
        <param>
          <type><ref refid="cpp/container/vector" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector</ref>&lt; <ref refid="classtf_1_1Task" kindref="compound">Task</ref> &gt; &amp;</type>
          <declname>tasks</declname>
        </param>
        <briefdescription>
<para>adds adjacent dependency links to a linear list of tasks </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tasks</parametername>
</parameternamelist>
<parameterdescription>
<para>a vector of tasks</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This member function creates linear dependencies over a vector of tasks.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>A<sp/>=<sp/>taskflow.emplace([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;A&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>B<sp/>=<sp/>taskflow.emplace([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;B&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>C<sp/>=<sp/>taskflow.emplace([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>D<sp/>=<sp/>taskflow.emplace([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;D&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;tf::Task&gt;</ref><sp/>tasks<sp/>{A,<sp/>B,<sp/>C,<sp/>D}</highlight></codeline>
<codeline><highlight class="normal">taskflow.linearize(tasks);<sp/><sp/></highlight><highlight class="comment">//<sp/>A-&gt;B-&gt;C-&gt;D</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="325" column="8" bodyfile="taskflow/core/flow_builder.hpp" bodystart="1385" bodyend="1387"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a4ec89b554d15ad5fb96f4fdb10dbbb16" prot="public" static="no" const="no" explicit="no" inline="yes" virt="non-virtual">
        <type>void</type>
        <definition>void tf::FlowBuilder::linearize</definition>
        <argsstring>(std::initializer_list&lt; Task &gt; tasks)</argsstring>
        <name>linearize</name>
        <qualifiedname>tf::FlowBuilder::linearize</qualifiedname>
        <param>
          <type><ref refid="cpp/utility/initializer_list" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::initializer_list</ref>&lt; <ref refid="classtf_1_1Task" kindref="compound">Task</ref> &gt;</type>
          <declname>tasks</declname>
        </param>
        <briefdescription>
<para>adds adjacent dependency links to a linear list of tasks </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>tasks</parametername>
</parameternamelist>
<parameterdescription>
<para>an initializer list of tasks</para>
</parameterdescription>
</parameteritem>
</parameterlist>
This member function creates linear dependencies over a list of tasks.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>A<sp/>=<sp/>taskflow.emplace([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;A&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>B<sp/>=<sp/>taskflow.emplace([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;B&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>C<sp/>=<sp/>taskflow.emplace([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>D<sp/>=<sp/>taskflow.emplace([](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;D&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal">taskflow.linearize({A,<sp/>B,<sp/>C,<sp/>D});<sp/><sp/></highlight><highlight class="comment">//<sp/>A-&gt;B-&gt;C-&gt;D</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="342" column="8" bodyfile="taskflow/core/flow_builder.hpp" bodystart="1390" bodyend="1392"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1aae3edfa278baa75b08414e083c14c836" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>typename P</type>
            <defval><ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">DefaultPartitioner</ref></defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::for_each</definition>
        <argsstring>(B first, E last, C callable, P part=P())</argsstring>
        <name>for_each</name>
        <qualifiedname>tf::FlowBuilder::for_each</qualifiedname>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <param>
          <type>C</type>
          <declname>callable</declname>
        </param>
        <param>
          <type>P</type>
          <declname>part</declname>
          <defval>P()</defval>
        </param>
        <briefdescription>
<para>constructs an STL-styled parallel-for task </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioner type (default <ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">tf::DefaultPartitioner</ref>)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning (inclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end (exclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object to apply to the dereferenced iterator </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>part</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioning algorithm to schedule parallel iterations</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para>
</simplesect>
The task spawns asynchronous tasks that applies the callable object to each object obtained by dereferencing every iterator in the range <computeroutput>[first, last)</computeroutput>. This method is equivalent to the parallel execution of the following loop:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>itr=first;<sp/>itr!=last;<sp/>itr++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>callable(*itr);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Iterators can be made stateful by using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref> The callable needs to take a single argument of the dereferenced iterator type.</para>
<para><simplesect kind="note"><para>Please refer to <ref refid="ParallelIterations" kindref="compound">Parallel Iterations</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="382" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a3b132bd902331a11b04b4ad66cf8bf77" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename S</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>typename P</type>
            <defval><ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">DefaultPartitioner</ref></defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::for_each_index</definition>
        <argsstring>(B first, E last, S step, C callable, P part=P())</argsstring>
        <name>for_each_index</name>
        <qualifiedname>tf::FlowBuilder::for_each_index</qualifiedname>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <param>
          <type>S</type>
          <declname>step</declname>
        </param>
        <param>
          <type>C</type>
          <declname>callable</declname>
        </param>
        <param>
          <type>P</type>
          <declname>part</declname>
          <defval>P()</defval>
        </param>
        <briefdescription>
<para>constructs an index-based parallel-for task </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning index type (must be integral) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending index type (must be integral) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>S</parametername>
</parameternamelist>
<parameterdescription>
<para>step type (must be integral) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioner type (default <ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">tf::DefaultPartitioner</ref>)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>index of the beginning (inclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>index of the end (exclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>step</parametername>
</parameternamelist>
<parameterdescription>
<para>step size </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object to apply to each valid index </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>part</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioning algorithm to schedule parallel iterations</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para>
</simplesect>
The task spawns asynchronous tasks that applies the callable object to each index in the range <computeroutput>[first, last)</computeroutput> with the step size. This method is equivalent to the parallel execution of the following loop:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>case<sp/>1:<sp/>step<sp/>size<sp/>is<sp/>positive</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>i=first;<sp/>i&lt;last;<sp/>i+=step)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>callable(i);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>case<sp/>2:<sp/>step<sp/>size<sp/>is<sp/>negative</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>i=first,<sp/>i&gt;last;<sp/>i+=step)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>callable(i);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Iterators can be made stateful by using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref> The callable needs to take a single argument of the integral index type.</para>
<para><simplesect kind="note"><para>Please refer to <ref refid="ParallelIterations" kindref="compound">Parallel Iterations</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="424" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a2582a216d54dacca2b7022ea7e89452a" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename R</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>typename P</type>
            <defval><ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">DefaultPartitioner</ref></defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::for_each_by_index</definition>
        <argsstring>(R range, C callable, P part=P())</argsstring>
        <name>for_each_by_index</name>
        <qualifiedname>tf::FlowBuilder::for_each_by_index</qualifiedname>
        <param>
          <type>R</type>
          <declname>range</declname>
        </param>
        <param>
          <type>C</type>
          <declname>callable</declname>
        </param>
        <param>
          <type>P</type>
          <declname>part</declname>
          <defval>P()</defval>
        </param>
        <briefdescription>
<para>constructs an index range-based parallel-for task </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>R</parametername>
</parameternamelist>
<parameterdescription>
<para>index range type (<ref refid="classtf_1_1IndexRange" kindref="compound">tf::IndexRange</ref>) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioner type (default <ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">tf::DefaultPartitioner</ref>)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>range</parametername>
</parameternamelist>
<parameterdescription>
<para>index range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object to apply to each valid index </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>part</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioning algorithm to schedule parallel iterations</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para>
</simplesect>
The task spawns asynchronous tasks that applies the callable object to in the range <computeroutput>[first, last)</computeroutput> with the step size.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>[0,<sp/>17)<sp/>with<sp/>a<sp/>step<sp/>size<sp/>of<sp/>2<sp/>using<sp/>tf::IndexRange</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1IndexRange" kindref="compound">tf::IndexRange&lt;int&gt;</ref><sp/>range(0,<sp/>17,<sp/>2);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>parallelize<sp/>the<sp/>sequence<sp/>[0,<sp/>2,<sp/>4,<sp/>6,<sp/>8,<sp/>10,<sp/>12,<sp/>14,<sp/>16]</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">taskflow.for_each_by_index(range,<sp/>[](<ref refid="classtf_1_1IndexRange" kindref="compound">tf::IndexRange&lt;int&gt;</ref><sp/>range)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>iterate<sp/>each<sp/>index<sp/>in<sp/>the<sp/>subrange</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i=range.<ref refid="classtf_1_1IndexRange_1a2b52381358ab392efa257e185a33d4af" kindref="member">begin</ref>();<sp/>i&lt;range.<ref refid="classtf_1_1IndexRange_1a280096cb4056bc19b86da77d019434e4" kindref="member">end</ref>();<sp/>i+=range.<ref refid="classtf_1_1IndexRange_1aafd4f2d04614e550649cd9b7912e0bf1" kindref="member">step_size</ref>())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;iterate<sp/>%d\n&quot;</highlight><highlight class="normal">,<sp/>i);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.run(taskflow).wait();</highlight></codeline>
</programlisting></para>
<para>The callable needs to take a single argument of type <ref refid="classtf_1_1IndexRange" kindref="compound">tf::IndexRange</ref>.</para>
<para><simplesect kind="note"><para>Please refer to <ref refid="ParallelIterations" kindref="compound">Parallel Iterations</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="463" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a97be7ceef6fa4276e3b074c10c13b826" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>typename P</type>
            <defval><ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">DefaultPartitioner</ref></defval>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1a73c20705fc54763f195a00b6e626e301" kindref="member">is_partitioner_v</ref>&lt; std::decay_t&lt; P &gt; &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::transform</definition>
        <argsstring>(B first1, E last1, O d_first, C c, P part=P())</argsstring>
        <name>transform</name>
        <qualifiedname>tf::FlowBuilder::transform</qualifiedname>
        <param>
          <type>B</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>O</type>
          <declname>d_first</declname>
        </param>
        <param>
          <type>C</type>
          <declname>c</declname>
        </param>
        <param>
          <type>P</type>
          <declname>part</declname>
          <defval>P()</defval>
        </param>
        <briefdescription>
<para>constructs a parallel-transform task </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning input iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending input iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>output iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioner type (default <ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">tf::DefaultPartitioner</ref>)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the first range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the first range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>d_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>an unary callable to apply to dereferenced input elements </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>part</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioning algorithm to schedule parallel iterations</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para>
</simplesect>
The task spawns asynchronous tasks that applies the callable object to an input range and stores the result in another output range. This method is equivalent to the parallel execution of the following loop:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(first1<sp/>!=<sp/>last1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*d_first++<sp/>=<sp/>c(*first1++);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Iterators can be made stateful by using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref> The callable needs to take a single argument of the dereferenced iterator type.</para>
<para><simplesect kind="note"><para>Please refer to <ref refid="ParallelTransforms" kindref="compound">Parallel Transforms</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="507" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a7ea96d3fa0aa9e3ff337a9f1e37682b0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B1</type>
          </param>
          <param>
            <type>typename E1</type>
          </param>
          <param>
            <type>typename B2</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>typename P</type>
            <defval><ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">DefaultPartitioner</ref></defval>
          </param>
          <param>
            <type>std::enable_if_t&lt;!<ref refid="namespacetf_1a73c20705fc54763f195a00b6e626e301" kindref="member">is_partitioner_v</ref>&lt; std::decay_t&lt; C &gt; &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::transform</definition>
        <argsstring>(B1 first1, E1 last1, B2 first2, O d_first, C c, P part=P())</argsstring>
        <name>transform</name>
        <qualifiedname>tf::FlowBuilder::transform</qualifiedname>
        <param>
          <type>B1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>E1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>B2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>O</type>
          <declname>d_first</declname>
        </param>
        <param>
          <type>C</type>
          <declname>c</declname>
        </param>
        <param>
          <type>P</type>
          <declname>part</declname>
          <defval>P()</defval>
        </param>
        <briefdescription>
<para>constructs a parallel-transform task </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B1</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning input iterator type for the first input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E1</parametername>
</parameternamelist>
<parameterdescription>
<para>ending input iterator type for the first input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B2</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning input iterator type for the first second range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>output iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioner type (default <ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">tf::DefaultPartitioner</ref>)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the first input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the first input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the second input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>d_first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the output range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>c</parametername>
</parameternamelist>
<parameterdescription>
<para>a binary operator to apply to dereferenced input elements </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>part</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioning algorithm to schedule parallel iterations</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para>
</simplesect>
The task spawns asynchronous tasks that applies the callable object to two input ranges and stores the result in another output range. This method is equivalent to the parallel execution of the following loop:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">while</highlight><highlight class="normal"><sp/>(first1<sp/>!=<sp/>last1)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>*d_first++<sp/>=<sp/>c(*first1++,<sp/>*first2++);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Iterators can be made stateful by using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref> The callable needs to take two arguments of dereferenced elements from the two input ranges.</para>
<para><simplesect kind="note"><para>Please refer to <ref refid="ParallelTransforms" kindref="compound">Parallel Transforms</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="549" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1afb24798ebf46e253a40b01bffb1da6a7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename O</type>
          </param>
          <param>
            <type>typename P</type>
            <defval><ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">DefaultPartitioner</ref></defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::reduce</definition>
        <argsstring>(B first, E last, T &amp;init, O bop, P part=P())</argsstring>
        <name>reduce</name>
        <qualifiedname>tf::FlowBuilder::reduce</qualifiedname>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>O</type>
          <declname>bop</declname>
        </param>
        <param>
          <type>P</type>
          <declname>part</declname>
          <defval>P()</defval>
        </param>
        <briefdescription>
<para>constructs an STL-styled parallel-reduction task </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>result type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>O</parametername>
</parameternamelist>
<parameterdescription>
<para>binary reducer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioner type (default <ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">tf::DefaultPartitioner</ref>)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning (inclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end (exclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>initial value of the reduction and the storage for the reduced result </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bop</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator that will be applied </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>part</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioning algorithm to schedule parallel iterations</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para>
</simplesect>
The task spawns asynchronous tasks to perform parallel reduction over <computeroutput>init</computeroutput> and the elements in the range <computeroutput>[first, last)</computeroutput>. The reduced result is store in <computeroutput>init</computeroutput>. This method is equivalent to the parallel execution of the following loop:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>itr=first;<sp/>itr!=last;<sp/>itr++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>init<sp/>=<sp/>bop(init,<sp/>*itr);</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Iterators can be made stateful by using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref></para>
<para><simplesect kind="note"><para>Please refer to <ref refid="ParallelReduction" kindref="compound">Parallel Reduction</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="589" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a3ea810696c4b29824d1aaef15342c825" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename R</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename L</type>
          </param>
          <param>
            <type>typename G</type>
          </param>
          <param>
            <type>typename P</type>
            <defval><ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">DefaultPartitioner</ref></defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::reduce_by_index</definition>
        <argsstring>(R range, T &amp;init, L lop, G gop, P part=P())</argsstring>
        <name>reduce_by_index</name>
        <qualifiedname>tf::FlowBuilder::reduce_by_index</qualifiedname>
        <param>
          <type>R</type>
          <declname>range</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>L</type>
          <declname>lop</declname>
        </param>
        <param>
          <type>G</type>
          <declname>gop</declname>
        </param>
        <param>
          <type>P</type>
          <declname>part</declname>
          <defval>P()</defval>
        </param>
        <briefdescription>
<para>constructs an index range-based parallel-reduction task </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>R</parametername>
</parameternamelist>
<parameterdescription>
<para>index range type (<ref refid="classtf_1_1IndexRange" kindref="compound">tf::IndexRange</ref>) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>result type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>L</parametername>
</parameternamelist>
<parameterdescription>
<para>local reducer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>G</parametername>
</parameternamelist>
<parameterdescription>
<para>global reducer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioner type (default <ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">tf::DefaultPartitioner</ref>)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>range</parametername>
</parameternamelist>
<parameterdescription>
<para>index range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>initial value of the reduction and the storage for the reduced result </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>lop</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator that will be applied locally per worker </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>gop</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator that will be applied globally among worker </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>part</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioning algorithm to schedule parallel iterations</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para>
</simplesect>
The task spawns asynchronous tasks to perform parallel reduction over a range with <computeroutput>init</computeroutput>. The reduced result is store in <computeroutput>init</computeroutput>. Unlike the iterator-based reduction, index range-based reduction is particularly useful for applications that benefit from SIMD optimizations or other range-based processing strategies.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">const</highlight><highlight class="normal"><sp/></highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>N<sp/>=<sp/>1000000;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;int&gt;</ref><sp/>data(N);<sp/><sp/></highlight><highlight class="comment">//<sp/>uninitialized<sp/>data<sp/>vector</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>res<sp/>=<sp/>1;<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>res<sp/>will<sp/>participate<sp/>in<sp/>the<sp/>reduction</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">taskflow.reduce_by_index(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="classtf_1_1IndexRange" kindref="compound">tf::IndexRange&lt;size_t&gt;</ref>(0,<sp/>N,<sp/>1),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>final<sp/>result</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>res,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>local<sp/>reducer</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[&amp;](<ref refid="classtf_1_1IndexRange" kindref="compound">tf::IndexRange&lt;size_t&gt;</ref><sp/>subrange,<sp/>std::optional&lt;int&gt;<sp/>running_total)<sp/>-&gt;<sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>residual<sp/>=<sp/>running_total<sp/>?<sp/>*running_total<sp/>:<sp/>0.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i=subrange.<ref refid="classtf_1_1IndexRange_1a2b52381358ab392efa257e185a33d4af" kindref="member">begin</ref>();<sp/>i&lt;subrange.<ref refid="classtf_1_1IndexRange_1a280096cb4056bc19b86da77d019434e4" kindref="member">end</ref>();<sp/>i+=subrange.<ref refid="classtf_1_1IndexRange_1aafd4f2d04614e550649cd9b7912e0bf1" kindref="member">step_size</ref>())<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>data[i]<sp/>=<sp/>1.0;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/>residual<sp/>+=<sp/>data[i];</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;partial<sp/>sum<sp/>=<sp/>%lf\n&quot;</highlight><highlight class="normal">,<sp/>residual);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>residual;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>global<sp/>reducer</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="cpp/utility/functional/plus" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::plus&lt;int&gt;</ref>()</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">executor.run(taskflow).wait();</highlight></codeline>
<codeline><highlight class="normal">assert(res<sp/>=<sp/>N<sp/>+<sp/>1);</highlight></codeline>
</programlisting></para>
<para>Range can be made stateful by using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref>.</para>
<para><simplesect kind="note"><para>Please refer to <ref refid="ParallelReduction" kindref="compound">Parallel Reduction</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="646" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1aa62d24438c0860e76153ffd129deba41" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename BOP</type>
          </param>
          <param>
            <type>typename UOP</type>
          </param>
          <param>
            <type>typename P</type>
            <defval><ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">DefaultPartitioner</ref></defval>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1a73c20705fc54763f195a00b6e626e301" kindref="member">is_partitioner_v</ref>&lt; std::decay_t&lt; P &gt; &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::transform_reduce</definition>
        <argsstring>(B first, E last, T &amp;init, BOP bop, UOP uop, P part=P())</argsstring>
        <name>transform_reduce</name>
        <qualifiedname>tf::FlowBuilder::transform_reduce</qualifiedname>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>BOP</type>
          <declname>bop</declname>
        </param>
        <param>
          <type>UOP</type>
          <declname>uop</declname>
        </param>
        <param>
          <type>P</type>
          <declname>part</declname>
          <defval>P()</defval>
        </param>
        <briefdescription>
<para>constructs an STL-styled parallel transform-reduce task </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>result type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BOP</parametername>
</parameternamelist>
<parameterdescription>
<para>binary reducer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UOP</parametername>
</parameternamelist>
<parameterdescription>
<para>unary transformation type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioner type (default <ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">tf::DefaultPartitioner</ref>)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning (inclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end (exclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>initial value of the reduction and the storage for the reduced result </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bop</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator that will be applied in unspecified order to the results of <computeroutput>uop</computeroutput> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>uop</parametername>
</parameternamelist>
<parameterdescription>
<para>unary operator that will be applied to transform each element in the range to the result type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>part</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioning algorithm to schedule parallel iterations</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para>
</simplesect>
The task spawns asynchronous tasks to perform parallel reduction over <computeroutput>init</computeroutput> and the transformed elements in the range <computeroutput>[first, last)</computeroutput>. The reduced result is store in <computeroutput>init</computeroutput>. This method is equivalent to the parallel execution of the following loop:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>itr=first;<sp/>itr!=last;<sp/>itr++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>init<sp/>=<sp/>bop(init,<sp/>uop(*itr));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Iterators can be made stateful by using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref></para>
<para><simplesect kind="note"><para>Please refer to <ref refid="ParallelReduction" kindref="compound">Parallel Reduction</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="691" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1adcd90e5b46299f4ccab33caf46edcbc0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B1</type>
          </param>
          <param>
            <type>typename E1</type>
          </param>
          <param>
            <type>typename B2</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename BOP_R</type>
          </param>
          <param>
            <type>typename BOP_T</type>
          </param>
          <param>
            <type>typename P</type>
            <defval><ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">DefaultPartitioner</ref></defval>
          </param>
          <param>
            <type>std::enable_if_t&lt;!<ref refid="namespacetf_1a73c20705fc54763f195a00b6e626e301" kindref="member">is_partitioner_v</ref>&lt; std::decay_t&lt; BOP_T &gt; &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::transform_reduce</definition>
        <argsstring>(B1 first1, E1 last1, B2 first2, T &amp;init, BOP_R bop_r, BOP_T bop_t, P part=P())</argsstring>
        <name>transform_reduce</name>
        <qualifiedname>tf::FlowBuilder::transform_reduce</qualifiedname>
        <param>
          <type>B1</type>
          <declname>first1</declname>
        </param>
        <param>
          <type>E1</type>
          <declname>last1</declname>
        </param>
        <param>
          <type>B2</type>
          <declname>first2</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>init</declname>
        </param>
        <param>
          <type>BOP_R</type>
          <declname>bop_r</declname>
        </param>
        <param>
          <type>BOP_T</type>
          <declname>bop_t</declname>
        </param>
        <param>
          <type>P</type>
          <declname>part</declname>
          <defval>P()</defval>
        </param>
        <briefdescription>
<para>constructs an STL-styled parallel transform-reduce task </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B1</parametername>
</parameternamelist>
<parameterdescription>
<para>first beginning iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E1</parametername>
</parameternamelist>
<parameterdescription>
<para>first ending iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>B2</parametername>
</parameternamelist>
<parameterdescription>
<para>second beginning iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>result type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BOP_R</parametername>
</parameternamelist>
<parameterdescription>
<para>binary reducer type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BOP_T</parametername>
</parameternamelist>
<parameterdescription>
<para>binary transformation type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioner type (default <ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">tf::DefaultPartitioner</ref>)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first1</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the first range (inclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last1</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end of the first range (exclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first2</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning of the second range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>initial value of the reduction and the storage for the reduced result </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bop_r</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator that will be applied in unspecified order to the results of <computeroutput>bop_t</computeroutput> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bop_t</parametername>
</parameternamelist>
<parameterdescription>
<para>binary operator that will be applied to transform each element in the range to the result type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>part</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioning algorithm to schedule parallel iterations</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref> handle</para>
</simplesect>
The task spawns asynchronous tasks to perform parallel reduction over <computeroutput>init</computeroutput> and transformed elements in the range <computeroutput>[first, last)</computeroutput>. The reduced result is store in <computeroutput>init</computeroutput>. This method is equivalent to the parallel execution of the following loop:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>itr1=first1,<sp/>itr2=first2;<sp/>itr1!=last1;<sp/>itr1++,<sp/>itr2++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>init<sp/>=<sp/>bop_r(init,<sp/>bop_t(*itr1,<sp/>*itr2));</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>Iterators can be made stateful by using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref></para>
<para><simplesect kind="note"><para>Please refer to <ref refid="ParallelReduction" kindref="compound">Parallel Reduction</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="735" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a1c2ace9290d83c2a006614a4d66ad588" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename D</type>
          </param>
          <param>
            <type>typename BOP</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::inclusive_scan</definition>
        <argsstring>(B first, E last, D d_first, BOP bop)</argsstring>
        <name>inclusive_scan</name>
        <qualifiedname>tf::FlowBuilder::inclusive_scan</qualifiedname>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <param>
          <type>D</type>
          <declname>d_first</declname>
        </param>
        <param>
          <type>BOP</type>
          <declname>bop</declname>
        </param>
        <briefdescription>
<para>creates an STL-styled parallel inclusive-scan task </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>D</parametername>
</parameternamelist>
<parameterdescription>
<para>destination iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BOP</parametername>
</parameternamelist>
<parameterdescription>
<para>summation operator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>start of input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>end of input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>d_first</parametername>
</parameternamelist>
<parameterdescription>
<para>start of output range (may be the same as input range) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bop</parametername>
</parameternamelist>
<parameterdescription>
<para>function to perform summation</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Performs the cumulative sum (aka prefix sum, aka scan) of the input range and writes the result to the output range. Each element of the output range contains the running total of all earlier elements using the given binary operator for summation.</para>
<para>This function generates an <emphasis>inclusive</emphasis> scan, meaning that the N-th element of the output range is the sum of the first N input elements, so the N-th input element is included.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;int&gt;</ref><sp/>input<sp/>=<sp/>{1,<sp/>2,<sp/>3,<sp/>4,<sp/>5};</highlight></codeline>
<codeline><highlight class="normal">taskflow.inclusive_scan(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>input.begin(),<sp/>input.end(),<sp/>input.begin(),<sp/><ref refid="cpp/utility/functional/plus" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::plus&lt;int&gt;</ref>{}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">executor.run(taskflow).wait();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>input<sp/>is<sp/>{1,<sp/>3,<sp/>6,<sp/>10,<sp/>15}</highlight></codeline>
</programlisting></para>
<para>Iterators can be made stateful by using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref></para>
<para><simplesect kind="note"><para>Please refer to <ref refid="ParallelScan" kindref="compound">Parallel Scan</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="782" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a0b589a5bbf9b18e6484fa9e554d39a39" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename D</type>
          </param>
          <param>
            <type>typename BOP</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::inclusive_scan</definition>
        <argsstring>(B first, E last, D d_first, BOP bop, T init)</argsstring>
        <name>inclusive_scan</name>
        <qualifiedname>tf::FlowBuilder::inclusive_scan</qualifiedname>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <param>
          <type>D</type>
          <declname>d_first</declname>
        </param>
        <param>
          <type>BOP</type>
          <declname>bop</declname>
        </param>
        <param>
          <type>T</type>
          <declname>init</declname>
        </param>
        <briefdescription>
<para>creates an STL-styled parallel inclusive-scan task with an initial value </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>D</parametername>
</parameternamelist>
<parameterdescription>
<para>destination iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BOP</parametername>
</parameternamelist>
<parameterdescription>
<para>summation operator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>initial value type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>start of input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>end of input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>d_first</parametername>
</parameternamelist>
<parameterdescription>
<para>start of output range (may be the same as input range) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bop</parametername>
</parameternamelist>
<parameterdescription>
<para>function to perform summation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>initial value</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Performs the cumulative sum (aka prefix sum, aka scan) of the input range and writes the result to the output range. Each element of the output range contains the running total of all earlier elements (and the initial value) using the given binary operator for summation.</para>
<para>This function generates an <emphasis>inclusive</emphasis> scan, meaning the N-th element of the output range is the sum of the first N input elements, so the N-th input element is included.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;int&gt;</ref><sp/>input<sp/>=<sp/>{1,<sp/>2,<sp/>3,<sp/>4,<sp/>5};</highlight></codeline>
<codeline><highlight class="normal">taskflow.inclusive_scan(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>input.begin(),<sp/>input.end(),<sp/>input.begin(),<sp/><ref refid="cpp/utility/functional/plus" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::plus&lt;int&gt;</ref>{},<sp/>-1</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">executor.run(taskflow).wait();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>input<sp/>is<sp/>{0,<sp/>2,<sp/>5,<sp/>9,<sp/>14}</highlight></codeline>
</programlisting></para>
<para>Iterators can be made stateful by using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref></para>
<para><simplesect kind="note"><para>Please refer to <ref refid="ParallelScan" kindref="compound">Parallel Scan</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="826" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a4e0d618d8eb0b3b2e5e00443a10bf512" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename D</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename BOP</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::exclusive_scan</definition>
        <argsstring>(B first, E last, D d_first, T init, BOP bop)</argsstring>
        <name>exclusive_scan</name>
        <qualifiedname>tf::FlowBuilder::exclusive_scan</qualifiedname>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <param>
          <type>D</type>
          <declname>d_first</declname>
        </param>
        <param>
          <type>T</type>
          <declname>init</declname>
        </param>
        <param>
          <type>BOP</type>
          <declname>bop</declname>
        </param>
        <briefdescription>
<para>creates an STL-styled parallel exclusive-scan task </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>D</parametername>
</parameternamelist>
<parameterdescription>
<para>destination iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>initial value type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BOP</parametername>
</parameternamelist>
<parameterdescription>
<para>summation operator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>start of input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>end of input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>d_first</parametername>
</parameternamelist>
<parameterdescription>
<para>start of output range (may be the same as input range) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>initial value </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bop</parametername>
</parameternamelist>
<parameterdescription>
<para>function to perform summation</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Performs the cumulative sum (aka prefix sum, aka scan) of the input range and writes the result to the output range. Each element of the output range contains the running total of all earlier elements (and the initial value) using the given binary operator for summation.</para>
<para>This function generates an <emphasis>exclusive</emphasis> scan, meaning the N-th element of the output range is the sum of the first N-1 input elements, so the N-th input element is not included.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;int&gt;</ref><sp/>input<sp/>=<sp/>{1,<sp/>2,<sp/>3,<sp/>4,<sp/>5};</highlight></codeline>
<codeline><highlight class="normal">taskflow.exclusive_scan(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>input.begin(),<sp/>input.end(),<sp/>input.begin(),<sp/>-1,<sp/><ref refid="cpp/utility/functional/plus" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::plus&lt;int&gt;</ref>{}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">executor.run(taskflow).wait();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>input<sp/>is<sp/>{-1,<sp/>0,<sp/>2,<sp/>5,<sp/>9}</highlight></codeline>
</programlisting></para>
<para>Iterators can be made stateful by using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref></para>
<para><simplesect kind="note"><para>Please refer to <ref refid="ParallelScan" kindref="compound">Parallel Scan</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="869" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a82f3c3f49a2d52cd52f6eac07a659e9c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename D</type>
          </param>
          <param>
            <type>typename BOP</type>
          </param>
          <param>
            <type>typename UOP</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::transform_inclusive_scan</definition>
        <argsstring>(B first, E last, D d_first, BOP bop, UOP uop)</argsstring>
        <name>transform_inclusive_scan</name>
        <qualifiedname>tf::FlowBuilder::transform_inclusive_scan</qualifiedname>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <param>
          <type>D</type>
          <declname>d_first</declname>
        </param>
        <param>
          <type>BOP</type>
          <declname>bop</declname>
        </param>
        <param>
          <type>UOP</type>
          <declname>uop</declname>
        </param>
        <briefdescription>
<para>creates an STL-styled parallel transform-inclusive scan task </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>D</parametername>
</parameternamelist>
<parameterdescription>
<para>destination iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BOP</parametername>
</parameternamelist>
<parameterdescription>
<para>summation operator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UOP</parametername>
</parameternamelist>
<parameterdescription>
<para>transform operator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>start of input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>end of input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>d_first</parametername>
</parameternamelist>
<parameterdescription>
<para>start of output range (may be the same as input range) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bop</parametername>
</parameternamelist>
<parameterdescription>
<para>function to perform summation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>uop</parametername>
</parameternamelist>
<parameterdescription>
<para>function to transform elements of the input range</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Write the cumulative sum (aka prefix sum, aka scan) of the input range to the output range. Each element of the output range contains the running total of all earlier elements using <computeroutput>uop</computeroutput> to transform the input elements and using <computeroutput>bop</computeroutput> for summation.</para>
<para>This function generates an <emphasis>inclusive</emphasis> scan, meaning the Nth element of the output range is the sum of the first N input elements, so the Nth input element is included.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;int&gt;</ref><sp/>input<sp/>=<sp/>{1,<sp/>2,<sp/>3,<sp/>4,<sp/>5};</highlight></codeline>
<codeline><highlight class="normal">taskflow.transform_inclusive_scan(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>input.begin(),<sp/>input.end(),<sp/>input.begin(),<sp/><ref refid="cpp/utility/functional/plus" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::plus&lt;int&gt;</ref>{},<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>item)<sp/>{<sp/>return<sp/>-item;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">executor.run(taskflow).wait();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>input<sp/>is<sp/>{-1,<sp/>-3,<sp/>-6,<sp/>-10,<sp/>-15}</highlight></codeline>
</programlisting></para>
<para>Iterators can be made stateful by using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref></para>
<para><simplesect kind="note"><para>Please refer to <ref refid="ParallelScan" kindref="compound">Parallel Scan</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="917" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a49f7e17d02c708035b9134d8c6c89f90" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename D</type>
          </param>
          <param>
            <type>typename BOP</type>
          </param>
          <param>
            <type>typename UOP</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::transform_inclusive_scan</definition>
        <argsstring>(B first, E last, D d_first, BOP bop, UOP uop, T init)</argsstring>
        <name>transform_inclusive_scan</name>
        <qualifiedname>tf::FlowBuilder::transform_inclusive_scan</qualifiedname>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <param>
          <type>D</type>
          <declname>d_first</declname>
        </param>
        <param>
          <type>BOP</type>
          <declname>bop</declname>
        </param>
        <param>
          <type>UOP</type>
          <declname>uop</declname>
        </param>
        <param>
          <type>T</type>
          <declname>init</declname>
        </param>
        <briefdescription>
<para>creates an STL-styled parallel transform-inclusive scan task </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>D</parametername>
</parameternamelist>
<parameterdescription>
<para>destination iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BOP</parametername>
</parameternamelist>
<parameterdescription>
<para>summation operator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UOP</parametername>
</parameternamelist>
<parameterdescription>
<para>transform operator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>initial value type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>start of input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>end of input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>d_first</parametername>
</parameternamelist>
<parameterdescription>
<para>start of output range (may be the same as input range) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bop</parametername>
</parameternamelist>
<parameterdescription>
<para>function to perform summation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>uop</parametername>
</parameternamelist>
<parameterdescription>
<para>function to transform elements of the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>initial value</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Write the cumulative sum (aka prefix sum, aka scan) of the input range to the output range. Each element of the output range contains the running total of all earlier elements (including an initial value) using <computeroutput>uop</computeroutput> to transform the input elements and using <computeroutput>bop</computeroutput> for summation.</para>
<para>This function generates an <emphasis>inclusive</emphasis> scan, meaning the Nth element of the output range is the sum of the first N input elements, so the Nth input element is included.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;int&gt;</ref><sp/>input<sp/>=<sp/>{1,<sp/>2,<sp/>3,<sp/>4,<sp/>5};</highlight></codeline>
<codeline><highlight class="normal">taskflow.transform_inclusive_scan(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>input.begin(),<sp/>input.end(),<sp/>input.begin(),<sp/><ref refid="cpp/utility/functional/plus" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::plus&lt;int&gt;</ref>{},<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[]<sp/>(</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>item)<sp/>{<sp/>return<sp/>-item;<sp/>},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>-1</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">executor.run(taskflow).wait();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>input<sp/>is<sp/>{-2,<sp/>-4,<sp/>-7,<sp/>-11,<sp/>-16}</highlight></codeline>
</programlisting></para>
<para>Iterators can be made stateful by using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref></para>
<para><simplesect kind="note"><para>Please refer to <ref refid="ParallelScan" kindref="compound">Parallel Scan</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="964" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a8549478ef819699b30f8daf88f04d577" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename D</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename BOP</type>
          </param>
          <param>
            <type>typename UOP</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::transform_exclusive_scan</definition>
        <argsstring>(B first, E last, D d_first, T init, BOP bop, UOP uop)</argsstring>
        <name>transform_exclusive_scan</name>
        <qualifiedname>tf::FlowBuilder::transform_exclusive_scan</qualifiedname>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <param>
          <type>D</type>
          <declname>d_first</declname>
        </param>
        <param>
          <type>T</type>
          <declname>init</declname>
        </param>
        <param>
          <type>BOP</type>
          <declname>bop</declname>
        </param>
        <param>
          <type>UOP</type>
          <declname>uop</declname>
        </param>
        <briefdescription>
<para>creates an STL-styled parallel transform-exclusive scan task </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>D</parametername>
</parameternamelist>
<parameterdescription>
<para>destination iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>BOP</parametername>
</parameternamelist>
<parameterdescription>
<para>summation operator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UOP</parametername>
</parameternamelist>
<parameterdescription>
<para>transform operator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>initial value type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>start of input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>end of input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>d_first</parametername>
</parameternamelist>
<parameterdescription>
<para>start of output range (may be the same as input range) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>bop</parametername>
</parameternamelist>
<parameterdescription>
<para>function to perform summation </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>uop</parametername>
</parameternamelist>
<parameterdescription>
<para>function to transform elements of the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>init</parametername>
</parameternamelist>
<parameterdescription>
<para>initial value</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Write the cumulative sum (aka prefix sum, aka scan) of the input range to the output range. Each element of the output range contains the running total of all earlier elements (including an initial value) using <computeroutput>uop</computeroutput> to transform the input elements and using <computeroutput>bop</computeroutput> for summation.</para>
<para>This function generates an <emphasis>exclusive</emphasis> scan, meaning the Nth element of the output range is the sum of the first N-1 input elements, so the Nth input element is not included.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;int&gt;</ref><sp/>input<sp/>=<sp/>{1,<sp/>2,<sp/>3,<sp/>4,<sp/>5};</highlight></codeline>
<codeline><highlight class="normal">taskflow.transform_exclusive_scan(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>input.begin(),<sp/>input.end(),<sp/>input.begin(),<sp/>-1,<sp/><ref refid="cpp/utility/functional/plus" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::plus&lt;int&gt;</ref>{},</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[](</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>item)<sp/>{<sp/>return<sp/>-item;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">executor.run(taskflow).wait();</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>input<sp/>is<sp/>{-1,<sp/>-2,<sp/>-4,<sp/>-7,<sp/>-11}</highlight></codeline>
</programlisting></para>
<para>Iterators can be made stateful by using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref></para>
<para><simplesect kind="note"><para>Please refer to <ref refid="ParallelScan" kindref="compound">Parallel Scan</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="1010" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a46a96f5889e6ac87b1ff8d6313b5f471" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename UOP</type>
          </param>
          <param>
            <type>typename P</type>
            <defval><ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">DefaultPartitioner</ref></defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::find_if</definition>
        <argsstring>(B first, E last, T &amp;result, UOP predicate, P part=P())</argsstring>
        <name>find_if</name>
        <qualifiedname>tf::FlowBuilder::find_if</qualifiedname>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>result</declname>
        </param>
        <param>
          <type>UOP</type>
          <declname>predicate</declname>
        </param>
        <param>
          <type>P</type>
          <declname>part</declname>
          <defval>P()</defval>
        </param>
        <briefdescription>
<para>constructs a task to perform STL-styled find-if algorithm </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UOP</parametername>
</parameternamelist>
<parameterdescription>
<para>unary predicate type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioner type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>start of the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>end of the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>result</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting iterator to the found element in the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>predicate</parametername>
</parameternamelist>
<parameterdescription>
<para>unary predicate which returns <computeroutput>true</computeroutput> for the required element </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>part</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioning algorithm (default <ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">tf::DefaultPartitioner</ref>)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Returns an iterator to the first element in the range <computeroutput>[first, last)</computeroutput> that satisfies the given criteria (or last if there is no such iterator). This method is equivalent to the parallel execution of the following loop:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">auto</highlight><highlight class="normal"><sp/><ref refid="classtf_1_1FlowBuilder_1a46a96f5889e6ac87b1ff8d6313b5f471" kindref="member">find_if</ref>(InputIt<sp/>first,<sp/>InputIt<sp/>last,<sp/>UnaryPredicate<sp/>p)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(;<sp/>first<sp/>!=<sp/>last;<sp/>++first)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(predicate(*first)){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>last;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>For example, the code below find the element that satisfies the given criteria (value plus one is equal to 23) from an input range of 10 elements:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;int&gt;</ref><sp/>input<sp/>=<sp/>{1,<sp/>6,<sp/>9,<sp/>10,<sp/>22,<sp/>5,<sp/>7,<sp/>8,<sp/>9,<sp/>11};</highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;int&gt;::iterator</ref><sp/>result;</highlight></codeline>
<codeline><highlight class="normal">taskflow.find_if(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>input.begin(),<sp/>input.end(),<sp/>[](</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i){<sp/>return<sp/>i+1<sp/>=<sp/>23;<sp/>},<sp/>result</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">executor.run(taskflow).wait();</highlight></codeline>
<codeline><highlight class="normal">assert(*result<sp/>==<sp/>22);</highlight></codeline>
</programlisting></para>
<para>Iterators can be made stateful by using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="1062" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a95fa2719fa7bbe7d171cf474ddb06726" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename UOP</type>
          </param>
          <param>
            <type>typename P</type>
            <defval><ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">DefaultPartitioner</ref></defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::find_if_not</definition>
        <argsstring>(B first, E last, T &amp;result, UOP predicate, P part=P())</argsstring>
        <name>find_if_not</name>
        <qualifiedname>tf::FlowBuilder::find_if_not</qualifiedname>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>result</declname>
        </param>
        <param>
          <type>UOP</type>
          <declname>predicate</declname>
        </param>
        <param>
          <type>P</type>
          <declname>part</declname>
          <defval>P()</defval>
        </param>
        <briefdescription>
<para>constructs a task to perform STL-styled find-if-not algorithm </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>UOP</parametername>
</parameternamelist>
<parameterdescription>
<para>unary predicate type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioner type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>start of the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>end of the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>result</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting iterator to the found element in the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>predicate</parametername>
</parameternamelist>
<parameterdescription>
<para>unary predicate which returns <computeroutput>false</computeroutput> for the required element </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>part</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioning algorithm (default <ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">tf::DefaultPartitioner</ref>)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Returns an iterator to the first element in the range <computeroutput>[first, last)</computeroutput> that satisfies the given criteria (or last if there is no such iterator). This method is equivalent to the parallel execution of the following loop:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keyword">auto</highlight><highlight class="normal"><sp/><ref refid="classtf_1_1FlowBuilder_1a46a96f5889e6ac87b1ff8d6313b5f471" kindref="member">find_if</ref>(InputIt<sp/>first,<sp/>InputIt<sp/>last,<sp/>UnaryPredicate<sp/>p)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(;<sp/>first<sp/>!=<sp/>last;<sp/>++first)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(!predicate(*first)){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>last;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
</programlisting></para>
<para>For example, the code below find the element that satisfies the given criteria (value is not equal to 1) from an input range of 10 elements:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;int&gt;</ref><sp/>input<sp/>=<sp/>{1,<sp/>1,<sp/>1,<sp/>1,<sp/>22,<sp/>1,<sp/>1,<sp/>1,<sp/>1,<sp/>1};</highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;int&gt;::iterator</ref><sp/>result;</highlight></codeline>
<codeline><highlight class="normal">taskflow.find_if_not(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>input.begin(),<sp/>input.end(),<sp/>[](</highlight><highlight class="keywordtype">int</highlight><highlight class="normal"><sp/>i){<sp/>return<sp/>i<sp/>==<sp/>1;<sp/>},<sp/>result</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">executor.run(taskflow).wait();</highlight></codeline>
<codeline><highlight class="normal">assert(*result<sp/>==<sp/>22);</highlight></codeline>
</programlisting></para>
<para>Iterators can be made stateful by using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="1110" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a6bf43eeaa81900084a472be1d36d46a6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>typename P</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::min_element</definition>
        <argsstring>(B first, E last, T &amp;result, C comp, P part)</argsstring>
        <name>min_element</name>
        <qualifiedname>tf::FlowBuilder::min_element</qualifiedname>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>result</declname>
        </param>
        <param>
          <type>C</type>
          <declname>comp</declname>
        </param>
        <param>
          <type>P</type>
          <declname>part</declname>
        </param>
        <briefdescription>
<para>constructs a task to perform STL-styled min-element algorithm </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>comparator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioner type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>start of the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>end of the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>result</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting iterator to the found element in the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para>comparison function object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>part</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioning algorithm (default <ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">tf::DefaultPartitioner</ref>)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Finds the smallest element in the <computeroutput>[first, last)</computeroutput> using the given comparison function object. The iterator to that smallest element is stored in <computeroutput>result</computeroutput>. This method is equivalent to the parallel execution of the following loop:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(first<sp/>==<sp/>last)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>last;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>smallest<sp/>=<sp/>first;</highlight></codeline>
<codeline><highlight class="normal">++first;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(;<sp/>first<sp/>!=<sp/>last;<sp/>++first)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(comp(*first,<sp/>*smallest))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>smallest<sp/>=<sp/>first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>smallest;</highlight></codeline>
</programlisting></para>
<para>For example, the code below find the smallest element from an input range of 10 elements.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;int&gt;</ref><sp/>input<sp/>=<sp/>{1,<sp/>1,<sp/>1,<sp/>1,<sp/>1,<sp/>-1,<sp/>1,<sp/>1,<sp/>1,<sp/>1};</highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;int&gt;::iterator</ref><sp/>result;</highlight></codeline>
<codeline><highlight class="normal">taskflow.min_element(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>input.begin(),<sp/>input.end(),<sp/><ref refid="cpp/utility/functional/less" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::less&lt;int&gt;</ref>(),<sp/>result</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">executor.run(taskflow).wait();</highlight></codeline>
<codeline><highlight class="normal">assert(*result<sp/>==<sp/>-1);</highlight></codeline>
</programlisting></para>
<para>Iterators can be made stateful by using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="1162" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a6be5d7f053a868647c3b9e0d9cdf6b68" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename T</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
          <param>
            <type>typename P</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::max_element</definition>
        <argsstring>(B first, E last, T &amp;result, C comp, P part)</argsstring>
        <name>max_element</name>
        <qualifiedname>tf::FlowBuilder::max_element</qualifiedname>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <param>
          <type>T &amp;</type>
          <declname>result</declname>
        </param>
        <param>
          <type>C</type>
          <declname>comp</declname>
        </param>
        <param>
          <type>P</type>
          <declname>part</declname>
        </param>
        <briefdescription>
<para>constructs a task to perform STL-styled max-element algorithm </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting iterator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>comparator type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioner type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>start of the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>end of the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>result</parametername>
</parameternamelist>
<parameterdescription>
<para>resulting iterator to the found element in the input range </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>comp</parametername>
</parameternamelist>
<parameterdescription>
<para>comparison function object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>part</parametername>
</parameternamelist>
<parameterdescription>
<para>partitioning algorithm (default <ref refid="namespacetf_1ace2c5adcd5039483eebb6dbdbb6f33e3" kindref="member">tf::DefaultPartitioner</ref>)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
Finds the largest element in the <computeroutput>[first, last)</computeroutput> using the given comparison function object. The iterator to that largest element is stored in <computeroutput>result</computeroutput>. This method is equivalent to the parallel execution of the following loop:</para>
<para><programlisting filename=".cpp"><codeline><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(first<sp/>==<sp/>last){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>last;</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>largest<sp/>=<sp/>first;</highlight></codeline>
<codeline><highlight class="normal">++first;</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal"><sp/>(;<sp/>first<sp/>!=<sp/>last;<sp/>++first)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">if</highlight><highlight class="normal"><sp/>(comp(*largest,<sp/>*first))<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>largest<sp/>=<sp/>first;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>largest;</highlight></codeline>
</programlisting></para>
<para>For example, the code below find the largest element from an input range of 10 elements.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;int&gt;</ref><sp/>input<sp/>=<sp/>{1,<sp/>1,<sp/>1,<sp/>1,<sp/>1,<sp/>2,<sp/>1,<sp/>1,<sp/>1,<sp/>1};</highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/container/vector" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector&lt;int&gt;::iterator</ref><sp/>result;</highlight></codeline>
<codeline><highlight class="normal">taskflow.max_element(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>input.begin(),<sp/>input.end(),<sp/><ref refid="cpp/utility/functional/less" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::less&lt;int&gt;</ref>(),<sp/>result</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">executor.run(taskflow).wait();</highlight></codeline>
<codeline><highlight class="normal">assert(*result<sp/>==<sp/>2);</highlight></codeline>
</programlisting></para>
<para>Iterators can be made stateful by using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="1214" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a35e180eb63de6c9f28e43185e837a4fa" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::sort</definition>
        <argsstring>(B first, E last, C cmp)</argsstring>
        <name>sort</name>
        <qualifiedname>tf::FlowBuilder::sort</qualifiedname>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <param>
          <type>C</type>
          <declname>cmp</declname>
        </param>
        <briefdescription>
<para>constructs a dynamic task to perform STL-styled parallel sort </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning iterator type (random-accessible) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending iterator type (random-accessible) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>C</parametername>
</parameternamelist>
<parameterdescription>
<para>comparator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning (inclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end (exclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>cmp</parametername>
</parameternamelist>
<parameterdescription>
<para>comparison operator</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The task spawns asynchronous tasks to sort elements in the range <computeroutput>[first, last)</computeroutput> in parallel.</para>
<para>Iterators can be made stateful by using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref></para>
<para><simplesect kind="note"><para>Please refer to <ref refid="ParallelSort" kindref="compound">Parallel Sort</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="1240" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a7d844e9856c7c65b26ccdb83ffdab1d6" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename B</type>
          </param>
          <param>
            <type>typename E</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Task" kindref="compound">Task</ref></type>
        <definition>Task tf::FlowBuilder::sort</definition>
        <argsstring>(B first, E last)</argsstring>
        <name>sort</name>
        <qualifiedname>tf::FlowBuilder::sort</qualifiedname>
        <param>
          <type>B</type>
          <declname>first</declname>
        </param>
        <param>
          <type>E</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>constructs a dynamic task to perform STL-styled parallel sort using the <computeroutput>std::less&lt;T&gt;</computeroutput> comparator, where <computeroutput>T</computeroutput> is the element type </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>B</parametername>
</parameternamelist>
<parameterdescription>
<para>beginning iterator type (random-accessible) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>E</parametername>
</parameternamelist>
<parameterdescription>
<para>ending iterator type (random-accessible)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning (inclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end (exclusive)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The task spawns asynchronous tasks to parallel sort elements in the range <computeroutput>[first, last)</computeroutput> using the <computeroutput>std::less&lt;T&gt;</computeroutput> comparator, where <computeroutput>T</computeroutput> is the dereferenced iterator type.</para>
<para>Iterators can be made stateful by using <ref refid="cpp/utility/functional/reference_wrapper" kindref="compound" external="/Users/twhuang/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::reference_wrapper</ref></para>
<para><simplesect kind="note"><para>Please refer to <ref refid="ParallelSort" kindref="compound">Parallel Sort</ref> for details. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="1262" column="8"/>
      </memberdef>
    </sectiondef>
    <sectiondef kind="private-func">
      <memberdef kind="function" id="classtf_1_1FlowBuilder_1a04115519f61efc42d018ea697054135d" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename L</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::FlowBuilder::_linearize</definition>
        <argsstring>(L &amp;)</argsstring>
        <name>_linearize</name>
        <qualifiedname>tf::FlowBuilder::_linearize</qualifiedname>
        <param>
          <type>L &amp;</type>
          <defname>keys</defname>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/flow_builder.hpp" line="1274" column="8" bodyfile="taskflow/core/flow_builder.hpp" bodystart="1368" bodyend="1382"/>
      </memberdef>
    </sectiondef>
    <briefdescription>
<para>class to build a task dependency graph </para>
    </briefdescription>
    <detaileddescription>
<para>The class provides essential methods to construct a task dependency graph from which <ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref> and <ref refid="classtf_1_1Subflow" kindref="compound">tf::Subflow</ref> are derived. </para>
    </detaileddescription>
    <inheritancegraph>
      <node id="1">
        <label>tf::FlowBuilder</label>
        <link refid="classtf_1_1FlowBuilder"/>
      </node>
      <node id="2">
        <label>tf::Subflow</label>
        <link refid="classtf_1_1Subflow"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
      <node id="3">
        <label>tf::Taskflow</label>
        <link refid="classtf_1_1Taskflow"/>
        <childnode refid="1" relation="public-inheritance">
        </childnode>
      </node>
    </inheritancegraph>
    <collaborationgraph>
      <node id="3">
        <label>std::vector&lt; std::unique_ptr&lt; Node &gt; &gt;</label>
      </node>
      <node id="1">
        <label>tf::FlowBuilder</label>
        <link refid="classtf_1_1FlowBuilder"/>
        <childnode refid="2" relation="usage">
          <edgelabel>_graph</edgelabel>
        </childnode>
      </node>
      <node id="2">
        <label>tf::Graph</label>
        <link refid="classtf_1_1Graph"/>
        <childnode refid="3" relation="public-inheritance">
        </childnode>
      </node>
    </collaborationgraph>
    <location file="taskflow/core/flow_builder.hpp" line="22" column="1" bodyfile="taskflow/core/flow_builder.hpp" bodystart="22" bodyend="1275"/>
    <listofallmembers>
      <member refid="classtf_1_1FlowBuilder_1a9404a57d9d37a4d49d20b686e4e5f68f" prot="protected" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>_graph</name></member>
      <member refid="classtf_1_1FlowBuilder_1a04115519f61efc42d018ea697054135d" prot="private" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>_linearize</name></member>
      <member refid="classtf_1_1FlowBuilder_1ac6f22228d4c2ea2e643c4b0d42c0e92a" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>composed_of</name></member>
      <member refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>emplace</name></member>
      <member refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>emplace</name></member>
      <member refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>emplace</name></member>
      <member refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>emplace</name></member>
      <member refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>emplace</name></member>
      <member refid="classtf_1_1FlowBuilder_1a1f6118326ad434f6c839007a1a79fe1b" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>emplace</name></member>
      <member refid="classtf_1_1FlowBuilder_1a5627f7962099ac7c4986993cffa7b909" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>erase</name></member>
      <member refid="classtf_1_1FlowBuilder_1a4e0d618d8eb0b3b2e5e00443a10bf512" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>exclusive_scan</name></member>
      <member refid="classtf_1_1FlowBuilder_1a763b2f90bc53f92d680a635fe28e858e" prot="private" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>Executor</name></member>
      <member refid="classtf_1_1FlowBuilder_1a46a96f5889e6ac87b1ff8d6313b5f471" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>find_if</name></member>
      <member refid="classtf_1_1FlowBuilder_1a95fa2719fa7bbe7d171cf474ddb06726" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>find_if_not</name></member>
      <member refid="classtf_1_1FlowBuilder_1a67d023d5493da1594a1d2eaea89da179" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>FlowBuilder</name></member>
      <member refid="classtf_1_1FlowBuilder_1aae3edfa278baa75b08414e083c14c836" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>for_each</name></member>
      <member refid="classtf_1_1FlowBuilder_1a2582a216d54dacca2b7022ea7e89452a" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>for_each_by_index</name></member>
      <member refid="classtf_1_1FlowBuilder_1a3b132bd902331a11b04b4ad66cf8bf77" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>for_each_index</name></member>
      <member refid="classtf_1_1FlowBuilder_1a1c2ace9290d83c2a006614a4d66ad588" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>inclusive_scan</name></member>
      <member refid="classtf_1_1FlowBuilder_1a0b589a5bbf9b18e6484fa9e554d39a39" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>inclusive_scan</name></member>
      <member refid="classtf_1_1FlowBuilder_1a90f3d9b9d6fcf4df8e7d7878dfdd130d" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>linearize</name></member>
      <member refid="classtf_1_1FlowBuilder_1a4ec89b554d15ad5fb96f4fdb10dbbb16" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>linearize</name></member>
      <member refid="classtf_1_1FlowBuilder_1a6be5d7f053a868647c3b9e0d9cdf6b68" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>max_element</name></member>
      <member refid="classtf_1_1FlowBuilder_1a6bf43eeaa81900084a472be1d36d46a6" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>min_element</name></member>
      <member refid="classtf_1_1FlowBuilder_1acab0b4ac82260f47fdb36a3244ee3aaf" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>placeholder</name></member>
      <member refid="classtf_1_1FlowBuilder_1afb24798ebf46e253a40b01bffb1da6a7" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>reduce</name></member>
      <member refid="classtf_1_1FlowBuilder_1a3ea810696c4b29824d1aaef15342c825" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>reduce_by_index</name></member>
      <member refid="classtf_1_1FlowBuilder_1a35e180eb63de6c9f28e43185e837a4fa" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>sort</name></member>
      <member refid="classtf_1_1FlowBuilder_1a7d844e9856c7c65b26ccdb83ffdab1d6" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>sort</name></member>
      <member refid="classtf_1_1FlowBuilder_1a97be7ceef6fa4276e3b074c10c13b826" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>transform</name></member>
      <member refid="classtf_1_1FlowBuilder_1a7ea96d3fa0aa9e3ff337a9f1e37682b0" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>transform</name></member>
      <member refid="classtf_1_1FlowBuilder_1a8549478ef819699b30f8daf88f04d577" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>transform_exclusive_scan</name></member>
      <member refid="classtf_1_1FlowBuilder_1a82f3c3f49a2d52cd52f6eac07a659e9c" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>transform_inclusive_scan</name></member>
      <member refid="classtf_1_1FlowBuilder_1a49f7e17d02c708035b9134d8c6c89f90" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>transform_inclusive_scan</name></member>
      <member refid="classtf_1_1FlowBuilder_1aa62d24438c0860e76153ffd129deba41" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>transform_reduce</name></member>
      <member refid="classtf_1_1FlowBuilder_1adcd90e5b46299f4ccab33caf46edcbc0" prot="public" virt="non-virtual"><scope>tf::FlowBuilder</scope><name>transform_reduce</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
