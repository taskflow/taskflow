<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.9.1" xml:lang="en-US">
  <compounddef id="classtf_1_1Executor" kind="class" language="C++" prot="public">
    <compoundname>tf::Executor</compoundname>
    <includes refid="executor_8hpp" local="no">taskflow/core/executor.hpp</includes>
      <sectiondef kind="friend">
      <memberdef kind="friend" id="classtf_1_1Executor_1a61184f9bd9c801d0a5eccecfdbddc641" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>class</type>
        <definition>friend class FlowBuilder</definition>
        <argsstring></argsstring>
        <name>FlowBuilder</name>
        <param>
          <type><ref refid="classtf_1_1FlowBuilder" kindref="compound">FlowBuilder</ref></type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="55" column="3" bodyfile="taskflow/core/executor.hpp" bodystart="55" bodyend="-1"/>
      </memberdef>
      <memberdef kind="friend" id="classtf_1_1Executor_1aa48945297ede77a161defc88033ce8a6" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>class</type>
        <definition>friend class Subflow</definition>
        <argsstring></argsstring>
        <name>Subflow</name>
        <param>
          <type><ref refid="classtf_1_1Subflow" kindref="compound">Subflow</ref></type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="56" column="3" bodyfile="taskflow/core/executor.hpp" bodystart="56" bodyend="-1"/>
      </memberdef>
      <memberdef kind="friend" id="classtf_1_1Executor_1af3d14e26ba8af9e6cc5a32aad8446de7" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>class</type>
        <definition>friend class Runtime</definition>
        <argsstring></argsstring>
        <name>Runtime</name>
        <param>
          <type><ref refid="classtf_1_1Runtime" kindref="compound">Runtime</ref></type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="57" column="3" bodyfile="taskflow/core/executor.hpp" bodystart="57" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-attrib">
      <memberdef kind="variable" id="classtf_1_1Executor_1ac4a4632561a52d00a02d91296b20cb5a" prot="private" static="no" mutable="no">
        <type>const size_t</type>
        <definition>const size_t tf::Executor::_MAX_STEALS</definition>
        <argsstring></argsstring>
        <name>_MAX_STEALS</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1038" column="16" bodyfile="taskflow/core/executor.hpp" bodystart="1038" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtf_1_1Executor_1aef4cf993dbd8efa0372cdea6b0f725d7" prot="private" static="no" mutable="no">
        <type><ref refid="cpp/thread/mutex" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::mutex</ref></type>
        <definition>std::mutex tf::Executor::_taskflows_mutex</definition>
        <argsstring></argsstring>
        <name>_taskflows_mutex</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1041" column="14" bodyfile="taskflow/core/executor.hpp" bodystart="1041" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtf_1_1Executor_1a3b5e7cf6749feded228a46e9fbfdef5f" prot="private" static="no" mutable="no">
        <type><ref refid="cpp/container/vector" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector</ref>&lt; <ref refid="cpp/thread/thread" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::thread</ref> &gt;</type>
        <definition>std::vector&lt;std::thread&gt; tf::Executor::_threads</definition>
        <argsstring></argsstring>
        <name>_threads</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1043" column="15" bodyfile="taskflow/core/executor.hpp" bodystart="1043" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtf_1_1Executor_1ad93162f032d463cc845fbca4fc0d960e" prot="private" static="no" mutable="no">
        <type><ref refid="cpp/container/vector" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::vector</ref>&lt; <ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &gt;</type>
        <definition>std::vector&lt;Worker&gt; tf::Executor::_workers</definition>
        <argsstring></argsstring>
        <name>_workers</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1044" column="15" bodyfile="taskflow/core/executor.hpp" bodystart="1044" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtf_1_1Executor_1ab36f7f886f9a6a9ad67ce919ca39d688" prot="private" static="no" mutable="no">
        <type>DefaultNotifier</type>
        <definition>DefaultNotifier tf::Executor::_notifier</definition>
        <argsstring></argsstring>
        <name>_notifier</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1045" column="19" bodyfile="taskflow/core/executor.hpp" bodystart="1045" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtf_1_1Executor_1a321f9b72162b9f5d4ba46d829af985cc" prot="private" static="no" mutable="no">
        <type>Latch</type>
        <definition>Latch tf::Executor::_latch</definition>
        <argsstring></argsstring>
        <name>_latch</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1050" column="9" bodyfile="taskflow/core/executor.hpp" bodystart="1050" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtf_1_1Executor_1a94357ea08db1859178f855b0b926b3de" prot="private" static="no" mutable="no">
        <type><ref refid="cpp/thread/condition_variable" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::condition_variable</ref></type>
        <definition>std::condition_variable tf::Executor::_topology_cv</definition>
        <argsstring></argsstring>
        <name>_topology_cv</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1057" column="27" bodyfile="taskflow/core/executor.hpp" bodystart="1057" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtf_1_1Executor_1a8be5571fa0df99784aacb26b01d0f4b4" prot="private" static="no" mutable="no">
        <type><ref refid="cpp/thread/mutex" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::mutex</ref></type>
        <definition>std::mutex tf::Executor::_topology_mutex</definition>
        <argsstring></argsstring>
        <name>_topology_mutex</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1058" column="14" bodyfile="taskflow/core/executor.hpp" bodystart="1058" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtf_1_1Executor_1a9e38edfbc967dd3f5ca6f7a115f95ed7" prot="private" static="no" mutable="no">
        <type>size_t</type>
        <definition>size_t tf::Executor::_num_topologies</definition>
        <argsstring></argsstring>
        <name>_num_topologies</name>
        <initializer>{0}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1059" column="10" bodyfile="taskflow/core/executor.hpp" bodystart="1059" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtf_1_1Executor_1a500d540a170f1da6e5247168bc6efa87" prot="private" static="no" mutable="no">
        <type><ref refid="cpp/atomic/atomic" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::atomic</ref>&lt; bool &gt;</type>
        <definition>std::atomic&lt;bool&gt; tf::Executor::_done</definition>
        <argsstring></argsstring>
        <name>_done</name>
        <initializer>{0}</initializer>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1060" column="15" bodyfile="taskflow/core/executor.hpp" bodystart="1060" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtf_1_1Executor_1a63090414fbad15f5934838d21aa0a28f" prot="private" static="no" mutable="no">
        <type><ref refid="cpp/container/list" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::list</ref>&lt; <ref refid="classtf_1_1Taskflow" kindref="compound">Taskflow</ref> &gt;</type>
        <definition>std::list&lt;Taskflow&gt; tf::Executor::_taskflows</definition>
        <argsstring></argsstring>
        <name>_taskflows</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1064" column="13" bodyfile="taskflow/core/executor.hpp" bodystart="1064" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtf_1_1Executor_1a0f74eb32b801b30164e36936204c4b66" prot="private" static="no" mutable="no">
        <type>Freelist&lt; Node * &gt;</type>
        <definition>Freelist&lt;Node*&gt; tf::Executor::_freelist</definition>
        <argsstring></argsstring>
        <name>_freelist</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1067" column="12" bodyfile="taskflow/core/executor.hpp" bodystart="1067" bodyend="-1"/>
      </memberdef>
      <memberdef kind="variable" id="classtf_1_1Executor_1ad7f083460df992b1186f83ac99481a57" prot="private" static="no" mutable="no">
        <type><ref refid="cpp/container/unordered_set" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::unordered_set</ref>&lt; <ref refid="cpp/memory/shared_ptr" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::shared_ptr</ref>&lt; <ref refid="classtf_1_1ObserverInterface" kindref="compound">ObserverInterface</ref> &gt; &gt;</type>
        <definition>std::unordered_set&lt;std::shared_ptr&lt;ObserverInterface&gt; &gt; tf::Executor::_observers</definition>
        <argsstring></argsstring>
        <name>_observers</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1069" column="22" bodyfile="taskflow/core/executor.hpp" bodystart="1069" bodyend="-1"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="public-func">
      <memberdef kind="function" id="classtf_1_1Executor_1a4910e89d89146b6d563d598b795eb4a9" prot="public" static="no" const="no" explicit="yes" inline="no" virt="non-virtual">
        <type></type>
        <definition>tf::Executor::Executor</definition>
        <argsstring>(size_t N=std::thread::hardware_concurrency())</argsstring>
        <name>Executor</name>
        <param>
          <type>size_t</type>
          <declname>N</declname>
          <defval><ref refid="cpp/thread/thread/hardware_concurrency" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::thread::hardware_concurrency</ref>()</defval>
        </param>
        <briefdescription>
<para>constructs the executor with <computeroutput>N</computeroutput> worker threads </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>the number of workers (default <ref refid="cpp/thread/thread/hardware_concurrency" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::thread::hardware_concurrency</ref>)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The constructor spawns <computeroutput>N</computeroutput> worker threads to run tasks in a work-stealing loop. The number of workers must be greater than zero or an exception will be thrown. By default, the number of worker threads is equal to the maximum hardware concurrency returned by <ref refid="cpp/thread/thread/hardware_concurrency" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::thread::hardware_concurrency</ref>. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="72" column="12"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a5a511b0cc23b264826373d3dabcef670" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type></type>
        <definition>tf::Executor::~Executor</definition>
        <argsstring>()</argsstring>
        <name>~Executor</name>
        <briefdescription>
<para>destructs the executor </para>
        </briefdescription>
        <detaileddescription>
<para>The destructor calls <ref refid="classtf_1_1Executor_1ab9aa252f70e9a40020a1e5a89d485b85" kindref="member">Executor::wait_for_all</ref> to wait for all submitted taskflows to complete and then notifies all worker threads to stop and join these threads. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="81" column="3"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref>&lt; void &gt;</type>
        <definition>tf::Future&lt;void&gt; tf::Executor::run</definition>
        <argsstring>(Taskflow &amp;taskflow)</argsstring>
        <name>run</name>
        <param>
          <type><ref refid="classtf_1_1Taskflow" kindref="compound">Taskflow</ref> &amp;</type>
          <declname>taskflow</declname>
        </param>
        <briefdescription>
<para>runs a taskflow once </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>taskflow</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref> object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> that holds the result of the execution</para>
</simplesect>
This member function executes the given taskflow once and returns a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> object that eventually holds the result of the execution.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Future" kindref="compound">tf::Future&lt;void&gt;</ref><sp/>future<sp/>=<sp/>executor.run(taskflow);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>do<sp/>something<sp/>else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">future.wait();</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe.</para>
<para><simplesect kind="attention"><para>The executor does not own the given taskflow. It is your responsibility to ensure the taskflow remains alive during its execution. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="105" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a4b97752c00b788918cb8396fbb1b3ad0" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref>&lt; void &gt;</type>
        <definition>tf::Future&lt;void&gt; tf::Executor::run</definition>
        <argsstring>(Taskflow &amp;&amp;taskflow)</argsstring>
        <name>run</name>
        <param>
          <type><ref refid="classtf_1_1Taskflow" kindref="compound">Taskflow</ref> &amp;&amp;</type>
          <declname>taskflow</declname>
        </param>
        <briefdescription>
<para>runs a moved taskflow once </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>taskflow</parametername>
</parameternamelist>
<parameterdescription>
<para>a moved <ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref> object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> that holds the result of the execution</para>
</simplesect>
This member function executes a moved taskflow once and returns a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> object that eventually holds the result of the execution. The executor will take care of the lifetime of the moved taskflow.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Future" kindref="compound">tf::Future&lt;void&gt;</ref><sp/>future<sp/>=<sp/>executor.run(std::move(taskflow));</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>do<sp/>something<sp/>else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">future.wait();</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="126" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a5a480ed24a6fd1e4152db69c0c5e2f89" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref>&lt; void &gt;</type>
        <definition>tf::Future&lt;void&gt; tf::Executor::run</definition>
        <argsstring>(Taskflow &amp;taskflow, C &amp;&amp;callable)</argsstring>
        <name>run</name>
        <param>
          <type><ref refid="classtf_1_1Taskflow" kindref="compound">Taskflow</ref> &amp;</type>
          <declname>taskflow</declname>
        </param>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>runs a taskflow once and invoke a callback upon completion </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>taskflow</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref> object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object to be invoked after this run</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> that holds the result of the execution</para>
</simplesect>
This member function executes the given taskflow once and invokes the given callable when the execution completes. This member function returns a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> object that eventually holds the result of the execution.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Future" kindref="compound">tf::Future&lt;void&gt;</ref><sp/>future<sp/>=<sp/>executor.run(taskflow,<sp/>[](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;done&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>do<sp/>something<sp/>else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">future.wait();</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe.</para>
<para><simplesect kind="attention"><para>The executor does not own the given taskflow. It is your responsibility to ensure the taskflow remains alive during its execution. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="154" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a2d0dc32d81100202168e42ac1d3dd8f9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref>&lt; void &gt;</type>
        <definition>tf::Future&lt;void&gt; tf::Executor::run</definition>
        <argsstring>(Taskflow &amp;&amp;taskflow, C &amp;&amp;callable)</argsstring>
        <name>run</name>
        <param>
          <type><ref refid="classtf_1_1Taskflow" kindref="compound">Taskflow</ref> &amp;&amp;</type>
          <declname>taskflow</declname>
        </param>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>runs a moved taskflow once and invoke a callback upon completion </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>taskflow</parametername>
</parameternamelist>
<parameterdescription>
<para>a moved <ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref> object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object to be invoked after this run</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> that holds the result of the execution</para>
</simplesect>
This member function executes a moved taskflow once and invokes the given callable when the execution completes. This member function returns a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> object that eventually holds the result of the execution. The executor will take care of the lifetime of the moved taskflow.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Future" kindref="compound">tf::Future&lt;void&gt;</ref><sp/>future<sp/>=<sp/>executor.run(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::move(taskflow),<sp/>[](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;done&quot;</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>do<sp/>something<sp/>else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">future.wait();</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="181" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1af15db5f7dde8e7ff1f86ef8fe825e9e2" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref>&lt; void &gt;</type>
        <definition>tf::Future&lt;void&gt; tf::Executor::run_n</definition>
        <argsstring>(Taskflow &amp;taskflow, size_t N)</argsstring>
        <name>run_n</name>
        <param>
          <type><ref refid="classtf_1_1Taskflow" kindref="compound">Taskflow</ref> &amp;</type>
          <declname>taskflow</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>runs a taskflow for <computeroutput>N</computeroutput> times </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>taskflow</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref> object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>number of runs</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> that holds the result of the execution</para>
</simplesect>
This member function executes the given taskflow <computeroutput>N</computeroutput> times and returns a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> object that eventually holds the result of the execution.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Future" kindref="compound">tf::Future&lt;void&gt;</ref><sp/>future<sp/>=<sp/>executor.run_n(taskflow,<sp/>2);<sp/><sp/></highlight><highlight class="comment">//<sp/>run<sp/>taskflow<sp/>2<sp/>times</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>do<sp/>something<sp/>else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">future.wait();</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe.</para>
<para><simplesect kind="attention"><para>The executor does not own the given taskflow. It is your responsibility to ensure the taskflow remains alive during its execution. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="206" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a04aa012598622e807dba3272aa464d7e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type><ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref>&lt; void &gt;</type>
        <definition>tf::Future&lt;void&gt; tf::Executor::run_n</definition>
        <argsstring>(Taskflow &amp;&amp;taskflow, size_t N)</argsstring>
        <name>run_n</name>
        <param>
          <type><ref refid="classtf_1_1Taskflow" kindref="compound">Taskflow</ref> &amp;&amp;</type>
          <declname>taskflow</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>N</declname>
        </param>
        <briefdescription>
<para>runs a moved taskflow for <computeroutput>N</computeroutput> times </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>taskflow</parametername>
</parameternamelist>
<parameterdescription>
<para>a moved <ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref> object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>number of runs</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> that holds the result of the execution</para>
</simplesect>
This member function executes a moved taskflow <computeroutput>N</computeroutput> times and returns a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> object that eventually holds the result of the execution. The executor will take care of the lifetime of the moved taskflow.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Future" kindref="compound">tf::Future&lt;void&gt;</ref><sp/>future<sp/>=<sp/>executor.run_n(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::move(taskflow),<sp/>2<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>run<sp/>the<sp/>moved<sp/>taskflow<sp/>2<sp/>times</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>do<sp/>something<sp/>else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">future.wait();</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="230" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a37af2ca2a97f0188fb2c4868d6f322ba" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref>&lt; void &gt;</type>
        <definition>tf::Future&lt;void&gt; tf::Executor::run_n</definition>
        <argsstring>(Taskflow &amp;taskflow, size_t N, C &amp;&amp;callable)</argsstring>
        <name>run_n</name>
        <param>
          <type><ref refid="classtf_1_1Taskflow" kindref="compound">Taskflow</ref> &amp;</type>
          <declname>taskflow</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>N</declname>
        </param>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>runs a taskflow for <computeroutput>N</computeroutput> times and then invokes a callback </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>taskflow</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>number of runs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object to be invoked after this run</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> that holds the result of the execution</para>
</simplesect>
This member function executes the given taskflow <computeroutput>N</computeroutput> times and invokes the given callable when the execution completes. This member function returns a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> object that eventually holds the result of the execution.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Future" kindref="compound">tf::Future&lt;void&gt;</ref><sp/>future<sp/>=<sp/>executor.run(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>taskflow,<sp/>2,<sp/>[](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;done&quot;</highlight><highlight class="normal">;<sp/>}<sp/><sp/></highlight><highlight class="comment">//<sp/>runs<sp/>taskflow<sp/>2<sp/>times<sp/>and<sp/>invoke</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>the<sp/>lambda<sp/>to<sp/>print<sp/>&quot;done&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>do<sp/>something<sp/>else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">future.wait();</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe.</para>
<para><simplesect kind="attention"><para>The executor does not own the given taskflow. It is your responsibility to ensure the taskflow remains alive during its execution. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="262" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1ae5c5c6a1c1f6d4740414c86daa6a3901" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref>&lt; void &gt;</type>
        <definition>tf::Future&lt;void&gt; tf::Executor::run_n</definition>
        <argsstring>(Taskflow &amp;&amp;taskflow, size_t N, C &amp;&amp;callable)</argsstring>
        <name>run_n</name>
        <param>
          <type><ref refid="classtf_1_1Taskflow" kindref="compound">Taskflow</ref> &amp;&amp;</type>
          <declname>taskflow</declname>
        </param>
        <param>
          <type>size_t</type>
          <declname>N</declname>
        </param>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>runs a moved taskflow for <computeroutput>N</computeroutput> times and then invokes a callback </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>taskflow</parametername>
</parameternamelist>
<parameterdescription>
<para>a moved <ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>N</parametername>
</parameternamelist>
<parameterdescription>
<para>number of runs </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object to be invoked after this run</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> that holds the result of the execution</para>
</simplesect>
This member function executes a moved taskflow <computeroutput>N</computeroutput> times and invokes the given callable when the execution completes. This member function returns a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> object that eventually holds the result of the execution.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Future" kindref="compound">tf::Future&lt;void&gt;</ref><sp/>future<sp/>=<sp/>executor.run_n(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="comment">//<sp/>run<sp/>the<sp/>moved<sp/>taskflow<sp/>2<sp/>times<sp/>and<sp/>invoke<sp/>the<sp/>lambda<sp/>to<sp/>print<sp/>&quot;done&quot;</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::move(taskflow),<sp/>2,<sp/>[](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;done&quot;</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>do<sp/>something<sp/>else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">future.wait();</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="290" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1ae4f9e214ea5ee873e8d90a70bc1c77e8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref>&lt; void &gt;</type>
        <definition>tf::Future&lt;void&gt; tf::Executor::run_until</definition>
        <argsstring>(Taskflow &amp;taskflow, P &amp;&amp;pred)</argsstring>
        <name>run_until</name>
        <param>
          <type><ref refid="classtf_1_1Taskflow" kindref="compound">Taskflow</ref> &amp;</type>
          <declname>taskflow</declname>
        </param>
        <param>
          <type>P &amp;&amp;</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>runs a taskflow multiple times until the predicate becomes true </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>taskflow</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>a boolean predicate to return <computeroutput>true</computeroutput> for stop</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> that holds the result of the execution</para>
</simplesect>
This member function executes the given taskflow multiple times until the predicate returns <computeroutput>true</computeroutput>. This member function returns a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> object that eventually holds the result of the execution.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Future" kindref="compound">tf::Future&lt;void&gt;</ref><sp/>future<sp/>=<sp/>executor.run_until(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>taskflow,<sp/>[](){<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="cpp/numeric/random/rand" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">rand</ref>()%10<sp/>==<sp/>0<sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>do<sp/>something<sp/>else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">future.wait();</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe.</para>
<para><simplesect kind="attention"><para>The executor does not own the given taskflow. It is your responsibility to ensure the taskflow remains alive during its execution. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="320" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a724d188df2952f64c1f2c60555a0a611" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref>&lt; void &gt;</type>
        <definition>tf::Future&lt;void&gt; tf::Executor::run_until</definition>
        <argsstring>(Taskflow &amp;&amp;taskflow, P &amp;&amp;pred)</argsstring>
        <name>run_until</name>
        <param>
          <type><ref refid="classtf_1_1Taskflow" kindref="compound">Taskflow</ref> &amp;&amp;</type>
          <declname>taskflow</declname>
        </param>
        <param>
          <type>P &amp;&amp;</type>
          <declname>pred</declname>
        </param>
        <briefdescription>
<para>runs a moved taskflow and keeps running it until the predicate becomes true </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>taskflow</parametername>
</parameternamelist>
<parameterdescription>
<para>a moved <ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref> object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>a boolean predicate to return <computeroutput>true</computeroutput> for stop</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> that holds the result of the execution</para>
</simplesect>
This member function executes a moved taskflow multiple times until the predicate returns <computeroutput>true</computeroutput>. This member function returns a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> object that eventually holds the result of the execution. The executor will take care of the lifetime of the moved taskflow.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Future" kindref="compound">tf::Future&lt;void&gt;</ref><sp/>future<sp/>=<sp/>executor.run_until(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::move(taskflow),<sp/>[](){<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="cpp/numeric/random/rand" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">rand</ref>()%10<sp/>==<sp/>0<sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>do<sp/>something<sp/>else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">future.wait();</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="348" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a5ed30b8db88cdeb78fe3e8e2de4a84dd" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref>&lt; void &gt;</type>
        <definition>tf::Future&lt;void&gt; tf::Executor::run_until</definition>
        <argsstring>(Taskflow &amp;taskflow, P &amp;&amp;pred, C &amp;&amp;callable)</argsstring>
        <name>run_until</name>
        <param>
          <type><ref refid="classtf_1_1Taskflow" kindref="compound">Taskflow</ref> &amp;</type>
          <declname>taskflow</declname>
        </param>
        <param>
          <type>P &amp;&amp;</type>
          <declname>pred</declname>
        </param>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>runs a taskflow multiple times until the predicate becomes true and then invokes the callback </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>taskflow</parametername>
</parameternamelist>
<parameterdescription>
<para>a <ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>a boolean predicate to return <computeroutput>true</computeroutput> for stop </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object to be invoked after this run completes</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> that holds the result of the execution</para>
</simplesect>
This member function executes the given taskflow multiple times until the predicate returns <computeroutput>true</computeroutput> and then invokes the given callable when the execution completes. This member function returns a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> object that eventually holds the result of the execution.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Future" kindref="compound">tf::Future&lt;void&gt;</ref><sp/>future<sp/>=<sp/>executor.run_until(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>taskflow,<sp/>[](){<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="cpp/numeric/random/rand" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">rand</ref>()%10<sp/>==<sp/>0<sp/>},<sp/>[](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;done&quot;</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>do<sp/>something<sp/>else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">future.wait();</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe.</para>
<para><simplesect kind="attention"><para>The executor does not own the given taskflow. It is your responsibility to ensure the taskflow remains alive during its execution. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="381" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1ad7aa69f06309b9226a4046f8c400144e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename C</type>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref>&lt; void &gt;</type>
        <definition>tf::Future&lt;void&gt; tf::Executor::run_until</definition>
        <argsstring>(Taskflow &amp;&amp;taskflow, P &amp;&amp;pred, C &amp;&amp;callable)</argsstring>
        <name>run_until</name>
        <param>
          <type><ref refid="classtf_1_1Taskflow" kindref="compound">Taskflow</ref> &amp;&amp;</type>
          <declname>taskflow</declname>
        </param>
        <param>
          <type>P &amp;&amp;</type>
          <declname>pred</declname>
        </param>
        <param>
          <type>C &amp;&amp;</type>
          <declname>callable</declname>
        </param>
        <briefdescription>
<para>runs a moved taskflow and keeps running it until the predicate becomes true and then invokes the callback </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>taskflow</parametername>
</parameternamelist>
<parameterdescription>
<para>a moved <ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>pred</parametername>
</parameternamelist>
<parameterdescription>
<para>a boolean predicate to return <computeroutput>true</computeroutput> for stop </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>callable</parametername>
</parameternamelist>
<parameterdescription>
<para>a callable object to be invoked after this run completes</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> that holds the result of the execution</para>
</simplesect>
This member function executes a moved taskflow multiple times until the predicate returns <computeroutput>true</computeroutput> and then invokes the given callable when the execution completes. This member function returns a <ref refid="classtf_1_1Future" kindref="compound">tf::Future</ref> object that eventually holds the result of the execution. The executor will take care of the lifetime of the moved taskflow.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Future" kindref="compound">tf::Future&lt;void&gt;</ref><sp/>future<sp/>=<sp/>executor.run_until(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>std::move(taskflow),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[](){<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/><ref refid="cpp/numeric/random/rand" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">rand</ref>()%10<sp/>==<sp/>0<sp/>},<sp/>[](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;done&quot;</highlight><highlight class="normal">;<sp/>}</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>do<sp/>something<sp/>else</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">future.wait();</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="412" column="14"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a8fcd9e0557922bb8194999f0cd433ea8" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename T</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::Executor::corun</definition>
        <argsstring>(T &amp;target)</argsstring>
        <name>corun</name>
        <param>
          <type>T &amp;</type>
          <declname>target</declname>
        </param>
        <briefdescription>
<para>runs a target graph and waits until it completes using an internal worker of this executor </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>T</parametername>
</parameternamelist>
<parameterdescription>
<para>target type which has <computeroutput><ref refid="classtf_1_1Graph" kindref="compound">tf::Graph</ref>&amp; T::graph()</computeroutput> defined </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>target</parametername>
</parameternamelist>
<parameterdescription>
<para>the target task graph object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The method runs a target graph which has <computeroutput><ref refid="classtf_1_1Graph" kindref="compound">tf::Graph</ref>&amp; T::graph()</computeroutput> defined and waits until the execution completes. Unlike the typical flow of calling <computeroutput><ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">tf::Executor::run</ref></computeroutput> series plus waiting on the result, this method must be called by an internal worker of this executor. The caller worker will participate in the work-stealing loop of the scheduler, thereby avoiding potential deadlock caused by blocked waiting.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/>executor(2);</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/container/array" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::array&lt;tf::Taskflow, 1000&gt;</ref><sp/>others;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/atomic/atomic" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::atomic&lt;size_t&gt;</ref><sp/>counter{0};</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>n=0;<sp/>n&lt;1000;<sp/>n++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">for</highlight><highlight class="normal">(</highlight><highlight class="keywordtype">size_t</highlight><highlight class="normal"><sp/>i=0;<sp/>i&lt;1000;<sp/>i++)<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>others[n].emplace([&amp;](){<sp/>counter++;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>}</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([&amp;executor,<sp/>&amp;<ref refid="namespacetf" kindref="compound">tf</ref>=others[n]](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/>executor.corun(<ref refid="namespacetf" kindref="compound">tf</ref>);</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//executor.run(tf).wait();<sp/><sp/>&lt;-<sp/>blocking<sp/>the<sp/>worker<sp/>without<sp/>doing<sp/>anything</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/>will<sp/>introduce<sp/>deadlock</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal">}</highlight></codeline>
<codeline><highlight class="normal">executor.run(taskflow).wait();</highlight></codeline>
</programlisting></para>
<para>The method is thread-safe as long as the target is not concurrently ran by two or more threads.</para>
<para><simplesect kind="attention"><para>You must call <ref refid="classtf_1_1Executor_1a8fcd9e0557922bb8194999f0cd433ea8" kindref="member">tf::Executor::corun</ref> from a worker of the calling executor or an exception will be thrown. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="457" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a0fc6eb19f168dc4a9cd0a7c6187c1d2d" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::Executor::corun_until</definition>
        <argsstring>(P &amp;&amp;predicate)</argsstring>
        <name>corun_until</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>predicate</declname>
        </param>
        <briefdescription>
<para>keeps running the work-stealing loop until the predicate becomes true </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>predicate type </para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>predicate</parametername>
</parameternamelist>
<parameterdescription>
<para>a boolean predicate to indicate when to stop the loop</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The method keeps the caller worker running in the work-stealing loop until the stop predicate becomes true.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">taskflow.emplace([&amp;](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="cpp/thread/future" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::future&lt;void&gt;</ref><sp/>fu<sp/>=<sp/><ref refid="cpp/thread/async" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::async</ref>([](){<sp/>std::sleep(100s);<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>executor.corun_until([](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>fu.wait_for(<ref refid="cpp/chrono/duration" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::chrono::seconds</ref>(0))<sp/>==<sp/>future_status::ready;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>});</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
</programlisting></para>
<para><simplesect kind="attention"><para>You must call <ref refid="classtf_1_1Executor_1a0fc6eb19f168dc4a9cd0a7c6187c1d2d" kindref="member">tf::Executor::corun_until</ref> from a worker of the calling executor or an exception will be thrown. </para>
</simplesect>
</para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="482" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1ab9aa252f70e9a40020a1e5a89d485b85" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::wait_for_all</definition>
        <argsstring>()</argsstring>
        <name>wait_for_all</name>
        <briefdescription>
<para>waits for all tasks to complete </para>
        </briefdescription>
        <detaileddescription>
<para>This member function waits until all submitted tasks (e.g., taskflows, asynchronous tasks) to finish.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">executor.run(taskflow1);</highlight></codeline>
<codeline><highlight class="normal">executor.run_n(taskflow2,<sp/>10);</highlight></codeline>
<codeline><highlight class="normal">executor.run_n(taskflow3,<sp/>100);</highlight></codeline>
<codeline><highlight class="normal">executor.wait_for_all();<sp/><sp/></highlight><highlight class="comment">//<sp/>wait<sp/>until<sp/>the<sp/>above<sp/>submitted<sp/>taskflows<sp/>finish</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="497" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a9d2d464ab2a84ecb3b3ea7747e8e276b" prot="public" static="no" const="yes" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::Executor::num_workers</definition>
        <argsstring>() const noexcept</argsstring>
        <name>num_workers</name>
        <briefdescription>
<para>queries the number of worker threads </para>
        </briefdescription>
        <detaileddescription>
<para>Each worker represents one unique thread spawned by an executor upon its construction time.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/>executor(4);</highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/>executor.num_workers();<sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>4</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="510" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a6d6c28ed58211e4c27a99571e5bf0b6c" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::Executor::num_topologies</definition>
        <argsstring>() const</argsstring>
        <name>num_topologies</name>
        <briefdescription>
<para>queries the number of running topologies at the time of this call </para>
        </briefdescription>
        <detaileddescription>
<para>When a taskflow is submitted to an executor, a topology is created to store runtime metadata of the running taskflow. When the execution of the submitted taskflow finishes, its corresponding topology will be removed from the executor.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">executor.run(taskflow);</highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/>executor.num_topologies();<sp/><sp/></highlight><highlight class="comment">//<sp/>0<sp/>or<sp/>1<sp/>(taskflow<sp/>still<sp/>running)</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="525" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a5fb438dc0f7b9e1ae2fe3f240c82f174" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::Executor::num_taskflows</definition>
        <argsstring>() const</argsstring>
        <name>num_taskflows</name>
        <briefdescription>
<para>queries the number of running taskflows with moved ownership </para>
        </briefdescription>
        <detaileddescription>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">executor.run(std::move(taskflow));</highlight></codeline>
<codeline><highlight class="normal"><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/>executor.num_taskflows();<sp/><sp/></highlight><highlight class="comment">//<sp/>0<sp/>or<sp/>1<sp/>(taskflow<sp/>still<sp/>running)</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="535" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a6487d589cb1f6b078b69fd3bb1082345" prot="public" static="no" const="yes" explicit="no" inline="no" virt="non-virtual">
        <type>int</type>
        <definition>int tf::Executor::this_worker_id</definition>
        <argsstring>() const</argsstring>
        <name>this_worker_id</name>
        <briefdescription>
<para>queries the id of the caller thread within this executor </para>
        </briefdescription>
        <detaileddescription>
<para>Each worker has an unique id in the range of <computeroutput>0</computeroutput> to <computeroutput>N-1</computeroutput> associated with its parent executor. If the caller thread does not belong to the executor, <computeroutput>-1</computeroutput> is returned.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/>executor(4);<sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>4<sp/>workers<sp/>in<sp/>the<sp/>executor</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.this_worker_id();<sp/><sp/></highlight><highlight class="comment">//<sp/>-1<sp/>(main<sp/>thread<sp/>is<sp/>not<sp/>a<sp/>worker)</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">taskflow.emplace([&amp;](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/>executor.this_worker_id();<sp/><sp/></highlight><highlight class="comment">//<sp/>0,<sp/>1,<sp/>2,<sp/>or<sp/>3</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
<codeline><highlight class="normal">executor.run(taskflow);</highlight></codeline>
</programlisting> </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="554" column="7"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1ab5a793a0f2ce41cd49ca45e9f0a6962c" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Observer</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>ArgsT</declname>
            <defname>ArgsT</defname>
          </param>
        </templateparamlist>
        <type><ref refid="cpp/memory/shared_ptr" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::shared_ptr</ref>&lt; Observer &gt;</type>
        <definition>std::shared_ptr&lt;Observer&gt; tf::Executor::make_observer</definition>
        <argsstring>(ArgsT &amp;&amp;... args)</argsstring>
        <name>make_observer</name>
        <param>
          <type>ArgsT &amp;&amp;...</type>
          <declname>args</declname>
        </param>
        <briefdescription>
<para>constructs an observer to inspect the activities of worker threads </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>Observer</parametername>
</parameternamelist>
<parameterdescription>
<para>observer type derived from <ref refid="classtf_1_1ObserverInterface" kindref="compound">tf::ObserverInterface</ref> </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>ArgsT</parametername>
</parameternamelist>
<parameterdescription>
<para>argument parameter pack</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>args</parametername>
</parameternamelist>
<parameterdescription>
<para>arguments to forward to the constructor of the observer</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a shared pointer to the created observer</para>
</simplesect>
Each executor manages a list of observers with shared ownership with callers. For each of these observers, the two member functions, <ref refid="classtf_1_1ObserverInterface_1a8225fcacb03089677a1efc4b16b734cc" kindref="member">tf::ObserverInterface::on_entry</ref> and <ref refid="classtf_1_1ObserverInterface_1aa22f5378154653f08d9a58326bda4754" kindref="member">tf::ObserverInterface::on_exit</ref> will be called before and after the execution of a task.</para>
<para>This member function is not thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="578" column="19"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a31081f492c376f7b798de0e430534531" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename Observer</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::Executor::remove_observer</definition>
        <argsstring>(std::shared_ptr&lt; Observer &gt; observer)</argsstring>
        <name>remove_observer</name>
        <param>
          <type><ref refid="cpp/memory/shared_ptr" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::shared_ptr</ref>&lt; Observer &gt;</type>
          <declname>observer</declname>
        </param>
        <briefdescription>
<para>removes an observer from the executor </para>
        </briefdescription>
        <detaileddescription>
<para>This member function is not thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="586" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1affec621aae59d73fc188ef454008fda2" prot="public" static="no" const="yes" explicit="no" inline="no" noexcept="yes" virt="non-virtual">
        <type>size_t</type>
        <definition>size_t tf::Executor::num_observers</definition>
        <argsstring>() const noexcept</argsstring>
        <name>num_observers</name>
        <briefdescription>
<para>queries the number of observers </para>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="591" column="10"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1af960048056f7c6b5bc71f4f526f05df7" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto tf::Executor::async</definition>
        <argsstring>(P &amp;&amp;params, F &amp;&amp;func)</argsstring>
        <name>async</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>params</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <briefdescription>
<para>creates a parameterized asynchronous task to run the given function </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>task parameter type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>params</parametername>
</parameternamelist>
<parameterdescription>
<para>task parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> that will hold the result of the execution</para>
</simplesect>
The method creates a parameterized asynchronous task to run the given function and return a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> object that eventually will hold the result of the execution.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/thread/future" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::future&lt;int&gt;</ref><sp/>future<sp/>=<sp/>executor.async(</highlight><highlight class="stringliteral">&quot;name&quot;</highlight><highlight class="normal">,<sp/>[](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;create<sp/>an<sp/>asynchronous<sp/>task<sp/>with<sp/>a<sp/>name<sp/>and<sp/>returns<sp/>1\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
<codeline><highlight class="normal">future.get();</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="623" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a28bdb43837bd6b548e092154e4df5dd9" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto tf::Executor::async</definition>
        <argsstring>(F &amp;&amp;func)</argsstring>
        <name>async</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <briefdescription>
<para>runs a given function asynchronously </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> that will hold the result of the execution</para>
</simplesect>
The method creates an asynchronous task to run the given function and return a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> object that eventually will hold the result of the return value.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/thread/future" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::future&lt;int&gt;</ref><sp/>future<sp/>=<sp/>executor.async([](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;create<sp/>an<sp/>asynchronous<sp/>task<sp/>and<sp/>returns<sp/>1\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
<codeline><highlight class="normal">future.get();</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="649" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a0461cb2c459c9f9473c72af06af9c701" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::Executor::silent_async</definition>
        <argsstring>(P &amp;&amp;params, F &amp;&amp;func)</argsstring>
        <name>silent_async</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>params</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <briefdescription>
<para>similar to <ref refid="classtf_1_1Executor_1af960048056f7c6b5bc71f4f526f05df7" kindref="member">tf::Executor::async</ref> but does not return a future object </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>params</parametername>
</parameternamelist>
<parameterdescription>
<para>task parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The method creates a parameterized asynchronous task to run the given function without returning any <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> object. This member function is more efficient than <ref refid="classtf_1_1Executor_1af960048056f7c6b5bc71f4f526f05df7" kindref="member">tf::Executor::async</ref> and is encouraged to use when applications do not need a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> to acquire the result or synchronize the execution.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">executor.silent_async(</highlight><highlight class="stringliteral">&quot;name&quot;</highlight><highlight class="normal">,<sp/>[](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;create<sp/>an<sp/>asynchronous<sp/>task<sp/>with<sp/>a<sp/>name<sp/>and<sp/>no<sp/>return\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
<codeline><highlight class="normal">executor.wait_for_all();</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="675" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a878ec1bc337c7efe22619b21ba3ecdf3" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::Executor::silent_async</definition>
        <argsstring>(F &amp;&amp;func)</argsstring>
        <name>silent_async</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <briefdescription>
<para>similar to <ref refid="classtf_1_1Executor_1af960048056f7c6b5bc71f4f526f05df7" kindref="member">tf::Executor::async</ref> but does not return a future object </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object</para>
</parameterdescription>
</parameteritem>
</parameterlist>
The method creates an asynchronous task to run the given function without returning any <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> object. This member function is more efficient than <ref refid="classtf_1_1Executor_1af960048056f7c6b5bc71f4f526f05df7" kindref="member">tf::Executor::async</ref> and is encouraged to use when applications do not need a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> to acquire the result or synchronize the execution.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal">executor.silent_async([](){</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;create<sp/>an<sp/>asynchronous<sp/>task<sp/>with<sp/>no<sp/>return\n&quot;</highlight><highlight class="normal">;</highlight></codeline>
<codeline><highlight class="normal">});</highlight></codeline>
<codeline><highlight class="normal">executor.wait_for_all();</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="700" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a0e2d792f28136b8227b413d0c27d5c7f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>Tasks</declname>
            <defname>Tasks</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; all_same_v&lt; <ref refid="classtf_1_1AsyncTask" kindref="compound">AsyncTask</ref>, std::decay_t&lt; Tasks &gt;... &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref></type>
        <definition>tf::AsyncTask tf::Executor::silent_dependent_async</definition>
        <argsstring>(F &amp;&amp;func, Tasks &amp;&amp;... tasks)</argsstring>
        <name>silent_dependent_async</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <param>
          <type>Tasks &amp;&amp;...</type>
          <declname>tasks</declname>
        </param>
        <briefdescription>
<para>runs the given function asynchronously when the given dependents finish </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tasks</parametername>
</parameternamelist>
<parameterdescription>
<para>task types convertible to <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tasks</parametername>
</parameternamelist>
<parameterdescription>
<para>asynchronous tasks on which this execution depends</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle</para>
</simplesect>
This member function is more efficient than <ref refid="classtf_1_1Executor_1aee02b63d3a91ad5ca5a1c0e71f3e128f" kindref="member">tf::Executor::dependent_async</ref> and is encouraged to use when you do not want a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> to acquire the result or synchronize the execution. The example below creates three asynchronous tasks, <computeroutput>A</computeroutput>, <computeroutput>B</computeroutput>, and <computeroutput>C</computeroutput>, in which task <computeroutput>C</computeroutput> runs after task <computeroutput>A</computeroutput> and task <computeroutput>B</computeroutput>.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>A<sp/>=<sp/>executor.silent_dependent_async([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;A\n&quot;</highlight><highlight class="normal">);<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>B<sp/>=<sp/>executor.silent_dependent_async([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;B\n&quot;</highlight><highlight class="normal">);<sp/>});</highlight></codeline>
<codeline><highlight class="normal">executor.silent_dependent_async([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;C<sp/>runs<sp/>after<sp/>A<sp/>and<sp/>B\n&quot;</highlight><highlight class="normal">);<sp/>},<sp/>A,<sp/>B);</highlight></codeline>
<codeline><highlight class="normal">executor.wait_for_all();</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="736" column="17"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1abbf277ddbe4974e928361f232149341e" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>Tasks</declname>
            <defname>Tasks</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1ad3a41adc2499a9519da3e77dc3e9849c" kindref="member">is_task_params_v</ref>&lt; P &gt; &amp;&amp;all_same_v&lt; <ref refid="classtf_1_1AsyncTask" kindref="compound">AsyncTask</ref>, std::decay_t&lt; Tasks &gt;... &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref></type>
        <definition>tf::AsyncTask tf::Executor::silent_dependent_async</definition>
        <argsstring>(P &amp;&amp;params, F &amp;&amp;func, Tasks &amp;&amp;... tasks)</argsstring>
        <name>silent_dependent_async</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>params</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <param>
          <type>Tasks &amp;&amp;...</type>
          <declname>tasks</declname>
        </param>
        <briefdescription>
<para>runs the given function asynchronously when the given dependents finish </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tasks</parametername>
</parameternamelist>
<parameterdescription>
<para>task types convertible to <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>params</parametername>
</parameternamelist>
<parameterdescription>
<para>task parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tasks</parametername>
</parameternamelist>
<parameterdescription>
<para>asynchronous tasks on which this execution depends</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle</para>
</simplesect>
This member function is more efficient than <ref refid="classtf_1_1Executor_1aee02b63d3a91ad5ca5a1c0e71f3e128f" kindref="member">tf::Executor::dependent_async</ref> and is encouraged to use when you do not want a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> to acquire the result or synchronize the execution. The example below creates three asynchronous tasks, <computeroutput>A</computeroutput>, <computeroutput>B</computeroutput>, and <computeroutput>C</computeroutput>, in which task <computeroutput>C</computeroutput> runs after task <computeroutput>A</computeroutput> and task <computeroutput>B</computeroutput>. Assigned task names will appear in the observers of the executor.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>A<sp/>=<sp/>executor.silent_dependent_async(</highlight><highlight class="stringliteral">&quot;A&quot;</highlight><highlight class="normal">,<sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;A\n&quot;</highlight><highlight class="normal">);<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>B<sp/>=<sp/>executor.silent_dependent_async(</highlight><highlight class="stringliteral">&quot;B&quot;</highlight><highlight class="normal">,<sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;B\n&quot;</highlight><highlight class="normal">);<sp/>});</highlight></codeline>
<codeline><highlight class="normal">executor.silent_dependent_async(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal">,<sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;C<sp/>runs<sp/>after<sp/>A<sp/>and<sp/>B\n&quot;</highlight><highlight class="normal">);<sp/>},<sp/>A,<sp/>B</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">executor.wait_for_all();</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="772" column="17"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1aa9b08e47e68ae1e568f18aa7104cb9b1" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>std::enable_if_t&lt;!std::is_same_v&lt; std::decay_t&lt; I &gt;, <ref refid="classtf_1_1AsyncTask" kindref="compound">AsyncTask</ref> &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref></type>
        <definition>tf::AsyncTask tf::Executor::silent_dependent_async</definition>
        <argsstring>(F &amp;&amp;func, I first, I last)</argsstring>
        <name>silent_dependent_async</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>runs the given function asynchronously when the given range of dependents finish </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning (inclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end (exclusive)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle</para>
</simplesect>
This member function is more efficient than <ref refid="classtf_1_1Executor_1aee02b63d3a91ad5ca5a1c0e71f3e128f" kindref="member">tf::Executor::dependent_async</ref> and is encouraged to use when you do not want a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> to acquire the result or synchronize the execution. The example below creates three asynchronous tasks, <computeroutput>A</computeroutput>, <computeroutput>B</computeroutput>, and <computeroutput>C</computeroutput>, in which task <computeroutput>C</computeroutput> runs after task <computeroutput>A</computeroutput> and task <computeroutput>B</computeroutput>.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/container/array" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::array&lt;tf::AsyncTask, 2&gt;</ref><sp/>array<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>executor.silent_dependent_async([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;A\n&quot;</highlight><highlight class="normal">);<sp/>}),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>executor.silent_dependent_async([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;B\n&quot;</highlight><highlight class="normal">);<sp/>})</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">executor.silent_dependent_async(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;C<sp/>runs<sp/>after<sp/>A<sp/>and<sp/>B\n&quot;</highlight><highlight class="normal">);<sp/>},<sp/>array.begin(),<sp/>array.end()</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">executor.wait_for_all();</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="809" column="17"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1afdfb0ef6f995288299f7fe7e53c0cf3b" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1ad3a41adc2499a9519da3e77dc3e9849c" kindref="member">is_task_params_v</ref>&lt; P &gt; &amp;&amp;!std::is_same_v&lt; std::decay_t&lt; I &gt;, <ref refid="classtf_1_1AsyncTask" kindref="compound">AsyncTask</ref> &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref></type>
        <definition>tf::AsyncTask tf::Executor::silent_dependent_async</definition>
        <argsstring>(P &amp;&amp;params, F &amp;&amp;func, I first, I last)</argsstring>
        <name>silent_dependent_async</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>params</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>runs the given function asynchronously when the given range of dependents finish </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>params</parametername>
</parameternamelist>
<parameterdescription>
<para>tasks parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning (inclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end (exclusive)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle</para>
</simplesect>
This member function is more efficient than <ref refid="classtf_1_1Executor_1aee02b63d3a91ad5ca5a1c0e71f3e128f" kindref="member">tf::Executor::dependent_async</ref> and is encouraged to use when you do not want a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> to acquire the result or synchronize the execution. The example below creates three asynchronous tasks, <computeroutput>A</computeroutput>, <computeroutput>B</computeroutput>, and <computeroutput>C</computeroutput>, in which task <computeroutput>C</computeroutput> runs after task <computeroutput>A</computeroutput> and task <computeroutput>B</computeroutput>. Assigned task names will appear in the observers of the executor.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/container/array" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::array&lt;tf::AsyncTask, 2&gt;</ref><sp/>array<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>executor.silent_dependent_async(</highlight><highlight class="stringliteral">&quot;A&quot;</highlight><highlight class="normal">,<sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;A\n&quot;</highlight><highlight class="normal">);<sp/>}),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>executor.silent_dependent_async(</highlight><highlight class="stringliteral">&quot;B&quot;</highlight><highlight class="normal">,<sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;B\n&quot;</highlight><highlight class="normal">);<sp/>})</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal">executor.silent_dependent_async(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal">,<sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;C<sp/>runs<sp/>after<sp/>A<sp/>and<sp/>B\n&quot;</highlight><highlight class="normal">);<sp/>},<sp/>array.begin(),<sp/>array.end()</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">executor.wait_for_all();</highlight></codeline>
</programlisting></para>
<para>This member function is thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="848" column="17"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1aee02b63d3a91ad5ca5a1c0e71f3e128f" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>Tasks</declname>
            <defname>Tasks</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; all_same_v&lt; <ref refid="classtf_1_1AsyncTask" kindref="compound">AsyncTask</ref>, std::decay_t&lt; Tasks &gt;... &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto tf::Executor::dependent_async</definition>
        <argsstring>(F &amp;&amp;func, Tasks &amp;&amp;... tasks)</argsstring>
        <name>dependent_async</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <param>
          <type>Tasks &amp;&amp;...</type>
          <declname>tasks</declname>
        </param>
        <briefdescription>
<para>runs the given function asynchronously when the given dependents finish </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tasks</parametername>
</parameternamelist>
<parameterdescription>
<para>task types convertible to <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tasks</parametername>
</parameternamelist>
<parameterdescription>
<para>asynchronous tasks on which this execution depends</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a pair of a <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle and a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> that holds the result of the execution</para>
</simplesect>
The example below creates three asynchronous tasks, <computeroutput>A</computeroutput>, <computeroutput>B</computeroutput>, and <computeroutput>C</computeroutput>, in which task <computeroutput>C</computeroutput> runs after task <computeroutput>A</computeroutput> and task <computeroutput>B</computeroutput>. <ref refid="classtf_1_1Task" kindref="compound">Task</ref> <computeroutput>C</computeroutput> returns a pair of its <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle and a std::future&lt;int&gt; that eventually will hold the result of the execution.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>A<sp/>=<sp/>executor.silent_dependent_async([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;A\n&quot;</highlight><highlight class="normal">);<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>B<sp/>=<sp/>executor.silent_dependent_async([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;B\n&quot;</highlight><highlight class="normal">);<sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>[C,<sp/>fuC]<sp/>=<sp/>executor.dependent_async(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[](){<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;C<sp/>runs<sp/>after<sp/>A<sp/>and<sp/>B\n&quot;</highlight><highlight class="normal">);<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>},<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>A,<sp/>B</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">fuC.get();<sp/><sp/></highlight><highlight class="comment">//<sp/>C<sp/>finishes,<sp/>which<sp/>in<sp/>turns<sp/>means<sp/>both<sp/>A<sp/>and<sp/>B<sp/>finish</highlight></codeline>
</programlisting></para>
<para>You can mixed the use of <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handles returned by <ref refid="classtf_1_1Executor_1aee02b63d3a91ad5ca5a1c0e71f3e128f" kindref="member">Executor::dependent_async</ref> and <ref refid="classtf_1_1Executor_1a0e2d792f28136b8227b413d0c27d5c7f" kindref="member">Executor::silent_dependent_async</ref> when specifying task dependencies.</para>
<para>This member function is thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="894" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a4428cc5d1102ecb0eb51e0b977e08857" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename...</type>
            <declname>Tasks</declname>
            <defname>Tasks</defname>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1ad3a41adc2499a9519da3e77dc3e9849c" kindref="member">is_task_params_v</ref>&lt; P &gt; &amp;&amp;all_same_v&lt; <ref refid="classtf_1_1AsyncTask" kindref="compound">AsyncTask</ref>, std::decay_t&lt; Tasks &gt;... &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto tf::Executor::dependent_async</definition>
        <argsstring>(P &amp;&amp;params, F &amp;&amp;func, Tasks &amp;&amp;... tasks)</argsstring>
        <name>dependent_async</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>params</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <param>
          <type>Tasks &amp;&amp;...</type>
          <declname>tasks</declname>
        </param>
        <briefdescription>
<para>runs the given function asynchronously when the given dependents finish </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>task parameters type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>Tasks</parametername>
</parameternamelist>
<parameterdescription>
<para>task types convertible to <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref></para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>params</parametername>
</parameternamelist>
<parameterdescription>
<para>task parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>tasks</parametername>
</parameternamelist>
<parameterdescription>
<para>asynchronous tasks on which this execution depends</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a pair of a <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle and a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> that holds the result of the execution</para>
</simplesect>
The example below creates three named asynchronous tasks, <computeroutput>A</computeroutput>, <computeroutput>B</computeroutput>, and <computeroutput>C</computeroutput>, in which task <computeroutput>C</computeroutput> runs after task <computeroutput>A</computeroutput> and task <computeroutput>B</computeroutput>. <ref refid="classtf_1_1Task" kindref="compound">Task</ref> <computeroutput>C</computeroutput> returns a pair of its <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle and a std::future&lt;int&gt; that eventually will hold the result of the execution. Assigned task names will appear in the observers of the executor.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>A<sp/>=<sp/>executor.silent_dependent_async(</highlight><highlight class="stringliteral">&quot;A&quot;</highlight><highlight class="normal">,<sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;A\n&quot;</highlight><highlight class="normal">);<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref><sp/>B<sp/>=<sp/>executor.silent_dependent_async(</highlight><highlight class="stringliteral">&quot;B&quot;</highlight><highlight class="normal">,<sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;B\n&quot;</highlight><highlight class="normal">);<sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>[C,<sp/>fuC]<sp/>=<sp/>executor.dependent_async(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[](){<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;C<sp/>runs<sp/>after<sp/>A<sp/>and<sp/>B\n&quot;</highlight><highlight class="normal">);<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>},<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>A,<sp/>B</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">assert(fuC.get()==1);<sp/><sp/></highlight><highlight class="comment">//<sp/>C<sp/>finishes,<sp/>which<sp/>in<sp/>turns<sp/>means<sp/>both<sp/>A<sp/>and<sp/>B<sp/>finish</highlight></codeline>
</programlisting></para>
<para>You can mixed the use of <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handles returned by <ref refid="classtf_1_1Executor_1aee02b63d3a91ad5ca5a1c0e71f3e128f" kindref="member">Executor::dependent_async</ref> and <ref refid="classtf_1_1Executor_1a0e2d792f28136b8227b413d0c27d5c7f" kindref="member">Executor::silent_dependent_async</ref> when specifying task dependencies.</para>
<para>This member function is thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="940" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a01e51e564f5def845506bcf6b4bb1664" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>std::enable_if_t&lt;!std::is_same_v&lt; std::decay_t&lt; I &gt;, <ref refid="classtf_1_1AsyncTask" kindref="compound">AsyncTask</ref> &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto tf::Executor::dependent_async</definition>
        <argsstring>(F &amp;&amp;func, I first, I last)</argsstring>
        <name>dependent_async</name>
        <param>
          <type>F &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>runs the given function asynchronously when the given range of dependents finish </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning (inclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end (exclusive)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a pair of a <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle and a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> that holds the result of the execution</para>
</simplesect>
The example below creates three asynchronous tasks, <computeroutput>A</computeroutput>, <computeroutput>B</computeroutput>, and <computeroutput>C</computeroutput>, in which task <computeroutput>C</computeroutput> runs after task <computeroutput>A</computeroutput> and task <computeroutput>B</computeroutput>. <ref refid="classtf_1_1Task" kindref="compound">Task</ref> <computeroutput>C</computeroutput> returns a pair of its <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle and a std::future&lt;int&gt; that eventually will hold the result of the execution.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/container/array" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::array&lt;tf::AsyncTask, 2&gt;</ref><sp/>array<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>executor.silent_dependent_async([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;A\n&quot;</highlight><highlight class="normal">);<sp/>}),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>executor.silent_dependent_async([](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;B\n&quot;</highlight><highlight class="normal">);<sp/>})</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>[C,<sp/>fuC]<sp/>=<sp/>executor.dependent_async(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[](){<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;C<sp/>runs<sp/>after<sp/>A<sp/>and<sp/>B\n&quot;</highlight><highlight class="normal">);<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>},<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>array.begin(),<sp/>array.end()</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">assert(fuC.get()==1);<sp/><sp/></highlight><highlight class="comment">//<sp/>C<sp/>finishes,<sp/>which<sp/>in<sp/>turns<sp/>means<sp/>both<sp/>A<sp/>and<sp/>B<sp/>finish</highlight></codeline>
</programlisting></para>
<para>You can mixed the use of <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handles returned by <ref refid="classtf_1_1Executor_1aee02b63d3a91ad5ca5a1c0e71f3e128f" kindref="member">Executor::dependent_async</ref> and <ref refid="classtf_1_1Executor_1a0e2d792f28136b8227b413d0c27d5c7f" kindref="member">Executor::silent_dependent_async</ref> when specifying task dependencies.</para>
<para>This member function is thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="985" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a962d7fb7213a804ee4a2e7b79455efdc" prot="public" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
          <param>
            <type>typename F</type>
          </param>
          <param>
            <type>typename I</type>
          </param>
          <param>
            <type>std::enable_if_t&lt; <ref refid="namespacetf_1ad3a41adc2499a9519da3e77dc3e9849c" kindref="member">is_task_params_v</ref>&lt; P &gt; &amp;&amp;!std::is_same_v&lt; std::decay_t&lt; I &gt;, <ref refid="classtf_1_1AsyncTask" kindref="compound">AsyncTask</ref> &gt;, void &gt; *</type>
            <defval>nullptr</defval>
          </param>
        </templateparamlist>
        <type>auto</type>
        <definition>auto tf::Executor::dependent_async</definition>
        <argsstring>(P &amp;&amp;params, F &amp;&amp;func, I first, I last)</argsstring>
        <name>dependent_async</name>
        <param>
          <type>P &amp;&amp;</type>
          <declname>params</declname>
        </param>
        <param>
          <type>F &amp;&amp;</type>
          <declname>func</declname>
        </param>
        <param>
          <type>I</type>
          <declname>first</declname>
        </param>
        <param>
          <type>I</type>
          <declname>last</declname>
        </param>
        <briefdescription>
<para>runs the given function asynchronously when the given range of dependents finish </para>
        </briefdescription>
        <detaileddescription>
<para><parameterlist kind="templateparam"><parameteritem>
<parameternamelist>
<parametername>P</parametername>
</parameternamelist>
<parameterdescription>
<para>task parameters type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>F</parametername>
</parameternamelist>
<parameterdescription>
<para>callable type </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>I</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator type</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<parameterlist kind="param"><parameteritem>
<parameternamelist>
<parametername>params</parametername>
</parameternamelist>
<parameterdescription>
<para>task parameters </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>func</parametername>
</parameternamelist>
<parameterdescription>
<para>callable object </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>first</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the beginning (inclusive) </para>
</parameterdescription>
</parameteritem>
<parameteritem>
<parameternamelist>
<parametername>last</parametername>
</parameternamelist>
<parameterdescription>
<para>iterator to the end (exclusive)</para>
</parameterdescription>
</parameteritem>
</parameterlist>
<simplesect kind="return"><para>a pair of a <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle and a <ulink url="https://en.cppreference.com/w/cpp/thread/future">std::future</ulink> that holds the result of the execution</para>
</simplesect>
The example below creates three named asynchronous tasks, <computeroutput>A</computeroutput>, <computeroutput>B</computeroutput>, and <computeroutput>C</computeroutput>, in which task <computeroutput>C</computeroutput> runs after task <computeroutput>A</computeroutput> and task <computeroutput>B</computeroutput>. <ref refid="classtf_1_1Task" kindref="compound">Task</ref> <computeroutput>C</computeroutput> returns a pair of its <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handle and a std::future&lt;int&gt; that eventually will hold the result of the execution. Assigned task names will appear in the observers of the executor.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="normal"><ref refid="cpp/container/array" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::array&lt;tf::AsyncTask, 2&gt;</ref><sp/>array<sp/>{</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>executor.silent_dependent_async(</highlight><highlight class="stringliteral">&quot;A&quot;</highlight><highlight class="normal">,<sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;A\n&quot;</highlight><highlight class="normal">);<sp/>}),</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>executor.silent_dependent_async(</highlight><highlight class="stringliteral">&quot;B&quot;</highlight><highlight class="normal">,<sp/>[](){<sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;B\n&quot;</highlight><highlight class="normal">);<sp/>})</highlight></codeline>
<codeline><highlight class="normal">};</highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="keyword">auto</highlight><highlight class="normal"><sp/>[C,<sp/>fuC]<sp/>=<sp/>executor.dependent_async(</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/></highlight><highlight class="stringliteral">&quot;C&quot;</highlight><highlight class="normal">,</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>[](){<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/><ref refid="cpp/io/c/fprintf" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">printf</ref>(</highlight><highlight class="stringliteral">&quot;C<sp/>runs<sp/>after<sp/>A<sp/>and<sp/>B\n&quot;</highlight><highlight class="normal">);<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/><sp/><sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>1;</highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>},<sp/></highlight></codeline>
<codeline><highlight class="normal"><sp/><sp/>array.begin(),<sp/>array.end()</highlight></codeline>
<codeline><highlight class="normal">);</highlight></codeline>
<codeline><highlight class="normal">assert(fuC.get()==1);<sp/><sp/></highlight><highlight class="comment">//<sp/>C<sp/>finishes,<sp/>which<sp/>in<sp/>turns<sp/>means<sp/>both<sp/>A<sp/>and<sp/>B<sp/>finish</highlight></codeline>
</programlisting></para>
<para>You can mixed the use of <ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> handles returned by <ref refid="classtf_1_1Executor_1aee02b63d3a91ad5ca5a1c0e71f3e128f" kindref="member">Executor::dependent_async</ref> and <ref refid="classtf_1_1Executor_1a0e2d792f28136b8227b413d0c27d5c7f" kindref="member">Executor::silent_dependent_async</ref> when specifying task dependencies.</para>
<para>This member function is thread-safe. </para>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1034" column="8"/>
      </memberdef>
      </sectiondef>
      <sectiondef kind="private-func">
      <memberdef kind="function" id="classtf_1_1Executor_1a57f5105dc812d83f259ec8cab7c96228" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tf::Executor::_wait_for_task</definition>
        <argsstring>(Worker &amp;, Node *&amp;)</argsstring>
        <name>_wait_for_task</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>Node *&amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1073" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a7338106d893b2b7cc223376878a48d64" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>bool</type>
        <definition>bool tf::Executor::_invoke_module_task_internal</definition>
        <argsstring>(Worker &amp;, Node *)</argsstring>
        <name>_invoke_module_task_internal</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>Node *</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1074" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1ae023614977a19def9e04cf7212eab65b" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_observer_prologue</definition>
        <argsstring>(Worker &amp;, Node *)</argsstring>
        <name>_observer_prologue</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>Node *</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1076" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a9cd8c1a72af4477bc0f9575b68ffb16a" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_observer_epilogue</definition>
        <argsstring>(Worker &amp;, Node *)</argsstring>
        <name>_observer_epilogue</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>Node *</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1077" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a8aee6c0ec55b4bfb3909601203e98514" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_spawn</definition>
        <argsstring>(size_t)</argsstring>
        <name>_spawn</name>
        <param>
          <type>size_t</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1078" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a0b4f231e11016194980b14e76262c8a7" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_exploit_task</definition>
        <argsstring>(Worker &amp;, Node *&amp;)</argsstring>
        <name>_exploit_task</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>Node *&amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1079" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1aab7cc2e53d75fcc87fcc919f29bf9ca9" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_explore_task</definition>
        <argsstring>(Worker &amp;, Node *&amp;)</argsstring>
        <name>_explore_task</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>Node *&amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1080" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1ab8d98f12a62d10ad6cf1a4011a4d0034" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_schedule</definition>
        <argsstring>(Worker &amp;, Node *)</argsstring>
        <name>_schedule</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>Node *</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1081" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a685c08b62a494359e34c6de2a700fdab" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_schedule</definition>
        <argsstring>(Node *)</argsstring>
        <name>_schedule</name>
        <param>
          <type>Node *</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1082" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a93428e4393889d4f944cd2ead5ae9a44" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_schedule</definition>
        <argsstring>(Worker &amp;, const SmallVector&lt; Node * &gt; &amp;)</argsstring>
        <name>_schedule</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>const <ref refid="classtf_1_1SmallVector" kindref="compound">SmallVector</ref>&lt; Node * &gt; &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1083" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1aeb7284d779569a8297bca3c5f126cd9b" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_schedule</definition>
        <argsstring>(const SmallVector&lt; Node * &gt; &amp;)</argsstring>
        <name>_schedule</name>
        <param>
          <type>const <ref refid="classtf_1_1SmallVector" kindref="compound">SmallVector</ref>&lt; Node * &gt; &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1084" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a723daf897c5d3d3517583cb4c62654ee" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_set_up_topology</definition>
        <argsstring>(Worker *, Topology *)</argsstring>
        <name>_set_up_topology</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> *</type>
        </param>
        <param>
          <type>Topology *</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1085" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a9c5bd85f2a5a266ae9cd27e5aaf2f14e" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_set_up_graph</definition>
        <argsstring>(Graph &amp;, Node *, Topology *, int, SmallVector&lt; Node * &gt; &amp;)</argsstring>
        <name>_set_up_graph</name>
        <param>
          <type><ref refid="classtf_1_1Graph" kindref="compound">Graph</ref> &amp;</type>
        </param>
        <param>
          <type>Node *</type>
        </param>
        <param>
          <type>Topology *</type>
        </param>
        <param>
          <type>int</type>
        </param>
        <param>
          <type><ref refid="classtf_1_1SmallVector" kindref="compound">SmallVector</ref>&lt; Node * &gt; &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1086" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a76be884d38d1bb8f9b8bba488c901b4b" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_tear_down_topology</definition>
        <argsstring>(Worker &amp;, Topology *)</argsstring>
        <name>_tear_down_topology</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>Topology *</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1087" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a42e7db3fc43e1c5479e30e8d83da9e74" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_tear_down_async</definition>
        <argsstring>(Node *)</argsstring>
        <name>_tear_down_async</name>
        <param>
          <type>Node *</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1088" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a5a745396246598bb55acb9dd3a4b6c25" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_tear_down_dependent_async</definition>
        <argsstring>(Worker &amp;, Node *)</argsstring>
        <name>_tear_down_dependent_async</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>Node *</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1089" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a17fe8e0f32892cf2848611bca7566378" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_tear_down_invoke</definition>
        <argsstring>(Worker &amp;, Node *)</argsstring>
        <name>_tear_down_invoke</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>Node *</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1090" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1ab85dc42b3e9b18e4b975bd5e9a8c5e72" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_increment_topology</definition>
        <argsstring>()</argsstring>
        <name>_increment_topology</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1091" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a8728f22f6d177fad84ce667e02a7a3b9" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_decrement_topology</definition>
        <argsstring>()</argsstring>
        <name>_decrement_topology</name>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1092" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1ad16165142908aca9444ea88e65040219" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_invoke</definition>
        <argsstring>(Worker &amp;, Node *)</argsstring>
        <name>_invoke</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>Node *</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1093" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1ac243d2a08b5a4a75dd440dc063b886ce" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_invoke_static_task</definition>
        <argsstring>(Worker &amp;, Node *)</argsstring>
        <name>_invoke_static_task</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>Node *</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1094" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1aacaec034158ede71eb815a9a1e9a83ca" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_invoke_subflow_task</definition>
        <argsstring>(Worker &amp;, Node *)</argsstring>
        <name>_invoke_subflow_task</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>Node *</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1095" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a990098e7c3c5d055c2aa87526772ce1e" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_detach_subflow_task</definition>
        <argsstring>(Worker &amp;, Node *, Graph &amp;)</argsstring>
        <name>_detach_subflow_task</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>Node *</type>
        </param>
        <param>
          <type><ref refid="classtf_1_1Graph" kindref="compound">Graph</ref> &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1096" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1afa6be6aab23ff4b2a293a2245818916d" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_invoke_condition_task</definition>
        <argsstring>(Worker &amp;, Node *, SmallVector&lt; int &gt; &amp;)</argsstring>
        <name>_invoke_condition_task</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>Node *</type>
        </param>
        <param>
          <type><ref refid="classtf_1_1SmallVector" kindref="compound">SmallVector</ref>&lt; int &gt; &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1097" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a19b3f10d4eab40143d3f76b946ded252" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_invoke_multi_condition_task</definition>
        <argsstring>(Worker &amp;, Node *, SmallVector&lt; int &gt; &amp;)</argsstring>
        <name>_invoke_multi_condition_task</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>Node *</type>
        </param>
        <param>
          <type><ref refid="classtf_1_1SmallVector" kindref="compound">SmallVector</ref>&lt; int &gt; &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1098" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a4c5324657bf02bc2da0294192ab80233" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_invoke_module_task</definition>
        <argsstring>(Worker &amp;, Node *)</argsstring>
        <name>_invoke_module_task</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>Node *</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1099" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a505ccafa7ab1855c200d5590499adf5a" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_invoke_async_task</definition>
        <argsstring>(Worker &amp;, Node *)</argsstring>
        <name>_invoke_async_task</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>Node *</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1100" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a6c5e337d9666504eed50c242f2090dbf" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_invoke_dependent_async_task</definition>
        <argsstring>(Worker &amp;, Node *)</argsstring>
        <name>_invoke_dependent_async_task</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>Node *</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1101" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a824fbb761eaece4549da2fe070f95dac" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_process_async_dependent</definition>
        <argsstring>(Node *, tf::AsyncTask &amp;, size_t &amp;)</argsstring>
        <name>_process_async_dependent</name>
        <param>
          <type>Node *</type>
        </param>
        <param>
          <type><ref refid="classtf_1_1AsyncTask" kindref="compound">tf::AsyncTask</ref> &amp;</type>
        </param>
        <param>
          <type>size_t &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1102" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1ad3c24a3fa701517bfdf119c549e2729a" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_process_exception</definition>
        <argsstring>(Worker &amp;, Node *)</argsstring>
        <name>_process_exception</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>Node *</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1103" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1af5acda8c6e9a1564c9d665336ea091d0" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_schedule_async_task</definition>
        <argsstring>(Node *)</argsstring>
        <name>_schedule_async_task</name>
        <param>
          <type>Node *</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1104" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a6202243d809e524d196a9c0e3092ce41" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <type>void</type>
        <definition>void tf::Executor::_corun_graph</definition>
        <argsstring>(Worker &amp;, Node *, Graph &amp;)</argsstring>
        <name>_corun_graph</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>Node *</type>
        </param>
        <param>
          <type><ref refid="classtf_1_1Graph" kindref="compound">Graph</ref> &amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1105" column="8"/>
      </memberdef>
      <memberdef kind="function" id="classtf_1_1Executor_1a43cdd198427b7be2827450f6ce8343af" prot="private" static="no" const="no" explicit="no" inline="no" virt="non-virtual">
        <templateparamlist>
          <param>
            <type>typename P</type>
          </param>
        </templateparamlist>
        <type>void</type>
        <definition>void tf::Executor::_corun_until</definition>
        <argsstring>(Worker &amp;, P &amp;&amp;)</argsstring>
        <name>_corun_until</name>
        <param>
          <type><ref refid="classtf_1_1Worker" kindref="compound">Worker</ref> &amp;</type>
        </param>
        <param>
          <type>P &amp;&amp;</type>
        </param>
        <briefdescription>
        </briefdescription>
        <detaileddescription>
        </detaileddescription>
        <inbodydescription>
        </inbodydescription>
        <location file="taskflow/core/executor.hpp" line="1108" column="8"/>
      </memberdef>
      </sectiondef>
    <briefdescription>
<para>class to create an executor </para>
    </briefdescription>
    <detaileddescription>
<para>An executor manages a set of worker threads to run one or multiple taskflows using an efficient work-stealing scheduling algorithm.</para>
<para><programlisting filename=".cpp"><codeline><highlight class="comment">//<sp/>Declare<sp/>an<sp/>executor<sp/>and<sp/>a<sp/>taskflow</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Executor" kindref="compound">tf::Executor</ref><sp/>executor;</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Taskflow" kindref="compound">tf::Taskflow</ref><sp/>taskflow;</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Add<sp/>three<sp/>tasks<sp/>into<sp/>the<sp/>taskflow</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>A<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>is<sp/>TaskA\n&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>B<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>is<sp/>TaskB\n&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Task" kindref="compound">tf::Task</ref><sp/>C<sp/>=<sp/>taskflow.<ref refid="classtf_1_1FlowBuilder_1a60d7a666cab71ecfa3010b2efb0d6b57" kindref="member">emplace</ref>([]<sp/>()<sp/>{<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;This<sp/>is<sp/>TaskC\n&quot;</highlight><highlight class="normal">;<sp/>});</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight><highlight class="comment">//<sp/>Build<sp/>precedence<sp/>between<sp/>tasks</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">A.<ref refid="classtf_1_1Task_1a8c78c453295a553c1c016e4062da8588" kindref="member">precede</ref>(B,<sp/>C);</highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"><ref refid="classtf_1_1Future" kindref="compound">tf::Future&lt;void&gt;</ref><sp/>fu<sp/>=<sp/>executor.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow);</highlight></codeline>
<codeline><highlight class="normal">fu.wait();<sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/><sp/></highlight><highlight class="comment">//<sp/>block<sp/>until<sp/>the<sp/>execution<sp/>completes</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" kindref="member">run</ref>(taskflow,<sp/>[](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;end<sp/>of<sp/>1<sp/>run&quot;</highlight><highlight class="normal">;<sp/>}).wait();</highlight></codeline>
<codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1af15db5f7dde8e7ff1f86ef8fe825e9e2" kindref="member">run_n</ref>(taskflow,<sp/>4);</highlight></codeline>
<codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1ab9aa252f70e9a40020a1e5a89d485b85" kindref="member">wait_for_all</ref>();<sp/><sp/></highlight><highlight class="comment">//<sp/>block<sp/>until<sp/>all<sp/>associated<sp/>executions<sp/>finish</highlight><highlight class="normal"></highlight></codeline>
<codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1af15db5f7dde8e7ff1f86ef8fe825e9e2" kindref="member">run_n</ref>(taskflow,<sp/>4,<sp/>[](){<sp/><ref refid="cpp/io/basic_ostream" kindref="compound" external="/home/thuang295/Code/taskflow/doxygen/cppreference-doxygen-web.tag.xml">std::cout</ref><sp/>&lt;&lt;<sp/></highlight><highlight class="stringliteral">&quot;end<sp/>of<sp/>4<sp/>runs&quot;</highlight><highlight class="normal">;<sp/>}).wait();</highlight></codeline>
<codeline><highlight class="normal">executor.<ref refid="classtf_1_1Executor_1ae4f9e214ea5ee873e8d90a70bc1c77e8" kindref="member">run_until</ref>(taskflow,<sp/>[cnt=0]<sp/>()<sp/></highlight><highlight class="keyword">mutable</highlight><highlight class="normal"><sp/>{<sp/></highlight><highlight class="keywordflow">return</highlight><highlight class="normal"><sp/>++cnt<sp/>==<sp/>10;<sp/>});</highlight></codeline>
</programlisting></para>
<para>All the <computeroutput>run</computeroutput> methods are <emphasis>thread-safe</emphasis>. You can submit multiple taskflows at the same time to an executor from different threads. </para>
    </detaileddescription>
    <location file="taskflow/core/executor.hpp" line="53" column="1" bodyfile="taskflow/core/executor.hpp" bodystart="53" bodyend="1110"/>
    <listofallmembers>
      <member refid="classtf_1_1Executor_1a6202243d809e524d196a9c0e3092ce41" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_corun_graph</name></member>
      <member refid="classtf_1_1Executor_1a43cdd198427b7be2827450f6ce8343af" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_corun_until</name></member>
      <member refid="classtf_1_1Executor_1a8728f22f6d177fad84ce667e02a7a3b9" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_decrement_topology</name></member>
      <member refid="classtf_1_1Executor_1a990098e7c3c5d055c2aa87526772ce1e" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_detach_subflow_task</name></member>
      <member refid="classtf_1_1Executor_1a500d540a170f1da6e5247168bc6efa87" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_done</name></member>
      <member refid="classtf_1_1Executor_1a0b4f231e11016194980b14e76262c8a7" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_exploit_task</name></member>
      <member refid="classtf_1_1Executor_1aab7cc2e53d75fcc87fcc919f29bf9ca9" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_explore_task</name></member>
      <member refid="classtf_1_1Executor_1a0f74eb32b801b30164e36936204c4b66" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_freelist</name></member>
      <member refid="classtf_1_1Executor_1ab85dc42b3e9b18e4b975bd5e9a8c5e72" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_increment_topology</name></member>
      <member refid="classtf_1_1Executor_1ad16165142908aca9444ea88e65040219" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_invoke</name></member>
      <member refid="classtf_1_1Executor_1a505ccafa7ab1855c200d5590499adf5a" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_invoke_async_task</name></member>
      <member refid="classtf_1_1Executor_1afa6be6aab23ff4b2a293a2245818916d" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_invoke_condition_task</name></member>
      <member refid="classtf_1_1Executor_1a6c5e337d9666504eed50c242f2090dbf" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_invoke_dependent_async_task</name></member>
      <member refid="classtf_1_1Executor_1a4c5324657bf02bc2da0294192ab80233" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_invoke_module_task</name></member>
      <member refid="classtf_1_1Executor_1a7338106d893b2b7cc223376878a48d64" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_invoke_module_task_internal</name></member>
      <member refid="classtf_1_1Executor_1a19b3f10d4eab40143d3f76b946ded252" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_invoke_multi_condition_task</name></member>
      <member refid="classtf_1_1Executor_1ac243d2a08b5a4a75dd440dc063b886ce" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_invoke_static_task</name></member>
      <member refid="classtf_1_1Executor_1aacaec034158ede71eb815a9a1e9a83ca" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_invoke_subflow_task</name></member>
      <member refid="classtf_1_1Executor_1a321f9b72162b9f5d4ba46d829af985cc" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_latch</name></member>
      <member refid="classtf_1_1Executor_1ac4a4632561a52d00a02d91296b20cb5a" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_MAX_STEALS</name></member>
      <member refid="classtf_1_1Executor_1ab36f7f886f9a6a9ad67ce919ca39d688" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_notifier</name></member>
      <member refid="classtf_1_1Executor_1a9e38edfbc967dd3f5ca6f7a115f95ed7" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_num_topologies</name></member>
      <member refid="classtf_1_1Executor_1a9cd8c1a72af4477bc0f9575b68ffb16a" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_observer_epilogue</name></member>
      <member refid="classtf_1_1Executor_1ae023614977a19def9e04cf7212eab65b" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_observer_prologue</name></member>
      <member refid="classtf_1_1Executor_1ad7f083460df992b1186f83ac99481a57" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_observers</name></member>
      <member refid="classtf_1_1Executor_1a824fbb761eaece4549da2fe070f95dac" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_process_async_dependent</name></member>
      <member refid="classtf_1_1Executor_1ad3c24a3fa701517bfdf119c549e2729a" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_process_exception</name></member>
      <member refid="classtf_1_1Executor_1ab8d98f12a62d10ad6cf1a4011a4d0034" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_schedule</name></member>
      <member refid="classtf_1_1Executor_1a685c08b62a494359e34c6de2a700fdab" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_schedule</name></member>
      <member refid="classtf_1_1Executor_1a93428e4393889d4f944cd2ead5ae9a44" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_schedule</name></member>
      <member refid="classtf_1_1Executor_1aeb7284d779569a8297bca3c5f126cd9b" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_schedule</name></member>
      <member refid="classtf_1_1Executor_1af5acda8c6e9a1564c9d665336ea091d0" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_schedule_async_task</name></member>
      <member refid="classtf_1_1Executor_1a9c5bd85f2a5a266ae9cd27e5aaf2f14e" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_set_up_graph</name></member>
      <member refid="classtf_1_1Executor_1a723daf897c5d3d3517583cb4c62654ee" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_set_up_topology</name></member>
      <member refid="classtf_1_1Executor_1a8aee6c0ec55b4bfb3909601203e98514" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_spawn</name></member>
      <member refid="classtf_1_1Executor_1a63090414fbad15f5934838d21aa0a28f" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_taskflows</name></member>
      <member refid="classtf_1_1Executor_1aef4cf993dbd8efa0372cdea6b0f725d7" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_taskflows_mutex</name></member>
      <member refid="classtf_1_1Executor_1a42e7db3fc43e1c5479e30e8d83da9e74" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_tear_down_async</name></member>
      <member refid="classtf_1_1Executor_1a5a745396246598bb55acb9dd3a4b6c25" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_tear_down_dependent_async</name></member>
      <member refid="classtf_1_1Executor_1a17fe8e0f32892cf2848611bca7566378" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_tear_down_invoke</name></member>
      <member refid="classtf_1_1Executor_1a76be884d38d1bb8f9b8bba488c901b4b" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_tear_down_topology</name></member>
      <member refid="classtf_1_1Executor_1a3b5e7cf6749feded228a46e9fbfdef5f" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_threads</name></member>
      <member refid="classtf_1_1Executor_1a94357ea08db1859178f855b0b926b3de" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_topology_cv</name></member>
      <member refid="classtf_1_1Executor_1a8be5571fa0df99784aacb26b01d0f4b4" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_topology_mutex</name></member>
      <member refid="classtf_1_1Executor_1a57f5105dc812d83f259ec8cab7c96228" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_wait_for_task</name></member>
      <member refid="classtf_1_1Executor_1ad93162f032d463cc845fbca4fc0d960e" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>_workers</name></member>
      <member refid="classtf_1_1Executor_1af960048056f7c6b5bc71f4f526f05df7" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>async</name></member>
      <member refid="classtf_1_1Executor_1a28bdb43837bd6b548e092154e4df5dd9" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>async</name></member>
      <member refid="classtf_1_1Executor_1a8fcd9e0557922bb8194999f0cd433ea8" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>corun</name></member>
      <member refid="classtf_1_1Executor_1a0fc6eb19f168dc4a9cd0a7c6187c1d2d" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>corun_until</name></member>
      <member refid="classtf_1_1Executor_1aee02b63d3a91ad5ca5a1c0e71f3e128f" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>dependent_async</name></member>
      <member refid="classtf_1_1Executor_1a4428cc5d1102ecb0eb51e0b977e08857" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>dependent_async</name></member>
      <member refid="classtf_1_1Executor_1a01e51e564f5def845506bcf6b4bb1664" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>dependent_async</name></member>
      <member refid="classtf_1_1Executor_1a962d7fb7213a804ee4a2e7b79455efdc" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>dependent_async</name></member>
      <member refid="classtf_1_1Executor_1a4910e89d89146b6d563d598b795eb4a9" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>Executor</name></member>
      <member refid="classtf_1_1Executor_1a61184f9bd9c801d0a5eccecfdbddc641" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>FlowBuilder</name></member>
      <member refid="classtf_1_1Executor_1ab5a793a0f2ce41cd49ca45e9f0a6962c" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>make_observer</name></member>
      <member refid="classtf_1_1Executor_1affec621aae59d73fc188ef454008fda2" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>num_observers</name></member>
      <member refid="classtf_1_1Executor_1a5fb438dc0f7b9e1ae2fe3f240c82f174" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>num_taskflows</name></member>
      <member refid="classtf_1_1Executor_1a6d6c28ed58211e4c27a99571e5bf0b6c" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>num_topologies</name></member>
      <member refid="classtf_1_1Executor_1a9d2d464ab2a84ecb3b3ea7747e8e276b" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>num_workers</name></member>
      <member refid="classtf_1_1Executor_1a31081f492c376f7b798de0e430534531" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>remove_observer</name></member>
      <member refid="classtf_1_1Executor_1a8d08f0cb79e7b3780087975d13368a96" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>run</name></member>
      <member refid="classtf_1_1Executor_1a4b97752c00b788918cb8396fbb1b3ad0" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>run</name></member>
      <member refid="classtf_1_1Executor_1a5a480ed24a6fd1e4152db69c0c5e2f89" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>run</name></member>
      <member refid="classtf_1_1Executor_1a2d0dc32d81100202168e42ac1d3dd8f9" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>run</name></member>
      <member refid="classtf_1_1Executor_1af15db5f7dde8e7ff1f86ef8fe825e9e2" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>run_n</name></member>
      <member refid="classtf_1_1Executor_1a04aa012598622e807dba3272aa464d7e" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>run_n</name></member>
      <member refid="classtf_1_1Executor_1a37af2ca2a97f0188fb2c4868d6f322ba" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>run_n</name></member>
      <member refid="classtf_1_1Executor_1ae5c5c6a1c1f6d4740414c86daa6a3901" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>run_n</name></member>
      <member refid="classtf_1_1Executor_1ae4f9e214ea5ee873e8d90a70bc1c77e8" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>run_until</name></member>
      <member refid="classtf_1_1Executor_1a724d188df2952f64c1f2c60555a0a611" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>run_until</name></member>
      <member refid="classtf_1_1Executor_1a5ed30b8db88cdeb78fe3e8e2de4a84dd" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>run_until</name></member>
      <member refid="classtf_1_1Executor_1ad7aa69f06309b9226a4046f8c400144e" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>run_until</name></member>
      <member refid="classtf_1_1Executor_1af3d14e26ba8af9e6cc5a32aad8446de7" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>Runtime</name></member>
      <member refid="classtf_1_1Executor_1a0461cb2c459c9f9473c72af06af9c701" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>silent_async</name></member>
      <member refid="classtf_1_1Executor_1a878ec1bc337c7efe22619b21ba3ecdf3" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>silent_async</name></member>
      <member refid="classtf_1_1Executor_1a0e2d792f28136b8227b413d0c27d5c7f" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>silent_dependent_async</name></member>
      <member refid="classtf_1_1Executor_1abbf277ddbe4974e928361f232149341e" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>silent_dependent_async</name></member>
      <member refid="classtf_1_1Executor_1aa9b08e47e68ae1e568f18aa7104cb9b1" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>silent_dependent_async</name></member>
      <member refid="classtf_1_1Executor_1afdfb0ef6f995288299f7fe7e53c0cf3b" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>silent_dependent_async</name></member>
      <member refid="classtf_1_1Executor_1aa48945297ede77a161defc88033ce8a6" prot="private" virt="non-virtual"><scope>tf::Executor</scope><name>Subflow</name></member>
      <member refid="classtf_1_1Executor_1a6487d589cb1f6b078b69fd3bb1082345" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>this_worker_id</name></member>
      <member refid="classtf_1_1Executor_1ab9aa252f70e9a40020a1e5a89d485b85" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>wait_for_all</name></member>
      <member refid="classtf_1_1Executor_1a5a511b0cc23b264826373d3dabcef670" prot="public" virt="non-virtual"><scope>tf::Executor</scope><name>~Executor</name></member>
    </listofallmembers>
  </compounddef>
</doxygen>
