<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>tf::Runtime class | Taskflow QuickStart</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark+documentation.compiled.css" />
  <link rel="icon" href="favicon.ico" type="image/vnd.microsoft.icon" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <span id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">
        <a href="https://taskflow.github.io"><img src="taskflow_logo.png" alt="" />Taskflow</a> <span class="m-breadcrumb">|</span> <a href="index.html" class="m-thin">QuickStart</a>
      </span>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="pages.html">Handbook</a></li>
            <li><a href="namespaces.html">Namespaces</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          <span class="m-breadcrumb"><a href="namespacetf.html">tf</a>::<wbr/></span>Runtime <span class="m-thin">class</span>
        </h1>
        <p>class to include a runtime object in a task</p>
        <nav class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li>
              Reference
              <ul>
                <li><a href="#pub-methods">Public functions</a></li>
              </ul>
            </li>
          </ul>
        </nav>
<p>A runtime object provides an interface for interacting with the scheduling system from within a task (i.e., the parent task of this runtime). It enables operations such as spawning asynchronous tasks, executing tasks cooperatively, and implementing recursive parallelism. The runtime guarantees an implicit join at the end of its scope, so all spawned tasks will finish before the parent runtime task continues to its successors.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Executor</span><span class="w"> </span><span class="nf">executor</span><span class="p">(</span><span class="n">num_threads</span><span class="p">);</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Taskflow</span><span class="w"> </span><span class="n">taskflow</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">counter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">Runtime</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rt</span><span class="p">){</span>
<span class="w">  </span><span class="c1">// spawn 1000 asynchronous tasks from this runtime task</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span><span class="w"> </span><span class="n">counter</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// implicit synchronization at the end of the runtime scope</span>
<span class="p">});</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
<span class="w">  </span><span class="n">REQUIRE</span><span class="p">(</span><span class="n">counter</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memory_order_relaxed</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1000</span><span class="p">);</span>
<span class="p">});</span>
<span class="n">A</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">B</span><span class="p">);</span>

<span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span></pre><p>A runtime object is associated with the worker and the executor that runs its parent task.</p><aside class="m-note m-info"><h4>Note</h4><p>To understand how Taskflow schedules a runtime task, please refer to <a href="RuntimeTasking.html" class="m-doc">Runtime Tasking</a>.</p></aside>
        <section id="pub-methods">
          <h2><a href="#pub-methods">Public functions</a></h2>
          <dl class="m-doc">
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a4ee48a82df1f9758a999d18e6015cec4" class="m-doc">executor</a>(</span><span class="m-doc-wrap">) -&gt; <a href="classtf_1_1Executor.html" class="m-doc">Executor</a>&amp;</span>
            </dt>
            <dd>obtains the running executor</dd>
            <dt id="ae1dbce75fd7375ae3bf38948638e34ec">
              <span class="m-doc-wrap-bumper">auto <a href="#ae1dbce75fd7375ae3bf38948638e34ec" class="m-doc-self">worker</a>(</span><span class="m-doc-wrap">) -&gt; <a href="classtf_1_1Worker.html" class="m-doc">Worker</a>&amp;</span>
            </dt>
            <dd>acquire a reference to the underlying worker</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#aa7e72cc0f298475195b252c8f1793343" class="m-doc">schedule</a>(</span><span class="m-doc-wrap"><a href="classtf_1_1Task.html" class="m-doc">Task</a> task)</span>
            </dt>
            <dd>schedules an active task immediately to the worker&#x27;s queue</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename F&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a5688b13034f179c4a8b2b0ebbb215051" class="m-doc">async</a>(</span><span class="m-doc-wrap">F&amp;&amp; f) -&gt; auto</span>
            </dt>
            <dd>runs the given callable asynchronously</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename P, typename F&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a333a76d63e50f3ddfbea60c4356b86f3" class="m-doc">async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; f) -&gt; auto</span>
            </dt>
            <dd>runs the given callable asynchronously</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename F&gt;</div>
              <span class="m-doc-wrap-bumper">void <a href="#a0ce29efa2106c8c5a1432e4a55ab2e05" class="m-doc">silent_async</a>(</span><span class="m-doc-wrap">F&amp;&amp; f)</span>
            </dt>
            <dd>runs the given function asynchronously without returning any future object</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename P, typename F&gt;</div>
              <span class="m-doc-wrap-bumper">void <a href="#a532d8cd09ebee59023e3ad65f3220f4e" class="m-doc">silent_async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; f)</span>
            </dt>
            <dd>runs the given function asynchronously without returning any future object</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename F, typename... Tasks, std::enable_if_t&lt;all_same_v&lt;<a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>, std::decay_t&lt;Tasks&gt;...&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a1b89026b619e145c7e2c5c223a0adfc7" class="m-doc">silent_dependent_async</a>(</span><span class="m-doc-wrap">F&amp;&amp; func,
              Tasks &amp;&amp; ... tasks) -&gt; <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a></span>
            </dt>
            <dd>runs the given function asynchronously when the given predecessors finish</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename P, typename F, typename... Tasks, std::enable_if_t&lt;<a href="namespacetf.html#ad3a41adc2499a9519da3e77dc3e9849c" class="m-doc">is_<wbr />task_<wbr />params_<wbr />v</a>&lt;P&gt; &amp;&amp; all_same_v&lt;<a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>, std::decay_t&lt;Tasks&gt;...&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#abc1a77a8896529a8dea6f86997ea10e5" class="m-doc">silent_dependent_async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; func,
              Tasks &amp;&amp; ... tasks) -&gt; <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a></span>
            </dt>
            <dd>runs the given function asynchronously when the given predecessors finish</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename F, typename I, std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;I&gt;, <a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a3e5e2347c6ec2f29be72aaaf4c75391e" class="m-doc">silent_dependent_async</a>(</span><span class="m-doc-wrap">F&amp;&amp; func,
              I first,
              I last) -&gt; <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a></span>
            </dt>
            <dd>runs the given function asynchronously when the given range of predecessors finish</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename P, typename F, typename I, std::enable_if_t&lt;<a href="namespacetf.html#ad3a41adc2499a9519da3e77dc3e9849c" class="m-doc">is_<wbr />task_<wbr />params_<wbr />v</a>&lt;P&gt; &amp;&amp; !std::is_same_v&lt;std::decay_t&lt;I&gt;, <a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a29472635df52420e3be81ae19976a687" class="m-doc">silent_dependent_async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; func,
              I first,
              I last) -&gt; <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a></span>
            </dt>
            <dd>runs the given function asynchronously when the given range of predecessors finish</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename F, typename... Tasks, std::enable_if_t&lt;all_same_v&lt;<a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>, std::decay_t&lt;Tasks&gt;...&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a42e87733508e3610d34728a38e975177" class="m-doc">dependent_async</a>(</span><span class="m-doc-wrap">F&amp;&amp; func,
              Tasks &amp;&amp; ... tasks) -&gt; auto</span>
            </dt>
            <dd>runs the given function asynchronously when the given predecessors finish</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename P, typename F, typename... Tasks, std::enable_if_t&lt;<a href="namespacetf.html#ad3a41adc2499a9519da3e77dc3e9849c" class="m-doc">is_<wbr />task_<wbr />params_<wbr />v</a>&lt;P&gt; &amp;&amp; all_same_v&lt;<a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>, std::decay_t&lt;Tasks&gt;...&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a033e68b47cecca58c59ee550274ceb6f" class="m-doc">dependent_async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; func,
              Tasks &amp;&amp; ... tasks) -&gt; auto</span>
            </dt>
            <dd>runs the given function asynchronously when the given predecessors finish</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename F, typename I, std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;I&gt;, <a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a7cd6502c12443a04f39d6ec139adff42" class="m-doc">dependent_async</a>(</span><span class="m-doc-wrap">F&amp;&amp; func,
              I first,
              I last) -&gt; auto</span>
            </dt>
            <dd>runs the given function asynchronously when the given range of predecessors finish</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename P, typename F, typename I, std::enable_if_t&lt;<a href="namespacetf.html#ad3a41adc2499a9519da3e77dc3e9849c" class="m-doc">is_<wbr />task_<wbr />params_<wbr />v</a>&lt;P&gt; &amp;&amp; !std::is_same_v&lt;std::decay_t&lt;I&gt;, <a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a5386a0f3a4460f8a471d76be2ea36f11" class="m-doc">dependent_async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; func,
              I first,
              I last) -&gt; auto</span>
            </dt>
            <dd>runs the given function asynchronously when the given range of predecessors finish</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#aba54a7cacffb54f5eb133730d256a7c4" class="m-doc">corun</a>(</span><span class="m-doc-wrap">)</span>
            </dt>
            <dd>corun all tasks spawned by this runtime with other workers</dd>
            <dt id="afcc18484a95fd2a834940d878eaf4dfc">
              <span class="m-doc-wrap-bumper">void <a href="#afcc18484a95fd2a834940d878eaf4dfc" class="m-doc-self">corun_all</a>(</span><span class="m-doc-wrap">)</span>
            </dt>
            <dd>equivalent to <a href="#aba54a7cacffb54f5eb133730d256a7c4" class="m-doc">tf::<wbr />Runtime::<wbr />corun</a> - just an alias for legacy purpose</dd>
            <dt id="a20d9756a7aa6b58d0d04437818c10066">
              <span class="m-doc-wrap-bumper">auto <a href="#a20d9756a7aa6b58d0d04437818c10066" class="m-doc-self">is_cancelled</a>(</span><span class="m-doc-wrap">) -&gt; bool</span>
            </dt>
            <dd>This method verifies if the task has been cancelled.</dd>
          </dl>
        </section>
        <section>
          <h2>Function documentation</h2>
          <section class="m-doc-details" id="a4ee48a82df1f9758a999d18e6015cec4"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Executor.html" class="m-doc">Executor</a>&amp; tf::<wbr />Runtime::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a4ee48a82df1f9758a999d18e6015cec4" class="m-doc-self">executor</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>obtains the running executor</p>
<p>The running executor of a runtime task is the executor that runs the parent taskflow of that runtime task.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Executor</span><span class="w"> </span><span class="n">executor</span><span class="p">;</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Taskflow</span><span class="w"> </span><span class="n">taskflow</span><span class="p">;</span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">Runtime</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rt</span><span class="p">){</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">rt</span><span class="p">.</span><span class="n">executor</span><span class="p">())</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">&amp;</span><span class="n">executor</span><span class="p">);</span>
<span class="p">});</span>
<span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span></pre>
          </div></section>
          <section class="m-doc-details" id="aa7e72cc0f298475195b252c8f1793343"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void tf::<wbr />Runtime::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#aa7e72cc0f298475195b252c8f1793343" class="m-doc-self">schedule</a>(</span><span class="m-doc-wrap"><a href="classtf_1_1Task.html" class="m-doc">Task</a> task)</span></span>
            </h3>
            <p>schedules an active task immediately to the worker&#x27;s queue</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">task</td>
                  <td>the given active task to schedule immediately</td>
                </tr>
              </tbody>
            </table>
<p>This member function immediately schedules an active task to the task queue of the associated worker in the runtime task. An active task is a task in a running taskflow. The task may or may not be running, and scheduling that task will immediately put the task into the task queue of the worker that is running the runtime task. Consider the following example:</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Task</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">[</span><span class="o">&amp;</span><span class="n">C</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="n">tf</span><span class="o">::</span><span class="n">Runtime</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rt</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// C must be captured by reference</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="n">rt</span><span class="p">.</span><span class="n">schedule</span><span class="p">(</span><span class="n">C</span><span class="p">);</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;C</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="p">[]</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;D</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">);</span>
<span class="n">A</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">);</span>
<span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span></pre><p>The executor will first run the condition task <code>A</code> which returns <code>0</code> to inform the scheduler to go to the runtime task <code>B</code>. During the execution of <code>B</code>, it directly schedules task <code>C</code> without going through the normal taskflow graph scheduling process. At this moment, task <code>C</code> is active because its parent taskflow is running. When the taskflow finishes, we will see both <code>B</code> and <code>C</code> in the output.</p><aside class="m-note m-warning"><h4>Attention</h4><p>This method can only be called by the parent worker of this runtime, or the behavior is undefined. Furthermore, we currently do not support scheduling a runtime task.</p></aside>
          </div></section>
          <section class="m-doc-details" id="a5688b13034f179c4a8b2b0ebbb215051"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename F&gt;
              </div>
              <span class="m-doc-wrap-bumper">auto tf::<wbr />Runtime::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a5688b13034f179c4a8b2b0ebbb215051" class="m-doc-self">async</a>(</span><span class="m-doc-wrap">F&amp;&amp; f)</span></span>
            </h3>
            <p>runs the given callable asynchronously</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">F</td>
                  <td>callable type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>f</td>
                  <td>callable object</td>
                </tr>
              </tbody>
            </table>
<p>This method creates an asynchronous task that executes the given function with the specified arguments. Unlike <a href="classtf_1_1Executor.html#af960048056f7c6b5bc71f4f526f05df7" class="m-doc">tf::<wbr />Executor::<wbr />async</a>, the task created here is bound to the runtime object and is implicitly synchronized at the end of the runtime&#x27;s scope. Applications may also call <a href="#aba54a7cacffb54f5eb133730d256a7c4" class="m-doc">tf::<wbr />Runtime::<wbr />corun</a> explicitly to wait for all asynchronous tasks spawned from the runtime to complete. For example:</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">counter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">Runtime</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rt</span><span class="p">){</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">fu1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt</span><span class="p">.</span><span class="n">async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span><span class="w"> </span><span class="n">counter</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">fu2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt</span><span class="p">.</span><span class="n">async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span><span class="w"> </span><span class="n">counter</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="n">fu1</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="w">  </span><span class="n">fu2</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// spawn 100 asynchronous tasks from the worker of the runtime</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span><span class="w"> </span><span class="n">counter</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// explicitly wait for the 100 asynchronous tasks to finish</span>
<span class="w">  </span><span class="n">rt</span><span class="p">.</span><span class="n">corun</span><span class="p">();</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">102</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// do something else afterwards ...</span>
<span class="p">});</span></pre>
          </div></section>
          <section class="m-doc-details" id="a333a76d63e50f3ddfbea60c4356b86f3"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename P, typename F&gt;
              </div>
              <span class="m-doc-wrap-bumper">auto tf::<wbr />Runtime::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a333a76d63e50f3ddfbea60c4356b86f3" class="m-doc-self">async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; f)</span></span>
            </h3>
            <p>runs the given callable asynchronously</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">P</td>
                  <td>task parameters type</td>
                </tr>
                <tr>
                  <td>F</td>
                  <td>callable type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>params</td>
                  <td>task parameters</td>
                </tr>
                <tr>
                  <td>f</td>
                  <td>callable</td>
                </tr>
              </tbody>
            </table>
<p>Similar to <a href="#a5688b13034f179c4a8b2b0ebbb215051" class="m-doc">tf::<wbr />Runtime::<wbr />async</a>, but takes a parameter of type <a href="classtf_1_1TaskParams.html" class="m-doc">tf::<wbr />TaskParams</a> to initialize the created asynchronous task.</p><pre class="m-code"><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">Runtime</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rt</span><span class="p">){</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">future</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt</span><span class="p">.</span><span class="n">async</span><span class="p">(</span><span class="s">&quot;my task&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){});</span>
<span class="w">  </span><span class="n">future</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="p">});</span></pre>
          </div></section>
          <section class="m-doc-details" id="a0ce29efa2106c8c5a1432e4a55ab2e05"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename F&gt;
              </div>
              <span class="m-doc-wrap-bumper">void tf::<wbr />Runtime::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a0ce29efa2106c8c5a1432e4a55ab2e05" class="m-doc-self">silent_async</a>(</span><span class="m-doc-wrap">F&amp;&amp; f)</span></span>
            </h3>
            <p>runs the given function asynchronously without returning any future object</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">F</td>
                  <td>callable type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>f</td>
                  <td>callable</td>
                </tr>
              </tbody>
            </table>
<p>This function is more efficient than <a href="#a5688b13034f179c4a8b2b0ebbb215051" class="m-doc">tf::<wbr />Runtime::<wbr />async</a> and is recommended when the result of the asynchronous task does not need to be accessed via a <a href="http://en.cppreference.com/w/cpp/thread/future.html" class="m-doc-external">std::<wbr />future</a>.</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">counter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">Runtime</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rt</span><span class="p">){</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span><span class="w"> </span><span class="n">counter</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">rt</span><span class="p">.</span><span class="n">corun</span><span class="p">();</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span>
<span class="p">});</span></pre><p>This member function is thread-safe.</p>
          </div></section>
          <section class="m-doc-details" id="a532d8cd09ebee59023e3ad65f3220f4e"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename P, typename F&gt;
              </div>
              <span class="m-doc-wrap-bumper">void tf::<wbr />Runtime::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a532d8cd09ebee59023e3ad65f3220f4e" class="m-doc-self">silent_async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; f)</span></span>
            </h3>
            <p>runs the given function asynchronously without returning any future object</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">F</td>
                  <td>callable type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>params</td>
                  <td>task parameters</td>
                </tr>
                <tr>
                  <td>f</td>
                  <td>callable</td>
                </tr>
              </tbody>
            </table>
<p>Similar to <a href="#a0ce29efa2106c8c5a1432e4a55ab2e05" class="m-doc">tf::<wbr />Runtime::<wbr />silent_async</a>, but takes a parameter of type <a href="classtf_1_1TaskParams.html" class="m-doc">tf::<wbr />TaskParams</a> to initialize the created asynchronous task.</p><pre class="m-code"><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">Runtime</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rt</span><span class="p">){</span>
<span class="w">  </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_async</span><span class="p">(</span><span class="s">&quot;my task&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){});</span>
<span class="p">});</span></pre>
          </div></section>
          <section class="m-doc-details" id="a1b89026b619e145c7e2c5c223a0adfc7"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename F, typename... Tasks, std::enable_if_t&lt;all_same_v&lt;<a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>, std::decay_t&lt;Tasks&gt;...&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> tf::<wbr />Runtime::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a1b89026b619e145c7e2c5c223a0adfc7" class="m-doc-self">silent_dependent_async</a>(</span><span class="m-doc-wrap">F&amp;&amp; func,
              Tasks &amp;&amp; ... tasks)</span></span>
            </h3>
            <p>runs the given function asynchronously when the given predecessors finish</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">F</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>Tasks</td>
                  <td>task types convertible to <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a></td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>func</td>
                  <td>callable object</td>
                </tr>
                <tr>
                  <td>tasks</td>
                  <td>asynchronous tasks on which this execution depends</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>This member function is more efficient than <a href="#a42e87733508e3610d34728a38e975177" class="m-doc">tf::<wbr />Runtime::<wbr />dependent_async</a> and is encouraged to use when you do not want a <a href="https://en.cppreference.com/w/cpp/thread/future">std::<wbr />future</a> to acquire the result or synchronize the execution. The example below creates three asynchronous tasks, <code>A</code>, <code>B</code>, and <code>C</code>, in which task <code>C</code> runs after task <code>A</code> and task <code>B</code>.</p><pre class="m-code"><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](</span><span class="n">tf</span><span class="o">::</span><span class="n">Runtime</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rt</span><span class="p">){</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;A</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C runs after A and B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">);</span>
<span class="p">});</span><span class="w">  </span><span class="c1">// implicit synchronization of all tasks at the end of runtime&#39;s scope</span>
<span class="n">executor</span><span class="p">.</span><span class="n">wait_for_all</span><span class="p">();</span></pre>
          </div></section>
          <section class="m-doc-details" id="abc1a77a8896529a8dea6f86997ea10e5"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename P, typename F, typename... Tasks, std::enable_if_t&lt;<a href="namespacetf.html#ad3a41adc2499a9519da3e77dc3e9849c" class="m-doc">is_<wbr />task_<wbr />params_<wbr />v</a>&lt;P&gt; &amp;&amp; all_same_v&lt;<a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>, std::decay_t&lt;Tasks&gt;...&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> tf::<wbr />Runtime::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#abc1a77a8896529a8dea6f86997ea10e5" class="m-doc-self">silent_dependent_async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; func,
              Tasks &amp;&amp; ... tasks)</span></span>
            </h3>
            <p>runs the given function asynchronously when the given predecessors finish</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">F</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>Tasks</td>
                  <td>task types convertible to <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a></td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>params</td>
                  <td>task parameters</td>
                </tr>
                <tr>
                  <td>func</td>
                  <td>callable object</td>
                </tr>
                <tr>
                  <td>tasks</td>
                  <td>asynchronous tasks on which this execution depends</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>This member function is more efficient than <a href="#a42e87733508e3610d34728a38e975177" class="m-doc">tf::<wbr />Runtime::<wbr />dependent_async</a> and is encouraged to use when you do not want a <a href="https://en.cppreference.com/w/cpp/thread/future">std::<wbr />future</a> to acquire the result or synchronize the execution. The example below creates three asynchronous tasks, <code>A</code>, <code>B</code>, and <code>C</code>, in which task <code>C</code> runs after task <code>A</code> and task <code>B</code>. Assigned task names will appear in the observers of the executor.</p><pre class="m-code"><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](</span><span class="n">tf</span><span class="o">::</span><span class="n">Runtime</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rt</span><span class="p">){</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;A</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;C&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C runs after A and B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">});</span><span class="w">  </span><span class="c1">// implicit synchronization of all tasks at the end of runtime&#39;s scope</span>
<span class="n">executor</span><span class="p">.</span><span class="n">wait_for_all</span><span class="p">();</span></pre><p>This member function is thread-safe.</p>
          </div></section>
          <section class="m-doc-details" id="a3e5e2347c6ec2f29be72aaaf4c75391e"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename F, typename I, std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;I&gt;, <a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> tf::<wbr />Runtime::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a3e5e2347c6ec2f29be72aaaf4c75391e" class="m-doc-self">silent_dependent_async</a>(</span><span class="m-doc-wrap">F&amp;&amp; func,
              I first,
              I last)</span></span>
            </h3>
            <p>runs the given function asynchronously when the given range of predecessors finish</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">F</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>I</td>
                  <td>iterator type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>func</td>
                  <td>callable object</td>
                </tr>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>This member function is more efficient than <a href="#a42e87733508e3610d34728a38e975177" class="m-doc">tf::<wbr />Runtime::<wbr />dependent_async</a> and is encouraged to use when you do not want a <a href="https://en.cppreference.com/w/cpp/thread/future">std::<wbr />future</a> to acquire the result or synchronize the execution. The example below creates three asynchronous tasks, <code>A</code>, <code>B</code>, and <code>C</code>, in which task <code>C</code> runs after task <code>A</code> and task <code>B</code>.</p><pre class="m-code"><span class="n">Taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">Runtime</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rt</span><span class="p">){</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;A</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}),</span>
<span class="w">    </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">})</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span>
<span class="w">    </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C runs after A and B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">end</span><span class="p">()</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">});</span><span class="w">  </span><span class="c1">// implicit synchronization of all tasks at the end of runtime&#39;s scope</span>
<span class="n">executor</span><span class="p">.</span><span class="n">wait_for_all</span><span class="p">();</span></pre>
          </div></section>
          <section class="m-doc-details" id="a29472635df52420e3be81ae19976a687"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename P, typename F, typename I, std::enable_if_t&lt;<a href="namespacetf.html#ad3a41adc2499a9519da3e77dc3e9849c" class="m-doc">is_<wbr />task_<wbr />params_<wbr />v</a>&lt;P&gt; &amp;&amp; !std::is_same_v&lt;std::decay_t&lt;I&gt;, <a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> tf::<wbr />Runtime::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a29472635df52420e3be81ae19976a687" class="m-doc-self">silent_dependent_async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; func,
              I first,
              I last)</span></span>
            </h3>
            <p>runs the given function asynchronously when the given range of predecessors finish</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">F</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>I</td>
                  <td>iterator type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>params</td>
                  <td>tasks parameters</td>
                </tr>
                <tr>
                  <td>func</td>
                  <td>callable object</td>
                </tr>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>This member function is more efficient than <a href="#a42e87733508e3610d34728a38e975177" class="m-doc">tf::<wbr />Runtime::<wbr />dependent_async</a> and is encouraged to use when you do not want a <a href="https://en.cppreference.com/w/cpp/thread/future">std::<wbr />future</a> to acquire the result or synchronize the execution. The example below creates three asynchronous tasks, <code>A</code>, <code>B</code>, and <code>C</code>, in which task <code>C</code> runs after task <code>A</code> and task <code>B</code>. Assigned task names will appear in the observers of the executor.</p><pre class="m-code"><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](</span><span class="n">tf</span><span class="o">::</span><span class="n">Runtime</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rt</span><span class="p">){</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;A</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}),</span>
<span class="w">    </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">})</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;C&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C runs after A and B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">end</span><span class="p">()</span>
<span class="w">  </span><span class="p">);</span>
<span class="p">});</span><span class="w">  </span><span class="c1">// implicit synchronization of all tasks at the end of runtime&#39;s scope</span>
<span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span></pre>
          </div></section>
          <section class="m-doc-details" id="a42e87733508e3610d34728a38e975177"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename F, typename... Tasks, std::enable_if_t&lt;all_same_v&lt;<a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>, std::decay_t&lt;Tasks&gt;...&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper">auto tf::<wbr />Runtime::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a42e87733508e3610d34728a38e975177" class="m-doc-self">dependent_async</a>(</span><span class="m-doc-wrap">F&amp;&amp; func,
              Tasks &amp;&amp; ... tasks)</span></span>
            </h3>
            <p>runs the given function asynchronously when the given predecessors finish</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">F</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>Tasks</td>
                  <td>task types convertible to <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a></td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>func</td>
                  <td>callable object</td>
                </tr>
                <tr>
                  <td>tasks</td>
                  <td>asynchronous tasks on which this execution depends</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a pair of a <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle and a <a href="https://en.cppreference.com/w/cpp/thread/future">std::<wbr />future</a> that holds the result of the execution</td>
                </tr>
              </tfoot>
            </table>
<p>The example below creates three asynchronous tasks, <code>A</code>, <code>B</code>, and <code>C</code>, in which task <code>C</code> runs after task <code>A</code> and task <code>B</code>. <a href="classtf_1_1Task.html" class="m-doc">Task</a> <code>C</code> returns a pair of its <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle and a std::future&lt;int&gt; that eventually will hold the result of the execution.</p><pre class="m-code"><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](</span><span class="n">tf</span><span class="o">::</span><span class="n">Runtime</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rt</span><span class="p">){</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;A</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">fuC</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt</span><span class="p">.</span><span class="n">dependent_async</span><span class="p">(</span>
<span class="w">    </span><span class="p">[](){</span><span class="w"> </span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C runs after A and B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span>
<span class="w">    </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="n">fuC</span><span class="p">.</span><span class="n">get</span><span class="p">();</span><span class="w">  </span><span class="c1">// C finishes, which in turns means both A and B finish</span>
<span class="p">});</span><span class="w">  </span><span class="c1">// implicit synchronization of all tasks at the end of runtime&#39;s scope</span>
<span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span></pre><p>You can mix the use of <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handles returned by <a href="#a42e87733508e3610d34728a38e975177" class="m-doc">tf::<wbr />Runtime::<wbr />dependent_async</a> and <a href="#a1b89026b619e145c7e2c5c223a0adfc7" class="m-doc">tf::<wbr />Runtime::<wbr />silent_dependent_async</a> when specifying task dependencies.</p>
          </div></section>
          <section class="m-doc-details" id="a033e68b47cecca58c59ee550274ceb6f"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename P, typename F, typename... Tasks, std::enable_if_t&lt;<a href="namespacetf.html#ad3a41adc2499a9519da3e77dc3e9849c" class="m-doc">is_<wbr />task_<wbr />params_<wbr />v</a>&lt;P&gt; &amp;&amp; all_same_v&lt;<a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>, std::decay_t&lt;Tasks&gt;...&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper">auto tf::<wbr />Runtime::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a033e68b47cecca58c59ee550274ceb6f" class="m-doc-self">dependent_async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; func,
              Tasks &amp;&amp; ... tasks)</span></span>
            </h3>
            <p>runs the given function asynchronously when the given predecessors finish</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">P</td>
                  <td>task parameters type</td>
                </tr>
                <tr>
                  <td>F</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>Tasks</td>
                  <td>task types convertible to <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a></td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>params</td>
                  <td>task parameters</td>
                </tr>
                <tr>
                  <td>func</td>
                  <td>callable object</td>
                </tr>
                <tr>
                  <td>tasks</td>
                  <td>asynchronous tasks on which this execution depends</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a pair of a <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle and a <a href="https://en.cppreference.com/w/cpp/thread/future">std::<wbr />future</a> that holds the result of the execution</td>
                </tr>
              </tfoot>
            </table>
<p>The example below creates three named asynchronous tasks, <code>A</code>, <code>B</code>, and <code>C</code>, in which task <code>C</code> runs after task <code>A</code> and task <code>B</code>. <a href="classtf_1_1Task.html" class="m-doc">Task</a> <code>C</code> returns a pair of its <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle and a std::future&lt;int&gt; that eventually will hold the result of the execution. Assigned task names will appear in the observers of the executor.</p><pre class="m-code"><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](</span><span class="n">tf</span><span class="o">::</span><span class="n">Runtime</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rt</span><span class="p">){</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;A</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">fuC</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt</span><span class="p">.</span><span class="n">dependent_async</span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;C&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[](){</span><span class="w"> </span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C runs after A and B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span>
<span class="w">    </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">fuC</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">==</span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// C finishes, which in turns means both A and B finish</span>
<span class="p">});</span><span class="w">  </span><span class="c1">// implicit synchronization of all tasks at the end of runtime&#39;s scope</span>
<span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span></pre><p>You can mix the use of <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handles returned by <a href="#a42e87733508e3610d34728a38e975177" class="m-doc">tf::<wbr />Runtime::<wbr />dependent_async</a> and <a href="#a1b89026b619e145c7e2c5c223a0adfc7" class="m-doc">tf::<wbr />Runtime::<wbr />silent_dependent_async</a> when specifying task dependencies.</p>
          </div></section>
          <section class="m-doc-details" id="a7cd6502c12443a04f39d6ec139adff42"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename F, typename I, std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;I&gt;, <a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper">auto tf::<wbr />Runtime::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a7cd6502c12443a04f39d6ec139adff42" class="m-doc-self">dependent_async</a>(</span><span class="m-doc-wrap">F&amp;&amp; func,
              I first,
              I last)</span></span>
            </h3>
            <p>runs the given function asynchronously when the given range of predecessors finish</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">F</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>I</td>
                  <td>iterator type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>func</td>
                  <td>callable object</td>
                </tr>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a pair of a <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle and a <a href="https://en.cppreference.com/w/cpp/thread/future">std::<wbr />future</a> that holds the result of the execution</td>
                </tr>
              </tfoot>
            </table>
<p>The example below creates three asynchronous tasks, <code>A</code>, <code>B</code>, and <code>C</code>, in which task <code>C</code> runs after task <code>A</code> and task <code>B</code>. <a href="classtf_1_1Task.html" class="m-doc">Task</a> <code>C</code> returns a pair of its <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle and a std::future&lt;int&gt; that eventually will hold the result of the execution.</p><pre class="m-code"><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](</span><span class="n">tf</span><span class="o">::</span><span class="n">Runtime</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rt</span><span class="p">){</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;A</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}),</span>
<span class="w">    </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">})</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">fuC</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt</span><span class="p">.</span><span class="n">dependent_async</span><span class="p">(</span>
<span class="w">    </span><span class="p">[](){</span><span class="w"> </span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C runs after A and B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span>
<span class="w">    </span><span class="n">array</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">end</span><span class="p">()</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">fuC</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">==</span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// C finishes, which in turns means both A and B finish</span>
<span class="p">});</span><span class="w">  </span><span class="c1">// implicit synchronization of all tasks at the end of runtime&#39;s scope</span>
<span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span></pre><p>You can mix the use of <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handles returned by <a href="#a42e87733508e3610d34728a38e975177" class="m-doc">tf::<wbr />Runtime::<wbr />dependent_async</a> and rt::Runtime::silent_dependent_async when specifying task dependencies.</p>
          </div></section>
          <section class="m-doc-details" id="a5386a0f3a4460f8a471d76be2ea36f11"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename P, typename F, typename I, std::enable_if_t&lt;<a href="namespacetf.html#ad3a41adc2499a9519da3e77dc3e9849c" class="m-doc">is_<wbr />task_<wbr />params_<wbr />v</a>&lt;P&gt; &amp;&amp; !std::is_same_v&lt;std::decay_t&lt;I&gt;, <a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper">auto tf::<wbr />Runtime::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a5386a0f3a4460f8a471d76be2ea36f11" class="m-doc-self">dependent_async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; func,
              I first,
              I last)</span></span>
            </h3>
            <p>runs the given function asynchronously when the given range of predecessors finish</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">P</td>
                  <td>task parameters type</td>
                </tr>
                <tr>
                  <td>F</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>I</td>
                  <td>iterator type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>params</td>
                  <td>task parameters</td>
                </tr>
                <tr>
                  <td>func</td>
                  <td>callable object</td>
                </tr>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a pair of a <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle and a <a href="https://en.cppreference.com/w/cpp/thread/future">std::<wbr />future</a> that holds the result of the execution</td>
                </tr>
              </tfoot>
            </table>
<p>The example below creates three named asynchronous tasks, <code>A</code>, <code>B</code>, and <code>C</code>, in which task <code>C</code> runs after task <code>A</code> and task <code>B</code>. <a href="classtf_1_1Task.html" class="m-doc">Task</a> <code>C</code> returns a pair of its <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle and a std::future&lt;int&gt; that eventually will hold the result of the execution. Assigned task names will appear in the observers of the executor.</p><pre class="m-code"><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([](</span><span class="n">tf</span><span class="o">::</span><span class="n">Runtime</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rt</span><span class="p">){</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;A</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}),</span>
<span class="w">    </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">})</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">fuC</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rt</span><span class="p">.</span><span class="n">dependent_async</span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;C&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[](){</span><span class="w"> </span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C runs after A and B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span>
<span class="w">    </span><span class="n">array</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">end</span><span class="p">()</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">fuC</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="o">==</span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// C finishes, which in turns means both A and B finish</span>
<span class="p">});</span><span class="w">  </span><span class="c1">// implicit synchronization of all tasks at the end of runtime&#39;s scope</span>
<span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span></pre><p>You can mix the use of <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handles returned by <a href="#a42e87733508e3610d34728a38e975177" class="m-doc">tf::<wbr />Runtime::<wbr />dependent_async</a> and <a href="#a1b89026b619e145c7e2c5c223a0adfc7" class="m-doc">tf::<wbr />Runtime::<wbr />silent_dependent_async</a> when specifying task dependencies.</p>
          </div></section>
          <section class="m-doc-details" id="aba54a7cacffb54f5eb133730d256a7c4"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void tf::<wbr />Runtime::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#aba54a7cacffb54f5eb133730d256a7c4" class="m-doc-self">corun</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>corun all tasks spawned by this runtime with other workers</p>
<p>Coruns all tasks spawned by this runtime cooperatively with other workers in the same executor until all these tasks finish. Under cooperative execution, a worker is not preempted. Instead, it continues participating in the work-stealing loop, executing available tasks alongside other workers.<br /></p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">counter</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">Runtime</span><span class="o">&amp;</span><span class="w"> </span><span class="n">rt</span><span class="p">){</span>
<span class="w">  </span><span class="c1">// spawn 100 async tasks and wait</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span><span class="w"> </span><span class="n">counter</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">rt</span><span class="p">.</span><span class="n">corun</span><span class="p">();</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// spawn another 100 async tasks and wait</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">rt</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span><span class="w"> </span><span class="n">counter</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">rt</span><span class="p">.</span><span class="n">corun</span><span class="p">();</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">200</span><span class="p">);</span>
<span class="p">});</span></pre><aside class="m-note m-warning"><h4>Attention</h4><p>This method can only be called by the parent worker of this runtime, or the behavior is undefined.</p></aside>
          </div></section>
        </section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim"></span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim"></span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v2.js"></script>
<script src="searchdata-v2.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Taskflow handbook is part of the <a href="https://taskflow.github.io">Taskflow project</a>, copyright  <a href="https://tsung-wei-huang.github.io/">Dr. Tsung-Wei Huang</a>, 2018&ndash;2025.<br />Generated by <a href="https://doxygen.org/">Doxygen</a> 1.9.1 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
