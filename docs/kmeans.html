<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Learning from Examples &raquo; k-means Clustering | Taskflow QuickStart</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark+documentation.compiled.css" />
  <link rel="icon" href="favicon.ico" type="image/x-icon" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <span id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">
        <a href="https://taskflow.github.io"><img src="taskflow_logo.png" alt="" />Taskflow</a> <span class="m-breadcrumb">|</span> <a href="index.html" class="m-thin">QuickStart</a>
      </span>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="pages.html">Handbook</a></li>
            <li><a href="namespaces.html">Namespaces</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          <span class="m-breadcrumb"><a href="Examples.html">Learning from Examples</a> &raquo;</span>
          k-means Clustering
        </h1>
        <div class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li><a href="#KMeansProblemFormulation">Problem Formulation</a></li>
            <li><a href="#ParallelKMeansUsingCPUs">Parallel k-means using CPUs</a></li>
            <li><a href="#ParallelKMeansUsingGPUs">Parallel k-means using GPUs</a></li>
            <li><a href="#BuiltInPredicate">Built-in Predicate</a></li>
            <li><a href="#KMeansBenchmarking">Benchmarking</a></li>
          </ul>
        </div>
<p>We study a fundamental clustering problem in unsupervised learning, <em>k-means clustering</em>. We will begin by discussing the problem formulation and then learn how to write a parallel k-means algorithm.</p><section id="KMeansProblemFormulation"><h2><a href="#KMeansProblemFormulation">Problem Formulation</a></h2><p>k-means clustering uses <em>centroids</em>, k different randomly-initiated points in the data, and assigns every data point to the nearest centroid. After every point has been assigned, the centroid is moved to the average of all of the points assigned to it. We describe the k-means algorithm in the following steps:</p><ul><li>Step 1: initialize k random centroids</li><li>Step 2: for every data point, find the nearest centroid (L2 distance or other measurements) and assign the point to it</li><li>Step 3: for every centroid, move the centroid to the average of the points assigned to that centroid</li><li>Step 4: go to Step 2 until converged (no more changes in the last few iterations) or maximum iterations reached</li></ul><p>The algorithm is illustrated as follows:</p><img class="m-image" src="kmeans_1.png" alt="Image" /><p>A sequential implementation of k-means is described as follows:</p><pre class="m-code"><span class="c1">// sequential implementation of k-means on a CPU</span>
<span class="c1">// N: number of points</span>
<span class="c1">// K: number of clusters</span>
<span class="c1">// M: number of iterations</span>
<span class="c1">// px/py: 2D point vector </span>
<span class="kt">void</span> <span class="nf">kmeans_seq</span><span class="p">(</span>
  <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="p">,</span> <span class="kt">int</span> <span class="n">M</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">px</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">py</span>
<span class="p">)</span> <span class="p">{</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">(</span><span class="n">K</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">sx</span><span class="p">(</span><span class="n">K</span><span class="p">),</span> <span class="n">sy</span><span class="p">(</span><span class="n">K</span><span class="p">),</span> <span class="n">mx</span><span class="p">(</span><span class="n">K</span><span class="p">),</span> <span class="n">my</span><span class="p">(</span><span class="n">K</span><span class="p">);</span>

  <span class="c1">// initial centroids</span>
  <span class="n">std</span><span class="o">::</span><span class="n">copy_n</span><span class="p">(</span><span class="n">px</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">K</span><span class="p">,</span> <span class="n">mx</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
  <span class="n">std</span><span class="o">::</span><span class="n">copy_n</span><span class="p">(</span><span class="n">py</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">K</span><span class="p">,</span> <span class="n">my</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
  
  <span class="c1">// k-means iteration</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">m</span><span class="o">&lt;</span><span class="n">M</span><span class="p">;</span> <span class="n">m</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

    <span class="c1">// clear the storage</span>
    <span class="n">std</span><span class="o">::</span><span class="n">fill_n</span><span class="p">(</span><span class="n">sx</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">K</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">fill_n</span><span class="p">(</span><span class="n">sy</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">K</span><span class="p">,</span> <span class="mf">0.0f</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">fill_n</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">K</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="c1">// find the best k (cluster id) for each point</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">px</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">py</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="kt">float</span> <span class="n">best_d</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
      <span class="kt">int</span> <span class="n">best_k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">float</span> <span class="n">d</span> <span class="o">=</span> <span class="n">L2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mx</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">my</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">best_d</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">best_d</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
          <span class="n">best_k</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="n">sx</span><span class="p">[</span><span class="n">best_k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">x</span><span class="p">;</span>
      <span class="n">sy</span><span class="p">[</span><span class="n">best_k</span><span class="p">]</span> <span class="o">+=</span> <span class="n">y</span><span class="p">;</span>
      <span class="n">c</span> <span class="p">[</span><span class="n">best_k</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// update the centroid</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">K</span><span class="p">;</span> <span class="n">k</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>  <span class="c1">// turn 0/0 to 0/1</span>
      <span class="n">mx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">count</span><span class="p">;</span>
      <span class="n">my</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sy</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// print the k centroids found</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">K</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;centroid &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">k</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">mx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span>
                                          <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">my</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span></pre></section><section id="ParallelKMeansUsingCPUs"><h2><a href="#ParallelKMeansUsingCPUs">Parallel k-means using CPUs</a></h2><p>The second step of k-means algorithm, <em>assigning every point to the nearest centroid</em>, is highly parallelizable across individual points. We can create a <em>parallel-for</em> task to run parallel iterations.</p><pre class="m-code"><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">best_ks</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>  <span class="c1">// nearest centroid of each point</span>

<span class="kt">unsigned</span> <span class="n">P</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>  <span class="c1">// 12 partitioned tasks</span>

<span class="c1">// update cluster</span>
<span class="n">taskflow</span><span class="p">.</span><span class="n">parallel_for</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
  <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">px</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">py</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="kt">float</span> <span class="n">best_d</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">best_k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">float</span> <span class="n">d</span> <span class="o">=</span> <span class="n">L2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mx</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">my</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">best_d</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">best_d</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
      <span class="n">best_k</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">best_ks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_k</span><span class="p">;</span>
<span class="p">});</span></pre><p>The third step of moving every centroid to the average of points is also parallelizable across individual centroids. However, since k is typically not large, one task of doing this update is sufficient.</p><pre class="m-code"><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
  <span class="c1">// sum of points</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sx</span><span class="p">[</span><span class="n">best_ks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">px</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">sy</span><span class="p">[</span><span class="n">best_ks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">py</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">c</span> <span class="p">[</span><span class="n">best_ks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="c1">// average of points</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">K</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">count</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>  <span class="c1">// turn 0/0 to 0/1</span>
    <span class="n">mx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">count</span><span class="p">;</span>
    <span class="n">my</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sy</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">count</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">});</span></pre><p>To describe <code>M</code> iterations, we create a condition task that loops the second step of the algorithm by <code>M</code> times. The return value of zero goes to the first successor which we will connect to the task of the second step later; otherwise, k-means completes.</p><pre class="m-code"><span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="p">]()</span> <span class="k">mutable</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">m</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">});</span></pre><p>The entire code of CPU-parallel k-means is shown below. Here we use an additional storage, <code>best_ks</code>, to record the nearest centroid of a point at an iteration.</p><pre class="m-code"><span class="c1">// N: number of points</span>
<span class="c1">// K: number of clusters</span>
<span class="c1">// M: number of iterations</span>
<span class="c1">// px/py: 2D point vector </span>
<span class="kt">void</span> <span class="nf">kmeans_par</span><span class="p">(</span>
  <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="p">,</span> <span class="kt">int</span> <span class="n">M</span><span class="p">,</span> <span class="n">cconst</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">px</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">py</span>
<span class="p">)</span> <span class="p">{</span>

  <span class="kt">unsigned</span> <span class="n">P</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>  <span class="c1">// 12 partitions of the parallel-for graph</span>

  <span class="n">tf</span><span class="o">::</span><span class="n">Executor</span> <span class="n">executor</span><span class="p">;</span>
  <span class="n">tf</span><span class="o">::</span><span class="n">Taskflow</span> <span class="n">taskflow</span><span class="p">(</span><span class="s">&quot;K-Means&quot;</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">c</span><span class="p">(</span><span class="n">K</span><span class="p">),</span> <span class="n">best_ks</span><span class="p">(</span><span class="n">N</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">sx</span><span class="p">(</span><span class="n">K</span><span class="p">),</span> <span class="n">sy</span><span class="p">(</span><span class="n">K</span><span class="p">),</span> <span class="n">mx</span><span class="p">(</span><span class="n">K</span><span class="p">),</span> <span class="n">my</span><span class="p">(</span><span class="n">K</span><span class="p">);</span>

  <span class="c1">// initial centroids</span>
  <span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">init</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">K</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">mx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">px</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="n">my</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">py</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
  <span class="p">}).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;init&quot;</span><span class="p">);</span>

  <span class="c1">// clear the storage</span>
  <span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">clean_up</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">K</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">sx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
      <span class="n">sy</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0f</span><span class="p">;</span>
      <span class="n">c</span> <span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;clean_up&quot;</span><span class="p">);</span>

  <span class="c1">// update cluster</span>
  <span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">pf</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">parallel_for</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">int</span> <span class="n">i</span><span class="p">){</span>
    <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">px</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">py</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="kt">float</span> <span class="n">best_d</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">best_k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">float</span> <span class="n">d</span> <span class="o">=</span> <span class="n">L2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mx</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">my</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">best_d</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">best_d</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
        <span class="n">best_k</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">best_ks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">best_k</span><span class="p">;</span>
  <span class="p">}).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;parallel-for&quot;</span><span class="p">);</span>

  <span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">update_cluster</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">sx</span><span class="p">[</span><span class="n">best_ks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">px</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="n">sy</span><span class="p">[</span><span class="n">best_ks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">py</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="n">c</span> <span class="p">[</span><span class="n">best_ks</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">k</span><span class="o">&lt;</span><span class="n">K</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="n">count</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>  <span class="c1">// turn 0/0 to 0/1</span>
      <span class="n">mx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">count</span><span class="p">;</span>
      <span class="n">my</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sy</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;update_cluster&quot;</span><span class="p">);</span>
  
  <span class="c1">// convergence check</span>
  <span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">condition</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="n">m</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="p">]()</span> <span class="k">mutable</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">m</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;converged?&quot;</span><span class="p">);</span>

  <span class="n">init</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">clean_up</span><span class="p">);</span>

  <span class="n">clean_up</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">pf</span><span class="p">);</span>
  <span class="n">pf</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">update_cluster</span><span class="p">);</span>

  <span class="n">condition</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">clean_up</span><span class="p">)</span>
           <span class="p">.</span><span class="n">succeed</span><span class="p">(</span><span class="n">update_cluster</span><span class="p">);</span>

  <span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span>
<span class="p">}</span></pre><p>The taskflow consists of two parts, a <code>clean_up</code> task and a parallel-for graph. The former cleans up the storage <code>sx</code>, <code>sy</code>, and <code>c</code> that are used to average points for new centroids, and the later parallelizes the searching for nearest centroids across individual points using 12 tasks (may vary depending on the machine). If the iteration count is smaller than <code>M</code>, the condition task returns 0 to let the execution path go back to <code>clean_up</code>. Otherwise, it returns 1 to stop (i.e., no successor tasks at index 1). The taskflow graph is illustrated below:</p><div class="m-graph"><svg style="width: 55.500rem; height: 46.750rem;" viewBox="0.00 0.00 887.79 748.00">
<g transform="scale(1 1) rotate(0) translate(4 744)">
<title>Taskflow</title>
<g class="m-cluster">
<title>cluster_p0x1dcb6e0</title>
<polygon points="8,-8 8,-732 308.9982,-732 308.9982,-8 8,-8"/>
<text text-anchor="middle" x="158.4991" y="-715.2">Subflow: parallel&#45;for</text>
</g>
<g class="m-node m-flat">
<title>p0x1dcb4c0</title>
<ellipse cx="631.7895" cy="-421" rx="27" ry="18"/>
<text text-anchor="middle" x="631.7895" y="-416.2">init</text>
</g>
<g class="m-node m-flat">
<title>p0x1dcb5d0</title>
<ellipse cx="825.4929" cy="-375" rx="54.1003" ry="18"/>
<text text-anchor="middle" x="825.4929" y="-370.2">clean_up</text>
</g>
<g class="m-edge">
<title>p0x1dcb4c0&#45;&gt;p0x1dcb5d0</title>
<path d="M657.5118,-414.8916C686.2967,-408.0558 733.7635,-396.7836 770.91,-387.9621"/>
<polygon points="772.1688,-391.2606 781.0895,-385.5448 770.5514,-384.45 772.1688,-391.2606"/>
</g>
<g class="m-node m-flat">
<title>p0x1dcb6e0</title>
<ellipse cx="239.5605" cy="-358" rx="61.3755" ry="18"/>
<text text-anchor="middle" x="239.5605" y="-353.2">parallel&#45;for</text>
</g>
<g class="m-edge">
<title>p0x1dcb5d0&#45;&gt;p0x1dcb6e0</title>
<path d="M771.0873,-373.4215C664.7934,-370.3375 429.5938,-363.5135 310.953,-360.0714"/>
<polygon points="310.9798,-356.5708 300.8825,-359.7792 310.7767,-363.5678 310.9798,-356.5708"/>
</g>
<g class="m-node m-flat">
<title>p0x1dcb7f0</title>
<ellipse cx="419.1413" cy="-329" rx="81.2864" ry="18"/>
<text text-anchor="middle" x="419.1413" y="-324.2">update_cluster</text>
</g>
<g class="m-edge">
<title>p0x1dcb6e0&#45;&gt;p0x1dcb7f0</title>
<path d="M293.4407,-349.299C309.012,-346.7845 326.3084,-343.9913 342.9649,-341.3015"/>
<polygon points="343.918,-344.693 353.2321,-339.6435 342.802,-337.7826 343.918,-344.693"/>
</g>
<g class="m-node">
<title>p0x1dcb900</title>
<polygon points="631.7895,-347 537.2792,-329 631.7895,-311 726.2998,-329 631.7895,-347"/>
<text text-anchor="middle" x="631.7895" y="-324.2">converged?</text>
</g>
<g class="m-edge">
<title>p0x1dcb7f0&#45;&gt;p0x1dcb900</title>
<path d="M500.4447,-329C509.1339,-329 518.0595,-329 526.971,-329"/>
<polygon points="527.0131,-332.5001 537.0131,-329 527.013,-325.5001 527.0131,-332.5001"/>
</g>
<g class="m-node m-flat">
<title>p0x7fd610000b50</title>
<ellipse cx="59.5614" cy="-682" rx="37.6845" ry="18"/>
<text text-anchor="middle" x="59.5614" y="-677.2">pfg_0</text>
</g>
<g class="m-edge">
<title>p0x7fd610000b50&#45;&gt;p0x1dcb6e0</title>
<path d="M85.8727,-669.105C92.0768,-665.1942 98.2848,-660.4614 103.1228,-655 176.6462,-572.0027 217.4214,-442.6673 232.6048,-386.0912"/>
<polygon points="236.0761,-386.6514 235.2235,-376.0909 229.3044,-384.8781 236.0761,-386.6514"/>
</g>
<g class="m-node m-flat">
<title>p0x7fd610000c60</title>
<ellipse cx="59.5614" cy="-628" rx="37.6845" ry="18"/>
<text text-anchor="middle" x="59.5614" y="-623.2">pfg_1</text>
</g>
<g class="m-edge">
<title>p0x7fd610000c60&#45;&gt;p0x1dcb6e0</title>
<path d="M85.584,-614.839C91.7936,-610.9334 98.0765,-606.2694 103.1228,-601 166.3869,-534.9385 210.6197,-433.9249 229.428,-385.61"/>
<polygon points="232.7499,-386.7221 233.0533,-376.1316 226.2118,-384.2213 232.7499,-386.7221"/>
</g>
<g class="m-node m-flat">
<title>p0x7fd610000d70</title>
<ellipse cx="59.5614" cy="-574" rx="37.6845" ry="18"/>
<text text-anchor="middle" x="59.5614" y="-569.2">pfg_2</text>
</g>
<g class="m-edge">
<title>p0x7fd610000d70&#45;&gt;p0x1dcb6e0</title>
<path d="M85.1805,-560.43C91.3978,-556.5322 97.7853,-551.9743 103.1228,-547 156.343,-497.4009 202.0969,-424.2641 224.6276,-385.1037"/>
<polygon points="227.9512,-386.3388 229.8458,-375.9147 221.8641,-382.8821 227.9512,-386.3388"/>
</g>
<g class="m-node m-flat">
<title>p0x7fd610000e80</title>
<ellipse cx="59.5614" cy="-520" rx="37.6845" ry="18"/>
<text text-anchor="middle" x="59.5614" y="-515.2">pfg_3</text>
</g>
<g class="m-edge">
<title>p0x7fd610000e80&#45;&gt;p0x1dcb6e0</title>
<path d="M84.181,-506.0786C90.545,-502.1238 97.2528,-497.6265 103.1228,-493 146.8999,-458.4965 191.7197,-411.4451 217.5291,-382.9749"/>
<polygon points="220.2009,-385.2383 224.2879,-375.4635 214.9973,-380.5561 220.2009,-385.2383"/>
</g>
<g class="m-node m-flat">
<title>p0x7fd610000f90</title>
<ellipse cx="59.5614" cy="-466" rx="37.6845" ry="18"/>
<text text-anchor="middle" x="59.5614" y="-461.2">pfg_4</text>
</g>
<g class="m-edge">
<title>p0x7fd610000f90&#45;&gt;p0x1dcb6e0</title>
<path d="M83.0931,-451.8809C113.8406,-433.4323 167.9737,-400.9523 203.8067,-379.4524"/>
<polygon points="205.723,-382.3843 212.4972,-374.2381 202.1215,-376.3819 205.723,-382.3843"/>
</g>
<g class="m-node m-flat">
<title>p0x7fd6100010a0</title>
<ellipse cx="59.5614" cy="-412" rx="37.6845" ry="18"/>
<text text-anchor="middle" x="59.5614" y="-407.2">pfg_5</text>
</g>
<g class="m-edge">
<title>p0x7fd6100010a0&#45;&gt;p0x1dcb6e0</title>
<path d="M91.7416,-402.3459C118.1118,-394.4348 155.9665,-383.0783 186.7661,-373.8384"/>
<polygon points="187.922,-377.1458 196.4945,-370.9199 185.9105,-370.441 187.922,-377.1458"/>
</g>
<g class="m-node m-flat">
<title>p0x7fd6100011b0</title>
<ellipse cx="59.5614" cy="-358" rx="37.6845" ry="18"/>
<text text-anchor="middle" x="59.5614" y="-353.2">pfg_6</text>
</g>
<g class="m-edge">
<title>p0x7fd6100011b0&#45;&gt;p0x1dcb6e0</title>
<path d="M97.2951,-358C117.6809,-358 143.5418,-358 167.6074,-358"/>
<polygon points="167.7902,-361.5001 177.7902,-358 167.7901,-354.5001 167.7902,-361.5001"/>
</g>
<g class="m-node m-flat">
<title>p0x7fd6100012c0</title>
<ellipse cx="59.5614" cy="-304" rx="37.6845" ry="18"/>
<text text-anchor="middle" x="59.5614" y="-299.2">pfg_7</text>
</g>
<g class="m-edge">
<title>p0x7fd6100012c0&#45;&gt;p0x1dcb6e0</title>
<path d="M91.7416,-313.6541C118.1118,-321.5652 155.9665,-332.9217 186.7661,-342.1616"/>
<polygon points="185.9105,-345.559 196.4945,-345.0801 187.922,-338.8542 185.9105,-345.559"/>
</g>
<g class="m-node m-flat">
<title>p0x7fd6100013d0</title>
<ellipse cx="59.5614" cy="-250" rx="37.6845" ry="18"/>
<text text-anchor="middle" x="59.5614" y="-245.2">pfg_8</text>
</g>
<g class="m-edge">
<title>p0x7fd6100013d0&#45;&gt;p0x1dcb6e0</title>
<path d="M83.0931,-264.1191C113.8406,-282.5677 167.9737,-315.0477 203.8067,-336.5476"/>
<polygon points="202.1215,-339.6181 212.4972,-341.7619 205.723,-333.6157 202.1215,-339.6181"/>
</g>
<g class="m-node m-flat">
<title>p0x7fd6100014e0</title>
<ellipse cx="59.5614" cy="-196" rx="37.6845" ry="18"/>
<text text-anchor="middle" x="59.5614" y="-191.2">pfg_9</text>
</g>
<g class="m-edge">
<title>p0x7fd6100014e0&#45;&gt;p0x1dcb6e0</title>
<path d="M84.181,-209.9214C90.545,-213.8762 97.2528,-218.3735 103.1228,-223 146.8999,-257.5035 191.7197,-304.5549 217.5291,-333.0251"/>
<polygon points="214.9973,-335.4439 224.2879,-340.5365 220.2009,-330.7617 214.9973,-335.4439"/>
</g>
<g class="m-node m-flat">
<title>p0x7fd6100015f0</title>
<ellipse cx="59.5614" cy="-142" rx="43.6229" ry="18"/>
<text text-anchor="middle" x="59.5614" y="-137.2">pfg_10</text>
</g>
<g class="m-edge">
<title>p0x7fd6100015f0&#45;&gt;p0x1dcb6e0</title>
<path d="M86.5475,-156.4362C92.3269,-160.1371 98.1759,-164.3897 103.1228,-169 156.343,-218.5991 202.0969,-291.7359 224.6276,-330.8963"/>
<polygon points="221.8641,-333.1179 229.8458,-340.0853 227.9512,-329.6612 221.8641,-333.1179"/>
</g>
<g class="m-node m-flat">
<title>p0x7fd610001700</title>
<ellipse cx="59.5614" cy="-88" rx="42.5413" ry="18"/>
<text text-anchor="middle" x="59.5614" y="-83.2">pfg_11</text>
</g>
<g class="m-edge">
<title>p0x7fd610001700&#45;&gt;p0x1dcb6e0</title>
<path d="M86.9477,-102.0304C92.7064,-105.7524 98.4457,-110.1161 103.1228,-115 166.3869,-181.0615 210.6197,-282.0751 229.428,-330.39"/>
<polygon points="226.2118,-331.7787 233.0533,-339.8684 232.7499,-329.2779 226.2118,-331.7787"/>
</g>
<g class="m-node m-flat">
<title>p0x7fd610001810</title>
<ellipse cx="59.5614" cy="-34" rx="43.6229" ry="18"/>
<text text-anchor="middle" x="59.5614" y="-29.2">pfg_12</text>
</g>
<g class="m-edge">
<title>p0x7fd610001810&#45;&gt;p0x1dcb6e0</title>
<path d="M87.6874,-48.063C93.2751,-51.7362 98.7568,-56.0715 103.1228,-61 176.6462,-143.9973 217.4214,-273.3327 232.6048,-329.9088"/>
<polygon points="229.3044,-331.1219 235.2235,-339.9091 236.0761,-329.3486 229.3044,-331.1219"/>
</g>
<g class="m-edge">
<title>p0x1dcb900&#45;&gt;p0x1dcb5d0</title>
<path stroke-dasharray="5,2" d="M697.6194,-334.4859C715.8132,-336.8618 735.4322,-340.2338 753.1931,-345 763.7364,-347.8293 774.7817,-351.8369 784.9759,-356.0046"/>
<polygon points="783.8716,-359.3379 794.4447,-360.0164 786.6024,-352.8925 783.8716,-359.3379"/>
<text text-anchor="middle" x="748.7439" y="-348.2">0</text>
</g>
</g>
</svg>
</div><p>The scheduler starts with <code>init</code>, moves on to <code>clean_up</code>, and then enters the parallel-for task <code>paralle-for</code> that spawns a subflow of 12 workers to perform parallel iterations. When <code>parallel-for</code> completes, it updates the cluster centroids and checks if they have converged through a condition task. If not, the condition task informs the scheduler to go back to <code>clean_up</code> and then <code>parallel-for</code>; otherwise, it returns a nominal index to stop the scheduler.</p></section><section id="ParallelKMeansUsingGPUs"><h2><a href="#ParallelKMeansUsingGPUs">Parallel k-means using GPUs</a></h2><p>We observe Step 2 and Step 3 of the algorithm are parallelizable across individual points for use to harness the power of GPU:</p><ol><li>for every data point, find the nearest centroid (L2 distance or other measurements) and assign the point to it</li><li>for every centroid, move the centroid to the average of the points assigned to that centroid.</li></ol><p>At a fine-grained level, we request one GPU thread to work on one point for Step 2 and one GPU thread to work on one centroid for Step 3.</p><pre class="m-code"><span class="c1">// px/py: 2D points</span>
<span class="c1">// N: number of points</span>
<span class="c1">// mx/my: centroids</span>
<span class="c1">// K: number of clusters</span>
<span class="c1">// sx/sy/c: storage to compute the average</span>
<span class="n">__global__</span> <span class="kt">void</span> <span class="n">assign_clusters</span><span class="p">(</span>
  <span class="kt">float</span><span class="o">*</span> <span class="n">px</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">py</span><span class="p">,</span> <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> 
  <span class="kt">float</span><span class="o">*</span> <span class="n">mx</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">my</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">sx</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">sy</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">c</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">blockIdx</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">blockDim</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">N</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Make global loads once.</span>
  <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">px</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
  <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">py</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>

  <span class="kt">float</span> <span class="n">best_dance</span> <span class="o">=</span> <span class="n">FLT_MAX</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">best_k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">K</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">d</span> <span class="o">=</span> <span class="n">L2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">mx</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="n">my</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&lt;</span> <span class="n">best_d</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">best_d</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
      <span class="n">best_k</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
    <span class="p">}</span>   
  <span class="p">}</span>

  <span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sx</span><span class="p">[</span><span class="n">best_k</span><span class="p">],</span> <span class="n">x</span><span class="p">);</span> 
  <span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sy</span><span class="p">[</span><span class="n">best_k</span><span class="p">],</span> <span class="n">y</span><span class="p">);</span> 
  <span class="n">atomicAdd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span> <span class="p">[</span><span class="n">best_k</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span> 
<span class="p">}</span>

<span class="c1">// mx/my: centroids, sx/sy/c: storage to compute the average</span>
<span class="n">__global__</span> <span class="kt">void</span> <span class="n">compute_new_means</span><span class="p">(</span>
  <span class="kt">float</span><span class="o">*</span> <span class="n">mx</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">my</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">sx</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">sy</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">c</span>
<span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">threadIdx</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">[</span><span class="n">k</span><span class="p">]);</span>  <span class="c1">// turn 0/0 to 0/1</span>
  <span class="n">mx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sx</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">count</span><span class="p">;</span>
  <span class="n">my</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">sy</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span></pre><p>When we recompute the cluster centroids to be the mean of all points assigned to a particular centroid, multiple GPU threads may access the sum arrays, <code>sx</code> and <code>sy</code>, and the count array, <code>c</code>. To avoid data race, we use a simple <code>atomicAdd</code> method. Based on the two kernels, the entire code of CPU-GPU collaborative tasking is described as follows:</p><pre class="m-code"><span class="c1">// N: number of points</span>
<span class="c1">// K: number of clusters</span>
<span class="c1">// M: number of iterations</span>
<span class="c1">// px/py: 2D point vector </span>
<span class="kt">void</span> <span class="nf">kmeans_gpu</span><span class="p">(</span>
  <span class="kt">int</span> <span class="n">N</span><span class="p">,</span> <span class="kt">int</span> <span class="n">K</span><span class="p">,</span> <span class="kt">int</span> <span class="n">M</span><span class="p">,</span> <span class="n">cconst</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">px</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;&amp;</span> <span class="n">py</span>
<span class="p">)</span> <span class="p">{</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span> <span class="n">h_mx</span><span class="p">,</span> <span class="n">h_my</span><span class="p">;</span>
  <span class="kt">float</span> <span class="o">*</span><span class="n">d_px</span><span class="p">,</span> <span class="o">*</span><span class="n">d_py</span><span class="p">,</span> <span class="o">*</span><span class="n">d_mx</span><span class="p">,</span> <span class="o">*</span><span class="n">d_my</span><span class="p">,</span> <span class="o">*</span><span class="n">d_sx</span><span class="p">,</span> <span class="o">*</span><span class="n">d_sy</span><span class="p">,</span> <span class="o">*</span><span class="n">d_c</span><span class="p">;</span>

  <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">K</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">h_mx</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">h_px</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">h_my</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">h_py</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="c1">// create a taskflow graph</span>
  <span class="n">tf</span><span class="o">::</span><span class="n">Executor</span> <span class="n">executor</span><span class="p">;</span>
  <span class="n">tf</span><span class="o">::</span><span class="n">Taskflow</span> <span class="n">taskflow</span><span class="p">(</span><span class="s">&quot;K-Means&quot;</span><span class="p">);</span>
  
  <span class="c1">// allocate GPU memory</span>
  <span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">allocate_px</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span> 
    <span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_px</span><span class="p">,</span> <span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span> 
  <span class="p">}).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;allocate_px&quot;</span><span class="p">);</span>

  <span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">allocate_py</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span> 
    <span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_py</span><span class="p">,</span> <span class="n">N</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span> 
  <span class="p">}).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;allocate_py&quot;</span><span class="p">);</span>

  <span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">allocate_mx</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span> 
    <span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_mx</span><span class="p">,</span> <span class="n">K</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span> <span class="p">}</span>
  <span class="p">).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;allocate_mx&quot;</span><span class="p">);</span>

  <span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">allocate_my</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span> 
    <span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_my</span><span class="p">,</span> <span class="n">K</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span> 
  <span class="p">}).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;allocate_my&quot;</span><span class="p">);</span>

  <span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">allocate_sy</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span> 
    <span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_sy</span><span class="p">,</span> <span class="n">K</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span> 
  <span class="p">}).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;allocate_sy&quot;</span><span class="p">);</span>

  <span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">allocate_c</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span> 
    <span class="n">cudaMalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">d_c</span><span class="p">,</span> <span class="n">K</span><span class="o">*</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span> 
  <span class="p">}).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;allocate_c&quot;</span><span class="p">);</span>
  
  <span class="c1">// transfer data from the host to the GPU</span>
  <span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">h2d</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">cudaFlow</span><span class="o">&amp;</span> <span class="n">cf</span><span class="p">){</span>
    <span class="n">cf</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">d_px</span><span class="p">,</span> <span class="n">h_px</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">N</span><span class="p">).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;h2d_px&quot;</span><span class="p">);</span>
    <span class="n">cf</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">d_py</span><span class="p">,</span> <span class="n">h_py</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">N</span><span class="p">).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;h2d_py&quot;</span><span class="p">);</span>
    <span class="n">cf</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">d_mx</span><span class="p">,</span> <span class="n">h_mx</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">K</span><span class="p">).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;h2d_mx&quot;</span><span class="p">);</span>
    <span class="n">cf</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">d_my</span><span class="p">,</span> <span class="n">h_my</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">K</span><span class="p">).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;h2d_my&quot;</span><span class="p">);</span>
  <span class="p">}).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;h2d&quot;</span><span class="p">);</span>
  
  <span class="c1">// GPU task graph of the main k-means body</span>
  <span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">kmeans</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">cudaFlow</span><span class="o">&amp;</span> <span class="n">cf</span><span class="p">){</span>

    <span class="n">tf</span><span class="o">::</span><span class="n">cudaTask</span> <span class="n">zero_c</span> <span class="o">=</span> <span class="n">cf</span><span class="p">.</span><span class="n">zero</span><span class="p">(</span><span class="n">d_c</span><span class="p">,</span> <span class="n">K</span><span class="p">).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;zero_c&quot;</span><span class="p">);</span>
    <span class="n">tf</span><span class="o">::</span><span class="n">cudaTask</span> <span class="n">zero_sx</span> <span class="o">=</span> <span class="n">cf</span><span class="p">.</span><span class="n">zero</span><span class="p">(</span><span class="n">d_sx</span><span class="p">,</span> <span class="n">K</span><span class="p">).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;zero_sx&quot;</span><span class="p">);</span>
    <span class="n">tf</span><span class="o">::</span><span class="n">cudaTask</span> <span class="n">zero_sy</span> <span class="o">=</span> <span class="n">cf</span><span class="p">.</span><span class="n">zero</span><span class="p">(</span><span class="n">d_sy</span><span class="p">,</span> <span class="n">K</span><span class="p">).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;zero_sy&quot;</span><span class="p">);</span>

    <span class="n">tf</span><span class="o">::</span><span class="n">cudaTask</span> <span class="n">cluster</span> <span class="o">=</span> <span class="n">cf</span><span class="p">.</span><span class="n">kernel</span><span class="p">(</span>
      <span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1024-1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> 
      <span class="n">assign_clusters</span><span class="p">,</span> <span class="n">d_px</span><span class="p">,</span> <span class="n">d_py</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">d_mx</span><span class="p">,</span> <span class="n">d_my</span><span class="p">,</span> <span class="n">d_sx</span><span class="p">,</span> <span class="n">d_sy</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">d_c</span>
    <span class="p">).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;cluster&quot;</span><span class="p">);</span>

    <span class="n">tf</span><span class="o">::</span><span class="n">cudaTask</span> <span class="n">new_centroid</span> <span class="o">=</span> <span class="n">cf</span><span class="p">.</span><span class="n">kernel</span><span class="p">(</span>
      <span class="mi">1</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">compute_new_means</span><span class="p">,</span> <span class="n">d_mx</span><span class="p">,</span> <span class="n">d_my</span><span class="p">,</span> <span class="n">d_sx</span><span class="p">,</span> <span class="n">d_sy</span><span class="p">,</span> <span class="n">d_c</span>
    <span class="p">).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;new_centroid&quot;</span><span class="p">);</span>

    <span class="n">cluster</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">new_centroid</span><span class="p">)</span>
           <span class="p">.</span><span class="n">succeed</span><span class="p">(</span><span class="n">zero_c</span><span class="p">,</span> <span class="n">zero_sx</span><span class="p">,</span> <span class="n">zero_sy</span><span class="p">);</span>
  <span class="p">}).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;update_means&quot;</span><span class="p">);</span>
  
  <span class="c1">// condition task to check convergence</span>
  <span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">condition</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="p">]</span> <span class="p">()</span> <span class="k">mutable</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="n">M</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;converged?&quot;</span><span class="p">);</span>
  
  <span class="c1">// transfer the result of clusters from GPU to host</span>
  <span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">stop</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">cudaFlow</span><span class="o">&amp;</span> <span class="n">cf</span><span class="p">){</span>
    <span class="n">cf</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">h_mx</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">d_mx</span><span class="p">,</span> <span class="n">K</span><span class="p">).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;d2h_mx&quot;</span><span class="p">);</span>
    <span class="n">cf</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">h_my</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">d_my</span><span class="p">,</span> <span class="n">K</span><span class="p">).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;d2h_my&quot;</span><span class="p">);</span>
  <span class="p">}).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;d2h&quot;</span><span class="p">);</span>
  
  <span class="c1">// deallocated GPU memory</span>
  <span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">free</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
    <span class="n">cudaFree</span><span class="p">(</span><span class="n">d_px</span><span class="p">);</span>
    <span class="n">cudaFree</span><span class="p">(</span><span class="n">d_py</span><span class="p">);</span>
    <span class="n">cudaFree</span><span class="p">(</span><span class="n">d_mx</span><span class="p">);</span>
    <span class="n">cudaFree</span><span class="p">(</span><span class="n">d_my</span><span class="p">);</span>
    <span class="n">cudaFree</span><span class="p">(</span><span class="n">d_sx</span><span class="p">);</span>
    <span class="n">cudaFree</span><span class="p">(</span><span class="n">d_sy</span><span class="p">);</span>
    <span class="n">cudaFree</span><span class="p">(</span><span class="n">d_c</span><span class="p">);</span>
  <span class="p">}).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;free&quot;</span><span class="p">);</span>

  <span class="c1">// build up the dependency</span>
  <span class="n">h2d</span><span class="p">.</span><span class="n">succeed</span><span class="p">(</span><span class="n">allocate_px</span><span class="p">,</span> <span class="n">allocate_py</span><span class="p">,</span> <span class="n">allocate_mx</span><span class="p">,</span> <span class="n">allocate_my</span><span class="p">);</span>

  <span class="n">kmeans</span><span class="p">.</span><span class="n">succeed</span><span class="p">(</span><span class="n">allocate_sx</span><span class="p">,</span> <span class="n">allocate_sy</span><span class="p">,</span> <span class="n">allocate_c</span><span class="p">,</span> <span class="n">h2d</span><span class="p">)</span>
        <span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">condition</span><span class="p">);</span>

  <span class="n">condition</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">kmeans</span><span class="p">,</span> <span class="n">stop</span><span class="p">);</span>

  <span class="n">stop</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">free</span><span class="p">);</span>
  
  <span class="c1">// dump the taskflow without expanding GPU task graphs</span>
  <span class="n">taskflow</span><span class="p">.</span><span class="n">dump</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">);</span>

  <span class="c1">// run the taskflow</span>
  <span class="n">executor</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">taskflow</span><span class="p">).</span><span class="n">wait</span><span class="p">();</span>
  
  <span class="c1">// dump the entire taskflow</span>
  <span class="n">taskflow</span><span class="p">.</span><span class="n">dump</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="p">);</span>
<span class="p">}</span></pre><p>The first dump before executing the taskflow produces the following diagram. The condition tasks introduces a cycle between itself and <code>update_means</code>. Each time it goes back to <code>update_means</code>, the cudaFlow is reconstructed with captured parameters in the closure and offloaded to the GPU.</p><div class="m-graph"><svg style="width: 56.062rem; height: 17.938rem;" viewBox="0.00 0.00 896.99 287.00">
<g transform="scale(1 1) rotate(0) translate(4 283)">
<title>Taskflow</title>
<g class="m-node m-flat">
<title>p0x562f9807bcc0</title>
<ellipse cx="68.0044" cy="-261" rx="65.0658" ry="18"/>
<text text-anchor="middle" x="68.0044" y="-256.2">allocate_px</text>
</g>
<g class="m-node">
<title>p0x562f9807b550</title>
<polygon points="264.439,-198 261.439,-202 240.439,-202 237.439,-198 210.439,-198 210.439,-162 264.439,-162 264.439,-198"/>
<text text-anchor="middle" x="237.439" y="-175.2">h2d</text>
</g>
<g class="m-edge">
<title>p0x562f9807bcc0&#45;&gt;p0x562f9807b550</title>
<path d="M106.8029,-246.4587C116.435,-242.6131 126.6716,-238.3228 136.0088,-234 158.1007,-223.7722 182.1787,-211.025 201.3294,-200.4843"/>
<polygon points="203.2562,-203.418 210.3045,-195.5077 199.8617,-197.2961 203.2562,-203.418"/>
</g>
<g class="m-node">
<title>p0x562f9807b440</title>
<polygon points="460.6584,-117 457.6584,-121 436.6584,-121 433.6584,-117 338.9395,-117 338.9395,-81 460.6584,-81 460.6584,-117"/>
<text text-anchor="middle" x="399.7989" y="-94.2">update_means</text>
</g>
<g class="m-edge">
<title>p0x562f9807b550&#45;&gt;p0x562f9807b440</title>
<path d="M264.685,-169.3379C276.2736,-164.6092 289.8585,-158.8075 301.8692,-153 321.368,-143.5719 342.4688,-132.1067 360.0728,-122.17"/>
<polygon points="361.97,-125.1176 368.9329,-117.132 358.5099,-119.0325 361.97,-125.1176"/>
</g>
<g class="m-node m-flat">
<title>p0x562f9807bbb0</title>
<ellipse cx="68.0044" cy="-207" rx="65.0658" ry="18"/>
<text text-anchor="middle" x="68.0044" y="-202.2">allocate_py</text>
</g>
<g class="m-edge">
<title>p0x562f9807bbb0&#45;&gt;p0x562f9807b550</title>
<path d="M124.4237,-198.0094C149.3553,-194.0365 177.9811,-189.4748 200.1847,-185.9366"/>
<polygon points="200.886,-189.3691 210.2106,-184.339 199.7843,-182.4563 200.886,-189.3691"/>
</g>
<g class="m-node m-flat">
<title>p0x562f9807baa0</title>
<ellipse cx="68.0044" cy="-153" rx="68.0088" ry="18"/>
<text text-anchor="middle" x="68.0044" y="-148.2">allocate_mx</text>
</g>
<g class="m-edge">
<title>p0x562f9807baa0&#45;&gt;p0x562f9807b550</title>
<path d="M126.3142,-162.2919C150.8289,-166.1984 178.6215,-170.6272 200.2797,-174.0785"/>
<polygon points="199.9517,-177.5703 210.3779,-175.6877 201.0533,-170.6576 199.9517,-177.5703"/>
</g>
<g class="m-node m-flat">
<title>p0x562f9807b990</title>
<ellipse cx="68.0044" cy="-99" rx="68.0088" ry="18"/>
<text text-anchor="middle" x="68.0044" y="-94.2">allocate_my</text>
</g>
<g class="m-edge">
<title>p0x562f9807b990&#45;&gt;p0x562f9807b550</title>
<path d="M109.0499,-113.3569C118.1284,-117.0619 127.5559,-121.3362 136.0088,-126 153.8332,-135.8343 155.2781,-142.9979 173.0088,-153 181.7113,-157.9092 191.4851,-162.4548 200.7395,-166.3626"/>
<polygon points="199.5476,-169.6563 210.1289,-170.1924 202.1914,-163.1748 199.5476,-169.6563"/>
</g>
<g class="m-node m-flat">
<title>p0x562f9807b880</title>
<ellipse cx="237.439" cy="-126" rx="64.3605" ry="18"/>
<text text-anchor="middle" x="237.439" y="-121.2">allocate_sx</text>
</g>
<g class="m-edge">
<title>p0x562f9807b880&#45;&gt;p0x562f9807b440</title>
<path d="M292.86,-116.7836C304.4148,-114.8621 316.7463,-112.8114 328.7756,-110.811"/>
<polygon points="329.495,-114.2395 338.7854,-109.1464 328.3466,-107.3343 329.495,-114.2395"/>
</g>
<g class="m-node">
<title>p0x562f9807b330</title>
<polygon points="600.1322,-117 505.6219,-99 600.1322,-81 694.6425,-99 600.1322,-117"/>
<text text-anchor="middle" x="600.1322" y="-94.2">converged?</text>
</g>
<g class="m-edge">
<title>p0x562f9807b440&#45;&gt;p0x562f9807b330</title>
<path d="M460.984,-100.7033C466.9797,-100.8242 472.9719,-100.9271 478.7286,-101 487.6292,-101.1127 496.8966,-101.1339 506.1678,-101.0906"/>
<polygon points="506.2372,-104.5903 516.2121,-101.0195 506.1876,-97.5904 506.2372,-104.5903"/>
</g>
<g class="m-node m-flat">
<title>p0x562f9807b770</title>
<ellipse cx="237.439" cy="-72" rx="64.3605" ry="18"/>
<text text-anchor="middle" x="237.439" y="-67.2">allocate_sy</text>
</g>
<g class="m-edge">
<title>p0x562f9807b770&#45;&gt;p0x562f9807b440</title>
<path d="M292.86,-81.2164C304.4148,-83.1379 316.7463,-85.1886 328.7756,-87.189"/>
<polygon points="328.3466,-90.6657 338.7854,-88.8536 329.495,-83.7605 328.3466,-90.6657"/>
</g>
<g class="m-node m-flat">
<title>p0x562f9807b660</title>
<ellipse cx="237.439" cy="-18" rx="59.1273" ry="18"/>
<text text-anchor="middle" x="237.439" y="-13.2">allocate_c</text>
</g>
<g class="m-edge">
<title>p0x562f9807b660&#45;&gt;p0x562f9807b440</title>
<path d="M273.5265,-32.3223C282.8477,-36.2393 292.8066,-40.618 301.8692,-45 321.368,-54.4281 342.4688,-65.8933 360.0728,-75.83"/>
<polygon points="358.5099,-78.9675 368.9329,-80.868 361.97,-72.8824 358.5099,-78.9675"/>
</g>
<g class="m-edge">
<title>p0x562f9807b330&#45;&gt;p0x562f9807b440</title>
<path stroke-dasharray="5,2" d="M561.9472,-88.207C538.0819,-82.7374 506.6778,-77.8535 478.7286,-81 476.0706,-81.2992 473.3715,-81.6535 470.6523,-82.0529"/>
<polygon points="470.0551,-78.604 460.7549,-83.679 471.19,-85.5114 470.0551,-78.604"/>
<text text-anchor="middle" x="483.1778" y="-84.2">0</text>
</g>
<g class="m-node">
<title>p0x562f9807b220</title>
<polygon points="793.5358,-117 790.5358,-121 769.5358,-121 766.5358,-117 739.5358,-117 739.5358,-81 793.5358,-81 793.5358,-117"/>
<text text-anchor="middle" x="766.5358" y="-94.2">d2h</text>
</g>
<g class="m-edge">
<title>p0x562f9807b330&#45;&gt;p0x562f9807b220</title>
<path stroke-dasharray="5,2" d="M695,-99C707.0258,-99 718.7198,-99 729.0503,-99"/>
<polygon points="729.2789,-102.5001 739.2789,-99 729.2788,-95.5001 729.2789,-102.5001"/>
<text text-anchor="middle" x="717.0866" y="-102.2">1</text>
</g>
<g class="m-node m-flat">
<title>p0x562f9807b110</title>
<ellipse cx="859.7637" cy="-99" rx="29.4575" ry="18"/>
<text text-anchor="middle" x="859.7637" y="-94.2">free</text>
</g>
<g class="m-edge">
<title>p0x562f9807b220&#45;&gt;p0x562f9807b110</title>
<path d="M794.003,-99C802.1872,-99 811.3245,-99 820.1226,-99"/>
<polygon points="820.2178,-102.5001 830.2178,-99 820.2177,-95.5001 820.2178,-102.5001"/>
</g>
</g>
</svg>
</div><p>The second dump after executing the taskflow produces the following diagram, with all cudaFlows expanded:</p><div class="m-graph"><svg style="width: 82.500rem; height: 49.438rem;" viewBox="0.00 0.00 1319.58 791.00">
<g transform="scale(1 1) rotate(0) translate(4 787)">
<title>Taskflow</title>
<g class="m-cluster">
<title>cluster_p0x562f9807b220</title>
<polygon points="765.471,-8 765.471,-138 1224.1254,-138 1224.1254,-8 765.471,-8"/>
<text text-anchor="middle" x="994.7982" y="-121.2">cudaFlow: h2d</text>
</g>
<g class="m-cluster">
<title>cluster_p0x562f9807b550</title>
<polygon points="279.7546,-447 279.7546,-685 695.0286,-685 695.0286,-447 279.7546,-447"/>
<text text-anchor="middle" x="487.3916" y="-668.2">cudaFlow: h2d</text>
</g>
<g class="m-cluster">
<title>cluster_p0x562f9807b440</title>
<polygon points="8,-157 8,-341 891.3182,-341 891.3182,-157 8,-157"/>
<text text-anchor="middle" x="449.6591" y="-324.2">cudaFlow: update_means</text>
</g>
<g class="m-node m-flat">
<title>p0x562f9807bcc0</title>
<ellipse cx="490.594" cy="-711" rx="65.0658" ry="18"/>
<text text-anchor="middle" x="490.594" y="-706.2">allocate_px</text>
</g>
<g class="m-node">
<title>p0x562f9807b550</title>
<polygon points="687.0286,-545 684.0286,-549 663.0286,-549 660.0286,-545 633.0286,-545 633.0286,-509 687.0286,-509 687.0286,-545"/>
<text text-anchor="middle" x="660.0286" y="-522.2">h2d</text>
</g>
<g class="m-edge">
<title>p0x562f9807bcc0&#45;&gt;p0x562f9807b550</title>
<path d="M540.5757,-699.3701C547.0071,-696.6044 553.2158,-693.1959 558.5984,-689 604.4083,-653.2894 634.9937,-590.674 649.757,-554.6425"/>
<polygon points="653.0574,-555.8148 653.501,-545.2292 646.553,-553.2277 653.0574,-555.8148"/>
</g>
<g class="m-node">
<title>p0x562f9807b440</title>
<polygon points="883.2479,-201 880.2479,-205 859.2479,-205 856.2479,-201 761.529,-201 761.529,-165 883.2479,-165 883.2479,-201"/>
<text text-anchor="middle" x="822.3885" y="-178.2">update_means</text>
</g>
<g class="m-edge">
<title>p0x562f9807b550&#45;&gt;p0x562f9807b440</title>
<path d="M668.5292,-508.9894C695.2083,-452.463 777.4039,-278.311 809.4279,-210.4601"/>
<polygon points="812.673,-211.7846 813.7762,-201.2473 806.3427,-208.7968 812.673,-211.7846"/>
</g>
<g class="m-node m-flat">
<title>p0x562f9807bbb0</title>
<ellipse cx="490.594" cy="-421" rx="65.0658" ry="18"/>
<text text-anchor="middle" x="490.594" y="-416.2">allocate_py</text>
</g>
<g class="m-edge">
<title>p0x562f9807bbb0&#45;&gt;p0x562f9807b550</title>
<path d="M537.667,-433.6378C544.8703,-436.303 552.0727,-439.4157 558.5984,-443 587.4357,-458.8393 615.9018,-483.4126 635.3026,-501.8965"/>
<polygon points="632.9125,-504.4541 642.529,-508.9008 637.7844,-499.4277 632.9125,-504.4541"/>
</g>
<g class="m-node m-flat">
<title>p0x562f9807baa0</title>
<ellipse cx="490.594" cy="-367" rx="68.0088" ry="18"/>
<text text-anchor="middle" x="490.594" y="-362.2">allocate_mx</text>
</g>
<g class="m-edge">
<title>p0x562f9807baa0&#45;&gt;p0x562f9807b550</title>
<path d="M535.2592,-380.6975C543.4533,-384.3033 551.6133,-388.7053 558.5984,-394 596.8123,-422.9662 627.9296,-469.9013 645.2058,-499.5722"/>
<polygon points="642.3305,-501.596 650.3201,-508.5543 648.4136,-498.1324 642.3305,-501.596"/>
</g>
<g class="m-node m-flat">
<title>p0x562f9807b990</title>
<ellipse cx="490.594" cy="-765" rx="68.0088" ry="18"/>
<text text-anchor="middle" x="490.594" y="-760.2">allocate_my</text>
</g>
<g class="m-edge">
<title>p0x562f9807b990&#45;&gt;p0x562f9807b550</title>
<path d="M537.5863,-751.7401C545.202,-748.1419 552.5588,-743.6301 558.5984,-738 613.5083,-686.813 641.9824,-599.6586 653.5847,-555.0777"/>
<polygon points="657.0199,-555.7679 656.0547,-545.2171 650.2297,-554.0669 657.0199,-555.7679"/>
</g>
<g class="m-node m-flat">
<title>p0x562f9807b880</title>
<ellipse cx="660.0286" cy="-131" rx="64.3605" ry="18"/>
<text text-anchor="middle" x="660.0286" y="-126.2">allocate_sx</text>
</g>
<g class="m-edge">
<title>p0x562f9807b880&#45;&gt;p0x562f9807b440</title>
<path d="M702.6867,-144.6624C719.0171,-149.8926 738.0549,-155.99 756.0799,-161.763"/>
<polygon points="755.375,-165.2122 765.966,-164.9292 757.5101,-158.5458 755.375,-165.2122"/>
</g>
<g class="m-node">
<title>p0x562f9807b330</title>
<polygon points="1022.7218,-182 928.2114,-164 1022.7218,-146 1117.2321,-164 1022.7218,-182"/>
<text text-anchor="middle" x="1022.7218" y="-159.2">converged?</text>
</g>
<g class="m-edge">
<title>p0x562f9807b440&#45;&gt;p0x562f9807b330</title>
<path d="M883.3922,-182.6127C892.397,-182.265 901.5554,-181.7499 910.2166,-181 927.7374,-179.483 946.6783,-176.9651 963.9326,-174.326"/>
<polygon points="964.5375,-177.774 973.8733,-172.7648 963.4514,-170.8588 964.5375,-177.774"/>
</g>
<g class="m-node m-flat">
<title>p0x562f9807b770</title>
<ellipse cx="660.0286" cy="-77" rx="64.3605" ry="18"/>
<text text-anchor="middle" x="660.0286" y="-72.2">allocate_sy</text>
</g>
<g class="m-edge">
<title>p0x562f9807b770&#45;&gt;p0x562f9807b440</title>
<path d="M700.5105,-91.0269C708.7568,-94.6805 717.1405,-99.0171 724.4588,-104 743.9434,-117.2667 743.3618,-126.8952 761.4588,-142 768.6472,-147.9998 776.7254,-153.9314 784.5913,-159.34"/>
<polygon points="782.7385,-162.3117 792.9912,-164.9822 786.6416,-156.5009 782.7385,-162.3117"/>
</g>
<g class="m-node m-flat">
<title>p0x562f9807b660</title>
<ellipse cx="660.0286" cy="-23" rx="59.1273" ry="18"/>
<text text-anchor="middle" x="660.0286" y="-18.2">allocate_c</text>
</g>
<g class="m-edge">
<title>p0x562f9807b660&#45;&gt;p0x562f9807b440</title>
<path d="M703.2031,-35.4722C710.9813,-39.1951 718.4991,-43.9536 724.4588,-50 755.3963,-81.3878 733.7319,-107.743 761.4588,-142 766.5348,-148.2715 772.8244,-153.9478 779.4174,-158.9398"/>
<polygon points="777.6718,-161.9914 787.8623,-164.8905 781.7039,-156.2693 777.6718,-161.9914"/>
</g>
<g class="m-node m-flat">
<title>p0x7fbc54000b20</title>
<ellipse cx="336.6721" cy="-635" rx="45.892" ry="18"/>
<text text-anchor="middle" x="336.6721" y="-630.2">h2d_px</text>
</g>
<g class="m-edge">
<title>p0x7fbc54000b20&#45;&gt;p0x562f9807b550</title>
<path d="M371.8924,-623.2365C433.5756,-602.6345 560.548,-560.2262 623.2869,-539.2716"/>
<polygon points="624.4086,-542.5871 632.7848,-536.0993 622.191,-535.9476 624.4086,-542.5871"/>
</g>
<g class="m-node m-flat">
<title>p0x7fbc54000c00</title>
<ellipse cx="336.6721" cy="-581" rx="45.892" ry="18"/>
<text text-anchor="middle" x="336.6721" y="-576.2">h2d_py</text>
</g>
<g class="m-edge">
<title>p0x7fbc54000c00&#45;&gt;p0x562f9807b550</title>
<path d="M378.9453,-573.9404C442.7058,-563.2925 562.4451,-543.2963 622.9791,-533.1872"/>
<polygon points="623.5814,-536.6352 632.8683,-531.5357 622.4283,-529.7308 623.5814,-536.6352"/>
</g>
<g class="m-node m-flat">
<title>p0x7fbc54000ce0</title>
<ellipse cx="336.6721" cy="-527" rx="48.8351" ry="18"/>
<text text-anchor="middle" x="336.6721" y="-522.2">h2d_mx</text>
</g>
<g class="m-edge">
<title>p0x7fbc54000ce0&#45;&gt;p0x562f9807b550</title>
<path d="M385.783,-527C450.8155,-527 564.0858,-527 622.6229,-527"/>
<polygon points="622.8922,-530.5001 632.8921,-527 622.8921,-523.5001 622.8922,-530.5001"/>
</g>
<g class="m-node m-flat">
<title>p0x7fbc54000db0</title>
<ellipse cx="336.6721" cy="-473" rx="48.8351" ry="18"/>
<text text-anchor="middle" x="336.6721" y="-468.2">h2d_my</text>
</g>
<g class="m-edge">
<title>p0x7fbc54000db0&#45;&gt;p0x562f9807b550</title>
<path d="M381.2939,-480.4518C445.5255,-491.1783 562.8838,-510.777 622.7524,-520.7749"/>
<polygon points="622.4506,-524.2729 632.8905,-522.468 623.6036,-517.3685 622.4506,-524.2729"/>
</g>
<g class="m-edge">
<title>p0x562f9807b330&#45;&gt;p0x562f9807b440</title>
<path stroke-dasharray="5,2" d="M956.6656,-158.5301C938.6504,-158.0811 919.1783,-158.5575 901.3182,-161 897.6493,-161.5018 893.9104,-162.1289 890.1537,-162.8509"/>
<polygon points="889.2595,-159.4626 880.2038,-164.962 890.7125,-166.3101 889.2595,-159.4626"/>
<text text-anchor="middle" x="905.7674" y="-164.2">0</text>
</g>
<g class="m-node">
<title>p0x562f9807b220</title>
<polygon points="1216.1254,-106 1213.1254,-110 1192.1254,-110 1189.1254,-106 1162.1254,-106 1162.1254,-70 1216.1254,-70 1216.1254,-106"/>
<text text-anchor="middle" x="1189.1254" y="-83.2">h2d</text>
</g>
<g class="m-edge">
<title>p0x562f9807b330&#45;&gt;p0x562f9807b220</title>
<path stroke-dasharray="5,2" d="M1075.0275,-155.8821C1089.1242,-152.6165 1104.0976,-148.1242 1117.2269,-142 1133.2423,-134.5296 1149.1528,-123.1068 1161.9195,-112.6879"/>
<polygon points="1164.4253,-115.1537 1169.8245,-106.0378 1159.919,-109.7971 1164.4253,-115.1537"/>
<text text-anchor="middle" x="1139.6761" y="-135.2">1</text>
</g>
<g class="m-node m-flat">
<title>p0x7fbc540051d0</title>
<ellipse cx="64.3148" cy="-291" rx="42.8965" ry="18"/>
<text text-anchor="middle" x="64.3148" y="-286.2">zero_c</text>
</g>
<g class="m-node">
<title>p0x7fbc540053d0</title>
<polygon points="250.8172,-227 191.567,-227 187.567,-223 187.567,-191 246.8172,-191 250.8172,-195 250.8172,-227"/>
<polyline points="246.8172,-223 187.567,-223 "/>
<polyline points="246.8172,-223 246.8172,-191 "/>
<polyline points="246.8172,-223 250.8172,-227 "/>
<text text-anchor="middle" x="219.1921" y="-204.2">cluster</text>
</g>
<g class="m-edge">
<title>p0x7fbc540051d0&#45;&gt;p0x7fbc540053d0</title>
<path d="M91.2924,-276.7167C115.3525,-263.978 150.9238,-245.1447 178.4493,-230.5713"/>
<polygon points="180.2473,-233.5797 187.4474,-225.8073 176.9719,-227.3933 180.2473,-233.5797"/>
</g>
<g class="m-node">
<title>p0x7fbc54005470</title>
<polygon points="546.266,-214 438.922,-214 434.922,-210 434.922,-178 542.266,-178 546.266,-182 546.266,-214"/>
<polyline points="542.266,-210 434.922,-210 "/>
<polyline points="542.266,-210 542.266,-178 "/>
<polyline points="542.266,-210 546.266,-214 "/>
<text text-anchor="middle" x="490.594" y="-191.2">new_centroid</text>
</g>
<g class="m-edge">
<title>p0x7fbc540053d0&#45;&gt;p0x7fbc54005470</title>
<path d="M250.8565,-207.4833C293.3093,-205.4498 369.7117,-201.7902 424.8738,-199.148"/>
<polygon points="425.0926,-202.6416 434.9136,-198.6671 424.7576,-195.6496 425.0926,-202.6416"/>
</g>
<g class="m-node m-flat">
<title>p0x7fbc54005270</title>
<ellipse cx="64.3148" cy="-237" rx="48.1303" ry="18"/>
<text text-anchor="middle" x="64.3148" y="-232.2">zero_sx</text>
</g>
<g class="m-edge">
<title>p0x7fbc54005270&#45;&gt;p0x7fbc540053d0</title>
<path d="M107.8689,-229.1259C129.5515,-225.206 155.6489,-220.4879 177.124,-216.6054"/>
<polygon points="178.0377,-219.9971 187.2555,-214.7738 176.7923,-213.1087 178.0377,-219.9971"/>
</g>
<g class="m-node m-flat">
<title>p0x7fbc54005330</title>
<ellipse cx="64.3148" cy="-183" rx="48.1303" ry="18"/>
<text text-anchor="middle" x="64.3148" y="-178.2">zero_sy</text>
</g>
<g class="m-edge">
<title>p0x7fbc54005330&#45;&gt;p0x7fbc540053d0</title>
<path d="M108.6964,-190.4506C130.3587,-194.0871 156.2696,-198.4369 177.554,-202.01"/>
<polygon points="177.1506,-205.4912 187.5921,-203.6952 178.3096,-198.5878 177.1506,-205.4912"/>
</g>
<g class="m-edge">
<title>p0x7fbc54005470&#45;&gt;p0x562f9807b440</title>
<path d="M546.5032,-193.8094C602.807,-191.6034 689.8736,-188.192 751.1064,-185.7929"/>
<polygon points="751.6079,-189.276 761.4632,-185.3871 751.3338,-182.2814 751.6079,-189.276"/>
</g>
<g class="m-node m-flat">
<title>p0x562f9807b110</title>
<ellipse cx="1282.3532" cy="-88" rx="29.4575" ry="18"/>
<text text-anchor="middle" x="1282.3532" y="-83.2">free</text>
</g>
<g class="m-edge">
<title>p0x562f9807b220&#45;&gt;p0x562f9807b110</title>
<path d="M1216.5926,-88C1224.7767,-88 1233.914,-88 1242.7122,-88"/>
<polygon points="1242.8073,-91.5001 1252.8073,-88 1242.8073,-84.5001 1242.8073,-91.5001"/>
</g>
<g class="m-node m-flat">
<title>p0x7fbc5400bf40</title>
<ellipse cx="822.3885" cy="-88" rx="48.8351" ry="18"/>
<text text-anchor="middle" x="822.3885" y="-83.2">d2h_mx</text>
</g>
<g class="m-edge">
<title>p0x7fbc5400bf40&#45;&gt;p0x562f9807b220</title>
<path d="M871.4677,-88C945.7606,-88 1085.1563,-88 1151.795,-88"/>
<polygon points="1151.8444,-91.5001 1161.8443,-88 1151.8443,-84.5001 1151.8444,-91.5001"/>
</g>
<g class="m-node m-flat">
<title>p0x7fbc54008020</title>
<ellipse cx="822.3885" cy="-34" rx="48.8351" ry="18"/>
<text text-anchor="middle" x="822.3885" y="-29.2">d2h_my</text>
</g>
<g class="m-edge">
<title>p0x7fbc54008020&#45;&gt;p0x562f9807b220</title>
<path d="M868.0944,-40.73C941.3636,-51.5184 1083.7365,-72.4821 1151.5118,-82.4616"/>
<polygon points="1151.3236,-85.9716 1161.7268,-83.9657 1152.3434,-79.0462 1151.3236,-85.9716"/>
</g>
</g>
</svg>
</div><p>The main cudaFlow task, <code>update_means</code>, must not run before all required data has settled down. It precedes a condition task that circles back to itself until we reach <code>M</code> iterations. When iteration completes, the condition task directs the execution path to the cudaFlow, <code>h2d</code>, to copy the results of clusters to <code>h_mx</code> and <code>h_my</code> and then deallocate all GPU memory.</p></section><section id="BuiltInPredicate"><h2><a href="#BuiltInPredicate">Built-in Predicate</a></h2><p>We observe the GPU task graph parameters remain <em>unchanged</em> across all k-means iterations. In this case, we can leverage <a href="classtf_1_1cudaFlow.html#a99358da15e3bdfa1faabb3e326130e1f" class="m-doc">tf::<wbr />cudaFlow::<wbr />offload_until</a> or <a href="classtf_1_1cudaFlow.html#ac2269fd7dc8ca04a294a718204703dad" class="m-doc">tf::<wbr />cudaFlow::<wbr />offload_n</a> to run it repeatedly without conditional tasking.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Task</span> <span class="n">kmeans</span> <span class="o">=</span> <span class="n">taskflow</span><span class="p">.</span><span class="n">emplace</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](</span><span class="n">tf</span><span class="o">::</span><span class="n">cudaFlow</span><span class="o">&amp;</span> <span class="n">cf</span><span class="p">){</span>

  <span class="n">tf</span><span class="o">::</span><span class="n">cudaTask</span> <span class="n">zero_c</span> <span class="o">=</span> <span class="n">cf</span><span class="p">.</span><span class="n">zero</span><span class="p">(</span><span class="n">d_c</span><span class="p">,</span> <span class="n">K</span><span class="p">).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;zero_c&quot;</span><span class="p">);</span>
  <span class="n">tf</span><span class="o">::</span><span class="n">cudaTask</span> <span class="n">zero_sx</span> <span class="o">=</span> <span class="n">cf</span><span class="p">.</span><span class="n">zero</span><span class="p">(</span><span class="n">d_sx</span><span class="p">,</span> <span class="n">K</span><span class="p">).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;zero_sx&quot;</span><span class="p">);</span>
  <span class="n">tf</span><span class="o">::</span><span class="n">cudaTask</span> <span class="n">zero_sy</span> <span class="o">=</span> <span class="n">cf</span><span class="p">.</span><span class="n">zero</span><span class="p">(</span><span class="n">d_sy</span><span class="p">,</span> <span class="n">K</span><span class="p">).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;zero_sy&quot;</span><span class="p">);</span>

  <span class="n">tf</span><span class="o">::</span><span class="n">cudaTask</span> <span class="n">cluster</span> <span class="o">=</span> <span class="n">cf</span><span class="p">.</span><span class="n">kernel</span><span class="p">(</span>
    <span class="p">(</span><span class="n">N</span><span class="o">+</span><span class="mi">1024-1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">assign_clusters</span><span class="p">,</span> <span class="n">d_px</span><span class="p">,</span> <span class="n">d_py</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">d_mx</span><span class="p">,</span> <span class="n">d_my</span><span class="p">,</span> <span class="n">d_sx</span><span class="p">,</span> <span class="n">d_sy</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="n">d_c</span>
  <span class="p">).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;cluster&quot;</span><span class="p">);</span>

  <span class="n">tf</span><span class="o">::</span><span class="n">cudaTask</span> <span class="n">new_centroid</span> <span class="o">=</span> <span class="n">cf</span><span class="p">.</span><span class="n">kernel</span><span class="p">(</span>
    <span class="mi">1</span><span class="p">,</span> <span class="n">K</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">compute_new_means</span><span class="p">,</span> <span class="n">d_mx</span><span class="p">,</span> <span class="n">d_my</span><span class="p">,</span> <span class="n">d_sx</span><span class="p">,</span> <span class="n">d_sy</span><span class="p">,</span> <span class="n">d_c</span>
  <span class="p">).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;new_centroid&quot;</span><span class="p">);</span>

  <span class="n">cluster</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">new_centroid</span><span class="p">)</span>
         <span class="p">.</span><span class="n">succeed</span><span class="p">(</span><span class="n">zero_c</span><span class="p">,</span> <span class="n">zero_sx</span><span class="p">,</span> <span class="n">zero_sy</span><span class="p">);</span>
  
  <span class="c1">// we ask the executor to launch the cudaFlow by M times</span>
  <span class="n">cf</span><span class="p">.</span><span class="n">offload_n</span><span class="p">(</span><span class="n">M</span><span class="p">);</span>
<span class="p">}).</span><span class="n">name</span><span class="p">(</span><span class="s">&quot;update_means&quot;</span><span class="p">);</span>

<span class="c1">// ...</span>

<span class="c1">// build up the dependency</span>
<span class="n">h2d</span><span class="p">.</span><span class="n">succeed</span><span class="p">(</span><span class="n">allocate_px</span><span class="p">,</span> <span class="n">allocate_py</span><span class="p">,</span> <span class="n">allocate_mx</span><span class="p">,</span> <span class="n">allocate_my</span><span class="p">);</span>

<span class="n">kmeans</span><span class="p">.</span><span class="n">succeed</span><span class="p">(</span><span class="n">allocate_sx</span><span class="p">,</span> <span class="n">allocate_sy</span><span class="p">,</span> <span class="n">allocate_c</span><span class="p">,</span> <span class="n">h2d</span><span class="p">)</span>
      <span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">stop</span><span class="p">);</span>

<span class="n">stop</span><span class="p">.</span><span class="n">precede</span><span class="p">(</span><span class="n">free</span><span class="p">);</span></pre><p>At the last line of the cudaFlow closure, we call <code>cf.offload_n(M)</code> to ask the executor to repeatedly run the cudaFlow by <code>M</code> times. Compared with the version using conditional tasking, the cudaFlow here is created only one time and thus the overhead is reduced.</p><div class="m-graph"><svg style="width: 112.750rem; height: 28.750rem;" viewBox="0.00 0.00 1804.10 460.00">
<g transform="scale(1 1) rotate(0) translate(4 456)">
<title>Taskflow</title>
<g class="m-cluster">
<title>cluster_p0x55764dbce0d0</title>
<polygon points="140.0329,-220 140.0329,-368 590.0329,-368 590.0329,-220 140.0329,-220"/>
<text text-anchor="middle" x="365.0329" y="-351.2">cudaFlow: h2d</text>
</g>
<g class="m-cluster">
<title>cluster_p0x55764dbce1e0</title>
<polygon points="1046.0329,-136 1046.0329,-444 1377.0329,-444 1377.0329,-136 1046.0329,-136"/>
<text text-anchor="middle" x="1211.5329" y="-427.2">cudaFlow: update_means</text>
</g>
<g class="m-cluster">
<title>cluster_p0x55764dbce2f0</title>
<polygon points="1385.0329,-64 1385.0329,-212 1615.0329,-212 1615.0329,-64 1385.0329,-64"/>
<text text-anchor="middle" x="1500.0329" y="-195.2">cudaFlow: d2h</text>
</g>
<g class="m-node m-flat">
<title>p0x55764dbcd960</title>
<ellipse cx="65.0329" cy="-318" rx="65.0658" ry="18"/>
<text text-anchor="middle" x="65.0329" y="-313.2">allocate_px</text>
</g>
<g class="m-node">
<title>p0x55764dbce0d0</title>
<polygon points="563.0329,-264 560.0329,-268 539.0329,-268 536.0329,-264 509.0329,-264 509.0329,-228 563.0329,-228 563.0329,-264"/>
<text text-anchor="middle" x="536.0329" y="-241.2">h2d</text>
</g>
<g class="m-edge">
<title>p0x55764dbcd960&#45;&gt;p0x55764dbce0d0</title>
<path d="M111.8383,-305.3303C119.8737,-303.3861 128.1676,-301.5228 136.0329,-300 268.217,-274.4085 427.3043,-256.8133 498.4518,-249.6271"/>
<polygon points="499.0957,-253.0803 508.698,-248.6031 498.3995,-246.115 499.0957,-253.0803"/>
</g>
<g class="m-node">
<title>p0x55764dbce1e0</title>
<polygon points="1368.8923,-180 1365.8923,-184 1344.8923,-184 1341.8923,-180 1247.1734,-180 1247.1734,-144 1368.8923,-144 1368.8923,-180"/>
<text text-anchor="middle" x="1308.0329" y="-157.2">update_means</text>
</g>
<g class="m-edge">
<title>p0x55764dbce0d0&#45;&gt;p0x55764dbce1e0</title>
<path d="M563.0561,-243.0596C670.8832,-231.3272 1072.4588,-187.6324 1237.0158,-169.7272"/>
<polygon points="1237.4727,-173.1983 1247.0354,-168.637 1236.7154,-166.2394 1237.4727,-173.1983"/>
</g>
<g class="m-node m-flat">
<title>p0x55764dbcda70</title>
<ellipse cx="665.0329" cy="-318" rx="65.0658" ry="18"/>
<text text-anchor="middle" x="665.0329" y="-313.2">allocate_py</text>
</g>
<g class="m-edge">
<title>p0x55764dbcda70&#45;&gt;p0x55764dbce0d0</title>
<path d="M636.0828,-301.8418C617.1438,-291.2712 592.258,-277.3815 572.044,-266.0992"/>
<polygon points="573.5612,-262.9378 563.1234,-261.1203 570.1496,-269.0502 573.5612,-262.9378"/>
</g>
<g class="m-node m-flat">
<title>p0x55764dbcdb80</title>
<ellipse cx="816.0329" cy="-318" rx="68.0088" ry="18"/>
<text text-anchor="middle" x="816.0329" y="-313.2">allocate_mx</text>
</g>
<g class="m-edge">
<title>p0x55764dbcdb80&#45;&gt;p0x55764dbce0d0</title>
<path d="M766.9402,-305.3762C711.6221,-291.1515 622.9429,-268.3483 573.1162,-255.5357"/>
<polygon points="573.9514,-252.1367 563.3948,-253.0359 572.208,-258.9161 573.9514,-252.1367"/>
</g>
<g class="m-node m-flat">
<title>p0x55764dbcdc90</title>
<ellipse cx="970.0329" cy="-318" rx="68.0088" ry="18"/>
<text text-anchor="middle" x="970.0329" y="-313.2">allocate_my</text>
</g>
<g class="m-edge">
<title>p0x55764dbcdc90&#45;&gt;p0x55764dbce0d0</title>
<path d="M920.0384,-305.7047C911.0732,-303.6737 901.796,-301.6843 893.0329,-300 777.2849,-277.7535 638.9724,-259.0546 573.6878,-250.6937"/>
<polygon points="573.8419,-247.1851 563.4801,-249.3946 572.9582,-254.1291 573.8419,-247.1851"/>
</g>
<g class="m-node m-flat">
<title>p0x55764dbcdda0</title>
<ellipse cx="1449.0329" cy="-246" rx="64.3605" ry="18"/>
<text text-anchor="middle" x="1449.0329" y="-241.2">allocate_sx</text>
</g>
<g class="m-edge">
<title>p0x55764dbcdda0&#45;&gt;p0x55764dbce1e0</title>
<path d="M1415.691,-230.462C1404.5007,-224.95 1392.0659,-218.4955 1381.0329,-212 1367.5884,-204.0848 1353.3218,-194.5803 1341.0015,-185.9933"/>
<polygon points="1343.0075,-183.1252 1332.817,-180.2259 1338.9753,-188.8472 1343.0075,-183.1252"/>
</g>
<g class="m-node">
<title>p0x55764dbce2f0</title>
<polygon points="1469.0329,-108 1466.0329,-112 1445.0329,-112 1442.0329,-108 1415.0329,-108 1415.0329,-72 1469.0329,-72 1469.0329,-108"/>
<text text-anchor="middle" x="1442.0329" y="-85.2">d2h</text>
</g>
<g class="m-edge">
<title>p0x55764dbce1e0&#45;&gt;p0x55764dbce2f0</title>
<path d="M1341.8468,-143.8314C1361.3909,-133.33 1385.9753,-120.1205 1405.8994,-109.415"/>
<polygon points="1407.8242,-112.3541 1414.9765,-104.5378 1404.5109,-106.1879 1407.8242,-112.3541"/>
</g>
<g class="m-node m-flat">
<title>p0x55764dbcdeb0</title>
<ellipse cx="1596.0329" cy="-246" rx="64.3605" ry="18"/>
<text text-anchor="middle" x="1596.0329" y="-241.2">allocate_sy</text>
</g>
<g class="m-edge">
<title>p0x55764dbcdeb0&#45;&gt;p0x55764dbce1e0</title>
<path d="M1559.7166,-230.9561C1547.896,-226.6807 1534.5847,-222.5088 1522.0329,-220 1491.2579,-213.8488 1410.7373,-222.1284 1381.0329,-212 1364.8123,-206.4693 1348.8656,-196.2633 1336.0346,-186.5074"/>
<polygon points="1338.0951,-183.6747 1328.0811,-180.215 1333.7519,-189.1644 1338.0951,-183.6747"/>
</g>
<g class="m-node m-flat">
<title>p0x55764dbcdfc0</title>
<ellipse cx="1737.0329" cy="-246" rx="59.1273" ry="18"/>
<text text-anchor="middle" x="1737.0329" y="-241.2">allocate_c</text>
</g>
<g class="m-edge">
<title>p0x55764dbcdfc0&#45;&gt;p0x55764dbce1e0</title>
<path d="M1704.1489,-230.8655C1693.2093,-226.5289 1680.809,-222.3441 1669.0329,-220 1637.6365,-213.7504 1411.4785,-221.8923 1381.0329,-212 1364.6142,-206.6653 1348.5427,-196.3786 1335.6776,-186.5158"/>
<polygon points="1337.7119,-183.6611 1327.715,-180.152 1333.3416,-189.1293 1337.7119,-183.6611"/>
</g>
<g class="m-node m-flat">
<title>p0x7fc258000ba0</title>
<ellipse cx="536.0329" cy="-318" rx="45.892" ry="18"/>
<text text-anchor="middle" x="536.0329" y="-313.2">h2d_px</text>
</g>
<g class="m-edge">
<title>p0x7fc258000ba0&#45;&gt;p0x55764dbce0d0</title>
<path d="M536.0329,-299.8314C536.0329,-292.131 536.0329,-282.9743 536.0329,-274.4166"/>
<polygon points="539.533,-274.4132 536.0329,-264.4133 532.533,-274.4133 539.533,-274.4132"/>
</g>
<g class="m-node m-flat">
<title>p0x7fc258000c40</title>
<ellipse cx="426.0329" cy="-318" rx="45.892" ry="18"/>
<text text-anchor="middle" x="426.0329" y="-313.2">h2d_py</text>
</g>
<g class="m-edge">
<title>p0x7fc258000c40&#45;&gt;p0x55764dbce0d0</title>
<path d="M449.6307,-302.5542C464.4677,-292.8426 483.89,-280.1299 500.5612,-269.2178"/>
<polygon points="502.5394,-272.1062 508.9896,-263.7011 498.7057,-266.2492 502.5394,-272.1062"/>
</g>
<g class="m-node m-flat">
<title>p0x7fc258000dd0</title>
<ellipse cx="313.0329" cy="-318" rx="48.8351" ry="18"/>
<text text-anchor="middle" x="313.0329" y="-313.2">h2d_mx</text>
</g>
<g class="m-edge">
<title>p0x7fc258000dd0&#45;&gt;p0x55764dbce0d0</title>
<path d="M349.8568,-306.1107C391.2278,-292.7532 457.9836,-271.1998 499.3123,-257.856"/>
<polygon points="500.5472,-261.1352 508.9881,-254.7319 498.3964,-254.4738 500.5472,-261.1352"/>
</g>
<g class="m-node m-flat">
<title>p0x7fc258000ea0</title>
<ellipse cx="197.0329" cy="-318" rx="48.8351" ry="18"/>
<text text-anchor="middle" x="197.0329" y="-313.2">h2d_my</text>
</g>
<g class="m-edge">
<title>p0x7fc258000ea0&#45;&gt;p0x55764dbce0d0</title>
<path d="M233.6781,-305.9533C240.726,-303.8281 248.0783,-301.7417 255.0329,-300 341.3216,-278.3903 444.3776,-260.5915 498.5281,-251.845"/>
<polygon points="499.366,-255.2555 508.6866,-250.218 498.2589,-248.3436 499.366,-255.2555"/>
</g>
<g class="m-node m-flat">
<title>p0x55764dbce400</title>
<ellipse cx="1442.0329" cy="-18" rx="29.4575" ry="18"/>
<text text-anchor="middle" x="1442.0329" y="-13.2">free</text>
</g>
<g class="m-edge">
<title>p0x55764dbce2f0&#45;&gt;p0x55764dbce400</title>
<path d="M1442.0329,-71.8314C1442.0329,-64.131 1442.0329,-54.9743 1442.0329,-46.4166"/>
<polygon points="1445.533,-46.4132 1442.0329,-36.4133 1438.533,-46.4133 1445.533,-46.4132"/>
</g>
<g class="m-node m-flat">
<title>p0x7fc2580032e0</title>
<ellipse cx="1326.0329" cy="-394" rx="42.8965" ry="18"/>
<text text-anchor="middle" x="1326.0329" y="-389.2">zero_c</text>
</g>
<g class="m-node">
<title>p0x7fc2580034e0</title>
<polygon points="1293.658,-336 1234.4078,-336 1230.4078,-332 1230.4078,-300 1289.658,-300 1293.658,-304 1293.658,-336"/>
<polyline points="1289.658,-332 1230.4078,-332 "/>
<polyline points="1289.658,-332 1289.658,-300 "/>
<polyline points="1289.658,-332 1293.658,-336 "/>
<text text-anchor="middle" x="1262.0329" y="-313.2">cluster</text>
</g>
<g class="m-edge">
<title>p0x7fc2580032e0&#45;&gt;p0x7fc2580034e0</title>
<path d="M1311.5103,-376.7544C1303.399,-367.1222 1293.1264,-354.9236 1284.0462,-344.1408"/>
<polygon points="1286.5091,-341.6318 1277.3905,-336.2371 1281.1547,-346.1407 1286.5091,-341.6318"/>
</g>
<g class="m-node">
<title>p0x7fc258003580</title>
<polygon points="1340.7049,-264 1233.3609,-264 1229.3609,-260 1229.3609,-228 1336.7049,-228 1340.7049,-232 1340.7049,-264"/>
<polyline points="1336.7049,-260 1229.3609,-260 "/>
<polyline points="1336.7049,-260 1336.7049,-228 "/>
<polyline points="1336.7049,-260 1340.7049,-264 "/>
<text text-anchor="middle" x="1285.0329" y="-241.2">new_centroid</text>
</g>
<g class="m-edge">
<title>p0x7fc2580034e0&#45;&gt;p0x7fc258003580</title>
<path d="M1267.8368,-299.8314C1270.3236,-292.0463 1273.286,-282.7729 1276.0454,-274.1347"/>
<polygon points="1279.4419,-275.0041 1279.1509,-264.4133 1272.7738,-272.874 1279.4419,-275.0041"/>
</g>
<g class="m-node m-flat">
<title>p0x7fc258003380</title>
<ellipse cx="1217.0329" cy="-394" rx="48.1303" ry="18"/>
<text text-anchor="middle" x="1217.0329" y="-389.2">zero_sx</text>
</g>
<g class="m-edge">
<title>p0x7fc258003380&#45;&gt;p0x7fc2580034e0</title>
<path d="M1227.4699,-376.373C1233.0124,-367.0125 1239.9413,-355.3102 1246.1372,-344.8461"/>
<polygon points="1249.2567,-346.4471 1251.34,-336.0591 1243.2334,-342.8806 1249.2567,-346.4471"/>
</g>
<g class="m-node m-flat">
<title>p0x7fc258003440</title>
<ellipse cx="1102.0329" cy="-394" rx="48.1303" ry="18"/>
<text text-anchor="middle" x="1102.0329" y="-389.2">zero_sy</text>
</g>
<g class="m-edge">
<title>p0x7fc258003440&#45;&gt;p0x7fc2580034e0</title>
<path d="M1132.1277,-379.705C1157.3399,-367.7292 1193.5627,-350.5234 1221.3565,-337.3213"/>
<polygon points="1222.8999,-340.463 1230.431,-333.0109 1219.8965,-334.14 1222.8999,-340.463"/>
</g>
<g class="m-edge">
<title>p0x7fc258003580&#45;&gt;p0x55764dbce1e0</title>
<path d="M1290.0236,-227.7733C1293.0375,-216.7657 1296.9409,-202.5098 1300.3428,-190.0854"/>
<polygon points="1303.7868,-190.7605 1303.052,-180.1912 1297.0353,-188.9118 1303.7868,-190.7605"/>
</g>
<g class="m-node m-flat">
<title>p0x7fc258005800</title>
<ellipse cx="1558.0329" cy="-162" rx="48.8351" ry="18"/>
<text text-anchor="middle" x="1558.0329" y="-157.2">d2h_mx</text>
</g>
<g class="m-edge">
<title>p0x7fc258005800&#45;&gt;p0x55764dbce2f0</title>
<path d="M1532.8626,-146.3771C1516.8611,-136.4451 1495.8887,-123.4278 1478.1284,-112.4041"/>
<polygon points="1479.5193,-109.1481 1469.1771,-106.8481 1475.8277,-115.0955 1479.5193,-109.1481"/>
</g>
<g class="m-node m-flat">
<title>p0x7fc2580058a0</title>
<ellipse cx="1442.0329" cy="-162" rx="48.8351" ry="18"/>
<text text-anchor="middle" x="1442.0329" y="-157.2">d2h_my</text>
</g>
<g class="m-edge">
<title>p0x7fc2580058a0&#45;&gt;p0x55764dbce2f0</title>
<path d="M1442.0329,-143.8314C1442.0329,-136.131 1442.0329,-126.9743 1442.0329,-118.4166"/>
<polygon points="1445.533,-118.4132 1442.0329,-108.4133 1438.533,-118.4133 1445.533,-118.4132"/>
</g>
</g>
</svg>
</div><p>We can see from the above taskflow the condition task is removed.</p></section><section id="KMeansBenchmarking"><h2><a href="#KMeansBenchmarking">Benchmarking</a></h2><p>We run three versions of k-means, sequential CPU, parallel CPUs, and one GPU, on a machine of 6 Intel i7-8700 CPUs at 3.20GHz and a Nvidia RTX 2080 GPU using various numbers of 2D point counts and iterations.</p><table class="m-table"><thead><tr><th>N</th><th>K</th><th>M</th><th>CPU Sequential</th><th>CPU Parallel</th><th>GPU (conditional taksing)</th><th>GPU (with predicate)</th></tr></thead><tbody><tr><td>10</td><td>5</td><td>10</td><td>0.14 ms</td><td>77 ms</td><td>1 ms</td><td>1 ms</td></tr><tr><td>100</td><td>10</td><td>100</td><td>0.56 ms</td><td>86 ms</td><td>7 ms</td><td>1 ms</td></tr><tr><td>1000</td><td>10</td><td>1000</td><td>10 ms</td><td>98 ms</td><td>55 ms</td><td>13 ms</td></tr><tr><td>10000</td><td>10</td><td>10000</td><td>1006 ms</td><td>713 ms</td><td>458 ms</td><td>183 ms</td></tr><tr><td>100000</td><td>10</td><td>100000</td><td>102483 ms</td><td>49966 ms</td><td>7952 ms</td><td>4725 ms</td></tr></tbody></table><p>When the number of points is larger than 10K, both parallel CPU and GPU implementations start to pick up the speed over than the sequential version. We can see using the built-in predicate of cudaFlow is two times faster than conditional tasking.</p></section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim"></span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim"></span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v1.js"></script>
<script src="searchdata-v1.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Taskflow handbook is part of the <a href="https://taskflow.github.io">Taskflow project</a>, copyright  <a href="https://tsung-wei-huang.github.io/">Dr. Tsung-Wei Huang</a>, 2018&ndash;2020.<br />Generated by <a href="https://doxygen.org/">Doxygen</a> 1.8.14 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
