<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>tf::TaskGroup class | Taskflow QuickStart</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,400i,600,600i%7CSource+Code+Pro:400,400i,600" />
  <link rel="stylesheet" href="m-dark+documentation.compiled.css" />
  <link rel="icon" href="favicon.ico" type="image/vnd.microsoft.icon" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#22272e" />
</head>
<body>
<header><nav id="navigation">
  <div class="m-container">
    <div class="m-row">
      <span id="m-navbar-brand" class="m-col-t-8 m-col-m-none m-left-m">
        <a href="https://taskflow.github.io"><img src="taskflow_logo.png" alt="" />Taskflow</a> <span class="m-breadcrumb">|</span> <a href="index.html" class="m-thin">QuickStart</a>
      </span>
      <div class="m-col-t-4 m-hide-m m-text-right m-nopadr">
        <a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
          <path id="m-doc-search-icon-path" d="m6 0c-3.31 0-6 2.69-6 6 0 3.31 2.69 6 6 6 1.49 0 2.85-0.541 3.89-1.44-0.0164 0.338 0.147 0.759 0.5 1.15l3.22 3.79c0.552 0.614 1.45 0.665 2 0.115 0.55-0.55 0.499-1.45-0.115-2l-3.79-3.22c-0.392-0.353-0.812-0.515-1.15-0.5 0.895-1.05 1.44-2.41 1.44-3.89 0-3.31-2.69-6-6-6zm0 1.56a4.44 4.44 0 0 1 4.44 4.44 4.44 4.44 0 0 1-4.44 4.44 4.44 4.44 0 0 1-4.44-4.44 4.44 4.44 0 0 1 4.44-4.44z"/>
        </svg></a>
        <a id="m-navbar-show" href="#navigation" title="Show navigation"></a>
        <a id="m-navbar-hide" href="#" title="Hide navigation"></a>
      </div>
      <div id="m-navbar-collapse" class="m-col-t-12 m-show-m m-col-m-none m-right-m">
        <div class="m-row">
          <ol class="m-col-t-6 m-col-m-none">
            <li><a href="pages.html">Handbook</a></li>
            <li><a href="namespaces.html">Namespaces</a></li>
          </ol>
          <ol class="m-col-t-6 m-col-m-none" start="3">
            <li><a href="annotated.html">Classes</a></li>
            <li><a href="files.html">Files</a></li>
            <li class="m-show-m"><a href="#search" class="m-doc-search-icon" title="Search" onclick="return showSearch()"><svg style="height: 0.9rem;" viewBox="0 0 16 16">
              <use href="#m-doc-search-icon-path" />
            </svg></a></li>
          </ol>
        </div>
      </div>
    </div>
  </div>
</nav></header>
<main><article>
  <div class="m-container m-container-inflatable">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <h1>
          <span class="m-breadcrumb"><a href="namespacetf.html">tf</a>::<wbr/></span>TaskGroup <span class="m-thin">class</span>
        </h1>
        <p>class to create a task group from a task</p>
        <nav class="m-block m-default">
          <h3>Contents</h3>
          <ul>
            <li>
              Reference
              <ul>
                <li><a href="#typeless-methods">Constructors, destructors, conversion operators</a></li>
                <li><a href="#pub-methods">Public functions</a></li>
              </ul>
            </li>
          </ul>
        </nav>
<p>A task group executes a group of asynchronous tasks. It enables asynchronous task spawning, cooperative execution among worker threads, and naturally supports recursive parallelism. Due to cooperative execution, a task group can only be created by an executor worker; otherwise an exception will be thrown. The code below demonstrates how to use task groups to implement recursive Fibonacci parallelism.</p><pre class="m-code"><span class="n">tf</span><span class="o">::</span><span class="n">Executor</span><span class="w"> </span><span class="n">executor</span><span class="p">;</span>

<span class="kt">size_t</span><span class="w"> </span><span class="nf">fibonacci</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">N</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">N</span><span class="p">;</span>

<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">res1</span><span class="p">,</span><span class="w"> </span><span class="n">res2</span><span class="p">;</span>

<span class="w">  </span><span class="c1">// Create a task group from the current executor</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">TaskGroup</span><span class="w"> </span><span class="n">tg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">get_executor</span><span class="p">().</span><span class="n">task_group</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// Submit asynchronous tasks to the group</span>
<span class="w">  </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="n">N</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">res1</span><span class="p">](){</span><span class="w"> </span><span class="n">res1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fibonacci</span><span class="p">(</span><span class="n">N</span><span class="mi">-1</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="n">res2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fibonacci</span><span class="p">(</span><span class="n">N</span><span class="mi">-2</span><span class="p">);</span><span class="w">  </span><span class="c1">// compute one branch synchronously</span>

<span class="w">  </span><span class="c1">// Wait for all tasks in the group to complete</span>
<span class="w">  </span><span class="n">tg</span><span class="p">.</span><span class="n">corun</span><span class="p">();</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">res1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">res2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="kt">size_t</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">30</span><span class="p">,</span><span class="w"> </span><span class="n">res</span><span class="p">;</span>
<span class="w">  </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">executor</span><span class="p">.</span><span class="n">async</span><span class="p">([](){</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">fibonacci</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span><span class="w"> </span><span class="p">}).</span><span class="n">get</span><span class="p">();</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;-th Fibonacci number is &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span></pre><p>Users must explicitly call <a href="#a1f481dc466e3107a08346d1a124677bc" class="m-doc">tf::<wbr />TaskGroup::<wbr />corun()</a> to ensure that all tasks have completed or been properly canceled before leaving the scope of a task group. Failing to do so results in undefined behavior.</p><aside class="m-note m-info"><h4>Note</h4><p>To understand how Taskflow schedules a task group, please refer to <a href="TaskGroup.html" class="m-doc">Task Group</a>.</p></aside>
        <section id="typeless-methods">
          <h2><a href="#typeless-methods">Constructors, destructors, conversion operators</a></h2>
          <dl class="m-doc">
            <dt id="ab4f3fec3f8ec46b65379e7f2a7eb809f">
              <span class="m-doc-wrap-bumper"><a href="#ab4f3fec3f8ec46b65379e7f2a7eb809f" class="m-doc-self">TaskGroup</a>(</span><span class="m-doc-wrap">const <a href="classtf_1_1TaskGroup.html" class="m-doc">TaskGroup</a>&amp;) <span class="m-label m-flat m-danger">deleted</span></span>
            </dt>
            <dd>disabled copy constructor</dd>
            <dt id="aa2c2252cb4c40db3abe4eba954562389">
              <span class="m-doc-wrap-bumper"><a href="#aa2c2252cb4c40db3abe4eba954562389" class="m-doc-self">TaskGroup</a>(</span><span class="m-doc-wrap"><a href="classtf_1_1TaskGroup.html" class="m-doc">TaskGroup</a>&amp;&amp;) <span class="m-label m-flat m-danger">deleted</span></span>
            </dt>
            <dd>disabled move constructor</dd>
          </dl>
        </section>
        <section id="pub-methods">
          <h2><a href="#pub-methods">Public functions</a></h2>
          <dl class="m-doc">
            <dt id="a79d3fa948a82b772df925e94822a0c90">
              <span class="m-doc-wrap-bumper">auto <a href="#a79d3fa948a82b772df925e94822a0c90" class="m-doc-self">operator=</a>(</span><span class="m-doc-wrap"><a href="classtf_1_1TaskGroup.html" class="m-doc">TaskGroup</a>&amp;&amp;) -&gt; <a href="classtf_1_1TaskGroup.html" class="m-doc">TaskGroup</a>&amp; <span class="m-label m-flat m-danger">deleted</span></span>
            </dt>
            <dd>disabled copy assignment</dd>
            <dt id="a77f8ee98c3a90b061125504f0adbf02a">
              <span class="m-doc-wrap-bumper">auto <a href="#a77f8ee98c3a90b061125504f0adbf02a" class="m-doc-self">operator=</a>(</span><span class="m-doc-wrap">const <a href="classtf_1_1TaskGroup.html" class="m-doc">TaskGroup</a>&amp;) -&gt; <a href="classtf_1_1TaskGroup.html" class="m-doc">TaskGroup</a>&amp; <span class="m-label m-flat m-danger">deleted</span></span>
            </dt>
            <dd>disabled move assignment</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#ac39e984ac576ff1e959059abd7b57aa5" class="m-doc">executor</a>(</span><span class="m-doc-wrap">) -&gt; <a href="classtf_1_1Executor.html" class="m-doc">Executor</a>&amp;</span>
            </dt>
            <dd>obtains the executor that creates this task group</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename F&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a65915370b458e982e04ebfbd46bb92c6" class="m-doc">async</a>(</span><span class="m-doc-wrap">F&amp;&amp; f) -&gt; auto</span>
            </dt>
            <dd>runs the given callable asynchronously</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename P, typename F&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a43ed0269d8301a11b9d92719ffecdb4a" class="m-doc">async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; f) -&gt; auto</span>
            </dt>
            <dd>runs the given callable asynchronously</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename F&gt;</div>
              <span class="m-doc-wrap-bumper">void <a href="#acf90acfcaf9468adc56bf647208a9e78" class="m-doc">silent_async</a>(</span><span class="m-doc-wrap">F&amp;&amp; f)</span>
            </dt>
            <dd>runs the given function asynchronously without returning any future object</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename P, typename F&gt;</div>
              <span class="m-doc-wrap-bumper">void <a href="#ac3284167c1e67bed2590d075eead9741" class="m-doc">silent_async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; f)</span>
            </dt>
            <dd>runs the given function asynchronously without returning any future object</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename F, typename... Tasks, std::enable_if_t&lt;all_same_v&lt;<a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>, std::decay_t&lt;Tasks&gt;...&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#af6ff72a4019da86f2234bea66a6abb98" class="m-doc">dependent_async</a>(</span><span class="m-doc-wrap">F&amp;&amp; func,
              Tasks &amp;&amp; ... tasks) -&gt; auto</span>
            </dt>
            <dd>runs the given function asynchronously when the given predecessors finish</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename P, typename F, typename... Tasks, std::enable_if_t&lt;<a href="namespacetf.html#ad3a41adc2499a9519da3e77dc3e9849c" class="m-doc">is_<wbr />task_<wbr />params_<wbr />v</a>&lt;P&gt; &amp;&amp; all_same_v&lt;<a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>, std::decay_t&lt;Tasks&gt;...&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#ae18cf8b8470943ff712caebb473691a0" class="m-doc">dependent_async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; func,
              Tasks &amp;&amp; ... tasks) -&gt; auto</span>
            </dt>
            <dd>runs the given function asynchronously when the given predecessors finish</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename F, typename I, std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;I&gt;, <a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#ab5dc02bad3b9503216037d048a0a62d7" class="m-doc">dependent_async</a>(</span><span class="m-doc-wrap">F&amp;&amp; func,
              I first,
              I last) -&gt; auto</span>
            </dt>
            <dd>runs the given function asynchronously when the given range of predecessors finish</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename P, typename F, typename I, std::enable_if_t&lt;<a href="namespacetf.html#ad3a41adc2499a9519da3e77dc3e9849c" class="m-doc">is_<wbr />task_<wbr />params_<wbr />v</a>&lt;P&gt; &amp;&amp; !std::is_same_v&lt;std::decay_t&lt;I&gt;, <a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a578f058ea088ebc0ed097b1b77a4052d" class="m-doc">dependent_async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; func,
              I first,
              I last) -&gt; auto</span>
            </dt>
            <dd>runs the given function asynchronously when the given range of predecessors finish</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename F, typename... Tasks, std::enable_if_t&lt;all_same_v&lt;<a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>, std::decay_t&lt;Tasks&gt;...&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a4eab3bb447361a2de8680fa7aab18f8c" class="m-doc">silent_dependent_async</a>(</span><span class="m-doc-wrap">F&amp;&amp; func,
              Tasks &amp;&amp; ... tasks) -&gt; <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a></span>
            </dt>
            <dd>runs the given function asynchronously when the given predecessors finish</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename P, typename F, typename... Tasks, std::enable_if_t&lt;<a href="namespacetf.html#ad3a41adc2499a9519da3e77dc3e9849c" class="m-doc">is_<wbr />task_<wbr />params_<wbr />v</a>&lt;P&gt; &amp;&amp; all_same_v&lt;<a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>, std::decay_t&lt;Tasks&gt;...&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#a860b4bddc6739ff8f772597ae2bbe6ce" class="m-doc">silent_dependent_async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; func,
              Tasks &amp;&amp; ... tasks) -&gt; <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a></span>
            </dt>
            <dd>runs the given function asynchronously when the given predecessors finish</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename F, typename I, std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;I&gt;, <a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#ab1a058131a088a258febbc40fdef82e7" class="m-doc">silent_dependent_async</a>(</span><span class="m-doc-wrap">F&amp;&amp; func,
              I first,
              I last) -&gt; <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a></span>
            </dt>
            <dd>runs the given function asynchronously when the given range of predecessors finish</dd>
            <dt>
              <div class="m-doc-template">template&lt;typename P, typename F, typename I, std::enable_if_t&lt;<a href="namespacetf.html#ad3a41adc2499a9519da3e77dc3e9849c" class="m-doc">is_<wbr />task_<wbr />params_<wbr />v</a>&lt;P&gt; &amp;&amp; !std::is_same_v&lt;std::decay_t&lt;I&gt;, <a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>&gt;, void&gt;* = nullptr&gt;</div>
              <span class="m-doc-wrap-bumper">auto <a href="#ac00237c032d82e008cdd7a8080dcdee8" class="m-doc">silent_dependent_async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; func,
              I first,
              I last) -&gt; <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a></span>
            </dt>
            <dd>runs the given function asynchronously when the given range of predecessors finish</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#a1f481dc466e3107a08346d1a124677bc" class="m-doc">corun</a>(</span><span class="m-doc-wrap">)</span>
            </dt>
            <dd>corun all tasks spawned by this task group with other workers</dd>
            <dt>
              <span class="m-doc-wrap-bumper">void <a href="#a2d32e816db51666b721d8b3d538e4066" class="m-doc">cancel</a>(</span><span class="m-doc-wrap">)</span>
            </dt>
            <dd>cancel all tasks in this task group</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#aa199904b8123c345df37df4360950fa7" class="m-doc">is_cancelled</a>(</span><span class="m-doc-wrap">) -&gt; bool</span>
            </dt>
            <dd>queries if the task group has been cancelled</dd>
            <dt>
              <span class="m-doc-wrap-bumper">auto <a href="#a2ff79bbacb724a4e99f3a65030bbd402" class="m-doc">size</a>(</span><span class="m-doc-wrap">) const -&gt; size_t</span>
            </dt>
            <dd>queries the number of tasks currently in this task group</dd>
          </dl>
        </section>
        <section>
          <h2>Function documentation</h2>
          <section class="m-doc-details" id="ac39e984ac576ff1e959059abd7b57aa5"><div>
            <h3>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1Executor.html" class="m-doc">Executor</a>&amp; tf::<wbr />TaskGroup::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ac39e984ac576ff1e959059abd7b57aa5" class="m-doc-self">executor</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>obtains the executor that creates this task group</p>
<p>The running executor of a task group is the executor that creates the task group.</p><pre class="m-code"><span class="n">executor</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">TaskGroup</span><span class="w"> </span><span class="n">tg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">executor</span><span class="p">.</span><span class="n">task_group</span><span class="p">();</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">tg</span><span class="p">.</span><span class="n">executor</span><span class="p">())</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="o">&amp;</span><span class="n">executor</span><span class="p">);</span>
<span class="p">});</span></pre>
          </div></section>
          <section class="m-doc-details" id="a65915370b458e982e04ebfbd46bb92c6"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename F&gt;
              </div>
              <span class="m-doc-wrap-bumper">auto tf::<wbr />TaskGroup::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a65915370b458e982e04ebfbd46bb92c6" class="m-doc-self">async</a>(</span><span class="m-doc-wrap">F&amp;&amp; f)</span></span>
            </h3>
            <p>runs the given callable asynchronously</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">F</td>
                  <td>callable type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>f</td>
                  <td>callable object</td>
                </tr>
              </tbody>
            </table>
<p>This method creates an asynchronous task that executes the given function with the specified arguments. Unlike <a href="classtf_1_1Executor.html#af960048056f7c6b5bc71f4f526f05df7" class="m-doc">tf::<wbr />Executor::<wbr />async</a>, the task created here is parented to the task group, where applications can issue <a href="#a1f481dc466e3107a08346d1a124677bc" class="m-doc">tf::<wbr />TaskGroup::<wbr />corun</a> to explicitly wait for all asynchronous tasks spawned from the task group to complete. For example:</p><pre class="m-code"><span class="n">executor</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">counter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">tg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">executor</span><span class="p">.</span><span class="n">task_group</span><span class="p">();</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">fu1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tg</span><span class="p">.</span><span class="n">async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span><span class="w"> </span><span class="n">counter</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">fu2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tg</span><span class="p">.</span><span class="n">async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span><span class="w"> </span><span class="n">counter</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="n">fu1</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="w">  </span><span class="n">fu2</span><span class="p">.</span><span class="n">get</span><span class="p">();</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// spawn 100 asynchronous tasks from the task group</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span><span class="w"> </span><span class="n">counter</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="c1">// corun until the 100 asynchronous tasks have completed</span>
<span class="w">  </span><span class="n">tg</span><span class="p">.</span><span class="n">corun</span><span class="p">();</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">102</span><span class="p">);</span>
<span class="w">  </span><span class="c1">// do something else afterwards ...</span>
<span class="p">});</span></pre>
          </div></section>
          <section class="m-doc-details" id="a43ed0269d8301a11b9d92719ffecdb4a"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename P, typename F&gt;
              </div>
              <span class="m-doc-wrap-bumper">auto tf::<wbr />TaskGroup::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a43ed0269d8301a11b9d92719ffecdb4a" class="m-doc-self">async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; f)</span></span>
            </h3>
            <p>runs the given callable asynchronously</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">P</td>
                  <td>task parameters type</td>
                </tr>
                <tr>
                  <td>F</td>
                  <td>callable type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>params</td>
                  <td>task parameters</td>
                </tr>
                <tr>
                  <td>f</td>
                  <td>callable</td>
                </tr>
              </tbody>
            </table>
<p>Similar to <a href="#a65915370b458e982e04ebfbd46bb92c6" class="m-doc">tf::<wbr />TaskGroup::<wbr />async</a>, but takes a parameter of type <a href="classtf_1_1TaskParams.html" class="m-doc">tf::<wbr />TaskParams</a> to initialize the asynchronous task.</p><pre class="m-code"><span class="n">executor</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">tg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">executor</span><span class="p">.</span><span class="n">task_group</span><span class="p">();</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">future</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tg</span><span class="p">.</span><span class="n">async</span><span class="p">(</span><span class="s">&quot;my task&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">future</span><span class="p">.</span><span class="n">get</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<span class="p">});</span></pre>
          </div></section>
          <section class="m-doc-details" id="acf90acfcaf9468adc56bf647208a9e78"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename F&gt;
              </div>
              <span class="m-doc-wrap-bumper">void tf::<wbr />TaskGroup::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#acf90acfcaf9468adc56bf647208a9e78" class="m-doc-self">silent_async</a>(</span><span class="m-doc-wrap">F&amp;&amp; f)</span></span>
            </h3>
            <p>runs the given function asynchronously without returning any future object</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">F</td>
                  <td>callable type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>f</td>
                  <td>callable</td>
                </tr>
              </tbody>
            </table>
<p>This function is more efficient than <a href="#a65915370b458e982e04ebfbd46bb92c6" class="m-doc">tf::<wbr />TaskGroup::<wbr />async</a> and is recommended when the result of the asynchronous task does not need to be accessed via a <a href="http://en.cppreference.com/w/cpp/thread/future.html" class="m-doc-external">std::<wbr />future</a>.</p><pre class="m-code"><span class="n">executor</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">counter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">tg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">executor</span><span class="p">.</span><span class="n">task_group</span><span class="p">();</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span><span class="w"> </span><span class="n">counter</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">tg</span><span class="p">.</span><span class="n">corun</span><span class="p">();</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span>
<span class="p">});</span></pre>
          </div></section>
          <section class="m-doc-details" id="ac3284167c1e67bed2590d075eead9741"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename P, typename F&gt;
              </div>
              <span class="m-doc-wrap-bumper">void tf::<wbr />TaskGroup::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ac3284167c1e67bed2590d075eead9741" class="m-doc-self">silent_async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; f)</span></span>
            </h3>
            <p>runs the given function asynchronously without returning any future object</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">F</td>
                  <td>callable type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>params</td>
                  <td>task parameters</td>
                </tr>
                <tr>
                  <td>f</td>
                  <td>callable</td>
                </tr>
              </tbody>
            </table>
<p>Similar to <a href="#acf90acfcaf9468adc56bf647208a9e78" class="m-doc">tf::<wbr />TaskGroup::<wbr />silent_async</a>, but takes a parameter of type <a href="classtf_1_1TaskParams.html" class="m-doc">tf::<wbr />TaskParams</a> to initialize the created asynchronous task.</p><pre class="m-code"><span class="n">executor</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">tg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">executor</span><span class="p">.</span><span class="n">task_group</span><span class="p">();</span>
<span class="w">  </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_async</span><span class="p">(</span><span class="s">&quot;my task&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){});</span>
<span class="w">  </span><span class="n">tg</span><span class="p">.</span><span class="n">corun</span><span class="p">();</span>
<span class="p">});</span></pre>
          </div></section>
          <section class="m-doc-details" id="af6ff72a4019da86f2234bea66a6abb98"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename F, typename... Tasks, std::enable_if_t&lt;all_same_v&lt;<a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>, std::decay_t&lt;Tasks&gt;...&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper">auto tf::<wbr />TaskGroup::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#af6ff72a4019da86f2234bea66a6abb98" class="m-doc-self">dependent_async</a>(</span><span class="m-doc-wrap">F&amp;&amp; func,
              Tasks &amp;&amp; ... tasks)</span></span>
            </h3>
            <p>runs the given function asynchronously when the given predecessors finish</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">F</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>Tasks</td>
                  <td>tasks of type <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a></td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>func</td>
                  <td>callable object</td>
                </tr>
                <tr>
                  <td>tasks</td>
                  <td>asynchronous tasks on which this execution depends</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a pair of a <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle and a <a href="https://en.cppreference.com/w/cpp/thread/future">std::<wbr />future</a> that holds the result of the execution</td>
                </tr>
              </tfoot>
            </table>
<p>The example below creates three asynchronous tasks, <code>A</code>, <code>B</code>, and <code>C</code>, in which task <code>C</code> runs after task <code>A</code> and task <code>B</code>. Task <code>C</code> returns a pair of its <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle and a std::future&lt;int&gt; that eventually will hold the result of the execution.</p><pre class="m-code"><span class="n">executor</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">tg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">executor</span><span class="p">.</span><span class="n">task_group</span><span class="p">();</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;A</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">fuC</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tg</span><span class="p">.</span><span class="n">dependent_async</span><span class="p">(</span>
<span class="w">    </span><span class="p">[](){</span><span class="w"> </span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C runs after A and B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span>
<span class="w">    </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="n">fuC</span><span class="p">.</span><span class="n">get</span><span class="p">();</span><span class="w">  </span><span class="c1">// C finishes, which in turns means both A and B finish,</span>
<span class="w">              </span><span class="c1">// so we don&#39;t need tg.corun()</span>
<span class="p">});</span></pre>
          </div></section>
          <section class="m-doc-details" id="ae18cf8b8470943ff712caebb473691a0"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename P, typename F, typename... Tasks, std::enable_if_t&lt;<a href="namespacetf.html#ad3a41adc2499a9519da3e77dc3e9849c" class="m-doc">is_<wbr />task_<wbr />params_<wbr />v</a>&lt;P&gt; &amp;&amp; all_same_v&lt;<a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>, std::decay_t&lt;Tasks&gt;...&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper">auto tf::<wbr />TaskGroup::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ae18cf8b8470943ff712caebb473691a0" class="m-doc-self">dependent_async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; func,
              Tasks &amp;&amp; ... tasks)</span></span>
            </h3>
            <p>runs the given function asynchronously when the given predecessors finish</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">P</td>
                  <td>task parameters type</td>
                </tr>
                <tr>
                  <td>F</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>Tasks</td>
                  <td>tasks of type <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a></td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>params</td>
                  <td>task parameters</td>
                </tr>
                <tr>
                  <td>func</td>
                  <td>callable object</td>
                </tr>
                <tr>
                  <td>tasks</td>
                  <td>asynchronous tasks on which this execution depends</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a pair of a <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle and a <a href="https://en.cppreference.com/w/cpp/thread/future">std::<wbr />future</a> that holds the result of the execution</td>
                </tr>
              </tfoot>
            </table>
<p>The example below creates three named asynchronous tasks, <code>A</code>, <code>B</code>, and <code>C</code>, in which task <code>C</code> runs after task <code>A</code> and task <code>B</code>. Task <code>C</code> returns a pair of its <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle and a std::future&lt;int&gt; that eventually will hold the result of the execution. Assigned task names will appear in the observers of the executor.</p><pre class="m-code"><span class="n">executor</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">tg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">executor</span><span class="p">.</span><span class="n">task_group</span><span class="p">();</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;A</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">fuC</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tg</span><span class="p">.</span><span class="n">dependent_async</span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;C&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[](){</span><span class="w"> </span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C runs after A and B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span>
<span class="w">    </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="n">fuC</span><span class="p">.</span><span class="n">get</span><span class="p">();</span><span class="w">  </span><span class="c1">// C finishes, which in turns means both A and B finish,</span>
<span class="w">              </span><span class="c1">// so we don&#39;t need tg.corun()</span>
<span class="p">});</span></pre>
          </div></section>
          <section class="m-doc-details" id="ab5dc02bad3b9503216037d048a0a62d7"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename F, typename I, std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;I&gt;, <a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper">auto tf::<wbr />TaskGroup::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ab5dc02bad3b9503216037d048a0a62d7" class="m-doc-self">dependent_async</a>(</span><span class="m-doc-wrap">F&amp;&amp; func,
              I first,
              I last)</span></span>
            </h3>
            <p>runs the given function asynchronously when the given range of predecessors finish</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">F</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>I</td>
                  <td>iterator type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>func</td>
                  <td>callable object</td>
                </tr>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a pair of a <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle and a <a href="https://en.cppreference.com/w/cpp/thread/future">std::<wbr />future</a> that holds the result of the execution</td>
                </tr>
              </tfoot>
            </table>
<p>The example below creates three asynchronous tasks, <code>A</code>, <code>B</code>, and <code>C</code>, in which task <code>C</code> runs after task <code>A</code> and task <code>B</code>. Task <code>C</code> returns a pair of its <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle and a std::future&lt;int&gt; that eventually will hold the result of the execution.</p><pre class="m-code"><span class="n">executor</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([](){</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">tg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">executor</span><span class="p">.</span><span class="n">task_group</span><span class="p">();</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;A</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}),</span>
<span class="w">    </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">})</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">fuC</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tg</span><span class="p">.</span><span class="n">dependent_async</span><span class="p">(</span>
<span class="w">    </span><span class="p">[](){</span><span class="w"> </span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C runs after A and B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span>
<span class="w">    </span><span class="n">array</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">end</span><span class="p">()</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="n">fuC</span><span class="p">.</span><span class="n">get</span><span class="p">();</span><span class="w">  </span><span class="c1">// C finishes, which in turns means both A and B finish,</span>
<span class="w">              </span><span class="c1">// so we don&#39;t need tg.corun()</span>
<span class="p">});</span><span class="w"> </span></pre>
          </div></section>
          <section class="m-doc-details" id="a578f058ea088ebc0ed097b1b77a4052d"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename P, typename F, typename I, std::enable_if_t&lt;<a href="namespacetf.html#ad3a41adc2499a9519da3e77dc3e9849c" class="m-doc">is_<wbr />task_<wbr />params_<wbr />v</a>&lt;P&gt; &amp;&amp; !std::is_same_v&lt;std::decay_t&lt;I&gt;, <a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper">auto tf::<wbr />TaskGroup::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a578f058ea088ebc0ed097b1b77a4052d" class="m-doc-self">dependent_async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; func,
              I first,
              I last)</span></span>
            </h3>
            <p>runs the given function asynchronously when the given range of predecessors finish</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">P</td>
                  <td>task parameters type</td>
                </tr>
                <tr>
                  <td>F</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>I</td>
                  <td>iterator type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>params</td>
                  <td>task parameters</td>
                </tr>
                <tr>
                  <td>func</td>
                  <td>callable object</td>
                </tr>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a pair of a <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle and a <a href="https://en.cppreference.com/w/cpp/thread/future">std::<wbr />future</a> that holds the result of the execution</td>
                </tr>
              </tfoot>
            </table>
<p>The example below creates three named asynchronous tasks, <code>A</code>, <code>B</code>, and <code>C</code>, in which task <code>C</code> runs after task <code>A</code> and task <code>B</code>. Task <code>C</code> returns a pair of its <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle and a std::future&lt;int&gt; that eventually will hold the result of the execution. Assigned task names will appear in the observers of the executor.</p><pre class="m-code"><span class="n">executor</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">tg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">executor</span><span class="p">.</span><span class="n">task_group</span><span class="p">();</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;A</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}),</span>
<span class="w">    </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">})</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">fuC</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tg</span><span class="p">.</span><span class="n">dependent_async</span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;C&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="p">[](){</span><span class="w"> </span>
<span class="w">      </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C runs after A and B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">},</span><span class="w"> </span>
<span class="w">    </span><span class="n">array</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">end</span><span class="p">()</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="n">fuC</span><span class="p">.</span><span class="n">get</span><span class="p">();</span><span class="w">  </span><span class="c1">// C finishes, which in turns means both A and B finish,</span>
<span class="w">              </span><span class="c1">// so we don&#39;t need tg.corun()</span>
<span class="p">});</span></pre>
          </div></section>
          <section class="m-doc-details" id="a4eab3bb447361a2de8680fa7aab18f8c"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename F, typename... Tasks, std::enable_if_t&lt;all_same_v&lt;<a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>, std::decay_t&lt;Tasks&gt;...&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> tf::<wbr />TaskGroup::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a4eab3bb447361a2de8680fa7aab18f8c" class="m-doc-self">silent_dependent_async</a>(</span><span class="m-doc-wrap">F&amp;&amp; func,
              Tasks &amp;&amp; ... tasks)</span></span>
            </h3>
            <p>runs the given function asynchronously when the given predecessors finish</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">F</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>Tasks</td>
                  <td>tasks of type <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a></td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>func</td>
                  <td>callable object</td>
                </tr>
                <tr>
                  <td>tasks</td>
                  <td>asynchronous tasks on which this execution depends</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>This member function is more efficient than <a href="#af6ff72a4019da86f2234bea66a6abb98" class="m-doc">tf::<wbr />TaskGroup::<wbr />dependent_async</a> and is encouraged to use when you do not want a <a href="https://en.cppreference.com/w/cpp/thread/future">std::<wbr />future</a> to acquire the result or synchronize the execution. The example below creates three asynchronous tasks, <code>A</code>, <code>B</code>, and <code>C</code>, in which task <code>C</code> runs after task <code>A</code> and task <code>B</code>.</p><pre class="m-code"><span class="n">executor</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">tg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">executor</span><span class="p">.</span><span class="n">task_group</span><span class="p">();</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;A</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C runs after A and B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="p">);</span>
<span class="w">  </span><span class="n">tg</span><span class="p">.</span><span class="n">corun</span><span class="p">();</span><span class="w">  </span><span class="c1">// corun until all dependent-async tasks finish</span>
<span class="p">});</span></pre>
          </div></section>
          <section class="m-doc-details" id="a860b4bddc6739ff8f772597ae2bbe6ce"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename P, typename F, typename... Tasks, std::enable_if_t&lt;<a href="namespacetf.html#ad3a41adc2499a9519da3e77dc3e9849c" class="m-doc">is_<wbr />task_<wbr />params_<wbr />v</a>&lt;P&gt; &amp;&amp; all_same_v&lt;<a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>, std::decay_t&lt;Tasks&gt;...&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> tf::<wbr />TaskGroup::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a860b4bddc6739ff8f772597ae2bbe6ce" class="m-doc-self">silent_dependent_async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; func,
              Tasks &amp;&amp; ... tasks)</span></span>
            </h3>
            <p>runs the given function asynchronously when the given predecessors finish</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">F</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>Tasks</td>
                  <td>tasks of type <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a></td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>params</td>
                  <td>task parameters</td>
                </tr>
                <tr>
                  <td>func</td>
                  <td>callable object</td>
                </tr>
                <tr>
                  <td>tasks</td>
                  <td>asynchronous tasks on which this execution depends</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>This member function is more efficient than <a href="#af6ff72a4019da86f2234bea66a6abb98" class="m-doc">tf::<wbr />TaskGroup::<wbr />dependent_async</a> and is encouraged to use when you do not want a <a href="https://en.cppreference.com/w/cpp/thread/future">std::<wbr />future</a> to acquire the result or synchronize the execution. The example below creates three asynchronous tasks, <code>A</code>, <code>B</code>, and <code>C</code>, in which task <code>C</code> runs after task <code>A</code> and task <code>B</code>. Assigned task names will appear in the observers of the executor.</p><pre class="m-code"><span class="n">executor</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">tg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">executor</span><span class="p">.</span><span class="n">task_group</span><span class="p">();</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;A</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;C&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C runs after A and B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">B</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="n">tg</span><span class="p">.</span><span class="n">corun</span><span class="p">();</span><span class="w">  </span><span class="c1">// corun until all dependent-async tasks finish</span>
<span class="p">});</span><span class="w"> </span></pre>
          </div></section>
          <section class="m-doc-details" id="ab1a058131a088a258febbc40fdef82e7"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename F, typename I, std::enable_if_t&lt;!std::is_same_v&lt;std::decay_t&lt;I&gt;, <a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> tf::<wbr />TaskGroup::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ab1a058131a088a258febbc40fdef82e7" class="m-doc-self">silent_dependent_async</a>(</span><span class="m-doc-wrap">F&amp;&amp; func,
              I first,
              I last)</span></span>
            </h3>
            <p>runs the given function asynchronously when the given range of predecessors finish</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">F</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>I</td>
                  <td>iterator type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>func</td>
                  <td>callable object</td>
                </tr>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>This member function is more efficient than <a href="#af6ff72a4019da86f2234bea66a6abb98" class="m-doc">tf::<wbr />TaskGroup::<wbr />dependent_async</a> and is encouraged to use when you do not want a <a href="https://en.cppreference.com/w/cpp/thread/future">std::<wbr />future</a> to acquire the result or synchronize the execution. The example below creates three asynchronous tasks, <code>A</code>, <code>B</code>, and <code>C</code>, in which task <code>C</code> runs after task <code>A</code> and task <code>B</code>.</p><pre class="m-code"><span class="n">executor</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">tg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">executor</span><span class="p">.</span><span class="n">task_group</span><span class="p">();</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;A</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}),</span>
<span class="w">    </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">([](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">})</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span>
<span class="w">    </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C runs after A and B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">end</span><span class="p">()</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="n">tg</span><span class="p">.</span><span class="n">corun</span><span class="p">();</span><span class="w">  </span><span class="c1">// corun until all dependent-async tasks finish</span>
<span class="p">});</span><span class="w"> </span></pre>
          </div></section>
          <section class="m-doc-details" id="ac00237c032d82e008cdd7a8080dcdee8"><div>
            <h3>
              <div class="m-doc-template">
                template&lt;typename P, typename F, typename I, std::enable_if_t&lt;<a href="namespacetf.html#ad3a41adc2499a9519da3e77dc3e9849c" class="m-doc">is_<wbr />task_<wbr />params_<wbr />v</a>&lt;P&gt; &amp;&amp; !std::is_same_v&lt;std::decay_t&lt;I&gt;, <a href="classtf_1_1AsyncTask.html" class="m-doc">AsyncTask</a>&gt;, void&gt;* = nullptr&gt;
              </div>
              <span class="m-doc-wrap-bumper"><a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> tf::<wbr />TaskGroup::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#ac00237c032d82e008cdd7a8080dcdee8" class="m-doc-self">silent_dependent_async</a>(</span><span class="m-doc-wrap">P&amp;&amp; params,
              F&amp;&amp; func,
              I first,
              I last)</span></span>
            </h3>
            <p>runs the given function asynchronously when the given range of predecessors finish</p>
            <table class="m-table m-fullwidth m-flat">
              <thead>
                <tr><th colspan="2">Template parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td style="width: 1%">F</td>
                  <td>callable type</td>
                </tr>
                <tr>
                  <td>I</td>
                  <td>iterator type</td>
                </tr>
              </tbody>
              <thead>
                <tr><th colspan="2">Parameters</th></tr>
              </thead>
              <tbody>
                <tr>
                  <td>params</td>
                  <td>tasks parameters</td>
                </tr>
                <tr>
                  <td>func</td>
                  <td>callable object</td>
                </tr>
                <tr>
                  <td>first</td>
                  <td>iterator to the beginning (inclusive)</td>
                </tr>
                <tr>
                  <td>last</td>
                  <td>iterator to the end (exclusive)</td>
                </tr>
              </tbody>
              <tfoot>
                <tr>
                  <th>Returns</th>
                  <td>a <a href="classtf_1_1AsyncTask.html" class="m-doc">tf::<wbr />AsyncTask</a> handle</td>
                </tr>
              </tfoot>
            </table>
<p>This member function is more efficient than <a href="#af6ff72a4019da86f2234bea66a6abb98" class="m-doc">tf::<wbr />TaskGroup::<wbr />dependent_async</a> and is encouraged to use when you do not want a <a href="https://en.cppreference.com/w/cpp/thread/future">std::<wbr />future</a> to acquire the result or synchronize the execution. The example below creates three asynchronous tasks, <code>A</code>, <code>B</code>, and <code>C</code>, in which task <code>C</code> runs after task <code>A</code> and task <code>B</code>. Assigned task names will appear in the observers of the executor.</p><pre class="m-code"><span class="n">executor</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">tg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">executor</span><span class="p">.</span><span class="n">task_group</span><span class="p">();</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">tf</span><span class="o">::</span><span class="n">AsyncTask</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="o">&gt;</span><span class="w"> </span><span class="n">array</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;A</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">}),</span>
<span class="w">    </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">})</span>
<span class="w">  </span><span class="p">};</span>
<span class="w">  </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_dependent_async</span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;C&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[](){</span><span class="w"> </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;C runs after A and B</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">},</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">array</span><span class="p">.</span><span class="n">end</span><span class="p">()</span>
<span class="w">  </span><span class="p">);</span>
<span class="w">  </span><span class="n">tg</span><span class="p">.</span><span class="n">corun</span><span class="p">();</span><span class="w">  </span><span class="c1">// corun until all dependent-async tasks finish</span>
<span class="p">});</span><span class="w"> </span></pre>
          </div></section>
          <section class="m-doc-details" id="a1f481dc466e3107a08346d1a124677bc"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void tf::<wbr />TaskGroup::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a1f481dc466e3107a08346d1a124677bc" class="m-doc-self">corun</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>corun all tasks spawned by this task group with other workers</p>
<p>Coruns all tasks spawned by this task group cooperatively with other workers in the same executor until all these tasks finish. Under cooperative execution, a worker is not preempted. Instead, it continues participating in the work-stealing loop, executing available tasks alongside other workers.<br /></p><pre class="m-code"><span class="n">executor</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">tg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">executor</span><span class="p">.</span><span class="n">task_group</span><span class="p">();</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">counter</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="w">  </span><span class="c1">// spawn 100 async tasks and wait</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span><span class="w"> </span><span class="n">counter</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">tg</span><span class="p">.</span><span class="n">corun</span><span class="p">();</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// spawn another 100 async tasks and wait</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span><span class="w"> </span><span class="n">counter</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">tg</span><span class="p">.</span><span class="n">corun</span><span class="p">();</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">counter</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">200</span><span class="p">);</span>
<span class="p">});</span></pre><p>Note that only the parent worker of this task group (the worker who creates it) can call this corun.</p>
          </div></section>
          <section class="m-doc-details" id="a2d32e816db51666b721d8b3d538e4066"><div>
            <h3>
              <span class="m-doc-wrap-bumper">void tf::<wbr />TaskGroup::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a2d32e816db51666b721d8b3d538e4066" class="m-doc-self">cancel</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>cancel all tasks in this task group</p>
<p>Marks the task group as cancelled to stop any not-yet-started tasks in the group from running. Tasks that are already running will continue to completion, but no new tasks belonging to the task group will be scheduled after cancellation.</p><p>This example below demonstrates how <a href="#a2d32e816db51666b721d8b3d538e4066" class="m-doc">tf::<wbr />TaskGroup::<wbr />cancel()</a> prevents pending tasks in a task group from executing, while allowing already running tasks to complete cooperatively. The first set of tasks deliberately occupies all but one worker thread, ensuring that subsequently spawned tasks remain pending. After invoking <a href="#a2d32e816db51666b721d8b3d538e4066" class="m-doc">tf::<wbr />TaskGroup::<wbr />cancel()</a>, these pending tasks are never scheduled, even after the blocked workers are released. A final call to <a href="#a1f481dc466e3107a08346d1a124677bc" class="m-doc">tf::<wbr />TaskGroup::<wbr />corun()</a> synchronizes with all tasks in the group, guaranteeing safe completion and verifying that cancellation successfully suppresses task execution.</p><pre class="m-code"><span class="k">const</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">12</span><span class="p">;</span><span class="w">  </span><span class="c1">// must be &gt;1 for this example to work</span>
<span class="n">tf</span><span class="o">::</span><span class="n">Executor</span><span class="w"> </span><span class="nf">executor</span><span class="p">(</span><span class="n">W</span><span class="p">);</span>

<span class="n">executor</span><span class="p">.</span><span class="n">async</span><span class="p">([</span><span class="o">&amp;</span><span class="n">executor</span><span class="p">,</span><span class="w"> </span><span class="n">W</span><span class="p">](){</span>

<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">tg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">executor</span><span class="p">.</span><span class="n">task_group</span><span class="p">();</span>

<span class="w">  </span><span class="c1">// deliberately block the other W-1 workers</span>
<span class="w">  </span><span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="w"> </span><span class="n">latch</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">W</span><span class="mi">-1</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">tg</span><span class="p">.</span><span class="n">async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
<span class="w">      </span><span class="o">++</span><span class="n">latch</span><span class="p">;</span>
<span class="w">      </span><span class="k">while</span><span class="p">(</span><span class="n">latch</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">});</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// wait until the other W-1 workers are blocked</span>
<span class="w">  </span><span class="k">while</span><span class="p">(</span><span class="n">latch</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">W</span><span class="mi">-1</span><span class="p">);</span>

<span class="w">  </span><span class="c1">// spawn other tasks which should never run after cancellation</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">tg</span><span class="p">.</span><span class="n">async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span><span class="w"> </span><span class="k">throw</span><span class="w"> </span><span class="n">std</span><span class="o">::</span><span class="n">runtime_error</span><span class="p">(</span><span class="s">&quot;this should never run&quot;</span><span class="p">);</span><span class="w"> </span><span class="p">});</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span>
<span class="w">  </span><span class="c1">// cancel the task group and unblock the other W-1 workers</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">tg</span><span class="p">.</span><span class="n">is_cancelled</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">  </span><span class="n">tg</span><span class="p">.</span><span class="n">cancel</span><span class="p">();</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">tg</span><span class="p">.</span><span class="n">is_cancelled</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">true</span><span class="p">);</span>
<span class="w">  </span><span class="n">latch</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">  </span><span class="n">tg</span><span class="p">.</span><span class="n">corun</span><span class="p">();</span>
<span class="p">});</span></pre><p>Note that cancellation is cooperative: tasks should not assume immediate termination. Users must still call <a href="#a1f481dc466e3107a08346d1a124677bc" class="m-doc">tf::<wbr />TaskGroup::<wbr />corun()</a> to synchronize with all spawned tasks and ensure safe completion or cancellation. Failing to do so results in undefined behavior.</p>
          </div></section>
          <section class="m-doc-details" id="aa199904b8123c345df37df4360950fa7"><div>
            <h3>
              <span class="m-doc-wrap-bumper">bool tf::<wbr />TaskGroup::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#aa199904b8123c345df37df4360950fa7" class="m-doc-self">is_cancelled</a>(</span><span class="m-doc-wrap">)</span></span>
            </h3>
            <p>queries if the task group has been cancelled</p>
            <table class="m-table m-fullwidth m-flat">
              <tfoot>
                <tr>
                  <th style="width: 1%">Returns</th>
                  <td><code>true</code> if the task group has been marked as cancelled or <code>false</code> otherwise</td>
                </tr>
              </tfoot>
            </table>
<p>This method returns <code>true</code> if the task group has been marked as cancelled via a call to <code><a href="#a2d32e816db51666b721d8b3d538e4066" class="m-doc">cancel()</a></code>, and <code>false</code> otherwise.</p><pre class="m-code"><span class="n">executor</span><span class="p">.</span><span class="n">async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">tg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">executor</span><span class="p">.</span><span class="n">task_group</span><span class="p">();</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">tg</span><span class="p">.</span><span class="n">is_cancelled</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">  </span><span class="n">tg</span><span class="p">.</span><span class="n">cancel</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">tg</span><span class="p">.</span><span class="n">is_cancelled</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="p">});</span></pre><p>The cancellation state reflects whether the task group is currently in a cancelled state and does not imply that all tasks have completed or been synchronized. If a task group spawns any task, users must still call <code><a href="#a1f481dc466e3107a08346d1a124677bc" class="m-doc">corun()</a></code> to synchronize with all spawned tasks and ensure safe completion or cancellation. Failing to do so results in undefined behavior.</p>
          </div></section>
          <section class="m-doc-details" id="a2ff79bbacb724a4e99f3a65030bbd402"><div>
            <h3>
              <span class="m-doc-wrap-bumper">size_t tf::<wbr />TaskGroup::<wbr /></span><span class="m-doc-wrap"><span class="m-doc-wrap-bumper"><a href="#a2ff79bbacb724a4e99f3a65030bbd402" class="m-doc-self">size</a>(</span><span class="m-doc-wrap">) const</span></span>
            </h3>
            <p>queries the number of tasks currently in this task group</p>
            <table class="m-table m-fullwidth m-flat">
              <tfoot>
                <tr>
                  <th style="width: 1%">Returns</th>
                  <td>the number of tasks currently in this task group</td>
                </tr>
              </tfoot>
            </table>
<p>This method returns the number of tasks that belong to the task group at the time of the call. The returned value represents a snapshot and may become outdated immediately, as tasks can be concurrently spawned, started, completed, or canceled while this method is executing. As a result, the value returned by <code><a href="#a2ff79bbacb724a4e99f3a65030bbd402" class="m-doc">size()</a></code> should be used for informational or diagnostic purposes only and must not be relied upon for synchronization or correctness.</p><pre class="m-code"><span class="n">executor</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([</span><span class="o">&amp;</span><span class="p">](){</span>
<span class="w">  </span><span class="k">auto</span><span class="w"> </span><span class="n">tg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">executor</span><span class="p">.</span><span class="n">task_group</span><span class="p">();</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">tg</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="k">for</span><span class="p">(</span><span class="kt">size_t</span><span class="w"> </span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="mi">1000</span><span class="p">;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">tg</span><span class="p">.</span><span class="n">silent_async</span><span class="p">([](){});</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">assert</span><span class="p">(</span><span class="n">tg</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">  </span><span class="n">tg</span><span class="p">.</span><span class="n">corun</span><span class="p">();</span>
<span class="p">});</span></pre>
          </div></section>
        </section>
      </div>
    </div>
  </div>
</article></main>
<div class="m-doc-search" id="search">
  <a href="#!" onclick="return hideSearch()"></a>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-m-8 m-push-m-2">
        <div class="m-doc-search-header m-text m-small">
          <div><span class="m-label m-default">Tab</span> / <span class="m-label m-default">T</span> to search, <span class="m-label m-default">Esc</span> to close</div>
          <div id="search-symbolcount">&hellip;</div>
        </div>
        <div class="m-doc-search-content">
          <form>
            <input type="search" name="q" id="search-input" placeholder="Loading &hellip;" disabled="disabled" autofocus="autofocus" autocomplete="off" spellcheck="false" />
          </form>
          <noscript class="m-text m-danger m-text-center">Unlike everything else in the docs, the search functionality <em>requires</em> JavaScript.</noscript>
          <div id="search-help" class="m-text m-dim m-text-center">
            <p class="m-noindent">Search for symbols, directories, files, pages or
            modules. You can omit any prefix from the symbol or file path; adding a
            <code>:</code> or <code>/</code> suffix lists all members of given symbol or
            directory.</p>
            <p class="m-noindent">Use <span class="m-label m-dim">&darr;</span>
            / <span class="m-label m-dim">&uarr;</span> to navigate through the list,
            <span class="m-label m-dim">Enter</span> to go.
            <span class="m-label m-dim">Tab</span> autocompletes common prefix, you can
            copy a link to the result using <span class="m-label m-dim"></span>
            <span class="m-label m-dim">L</span> while <span class="m-label m-dim"></span>
            <span class="m-label m-dim">M</span> produces a Markdown link.</p>
          </div>
          <div id="search-notfound" class="m-text m-warning m-text-center">Sorry, nothing was found.</div>
          <ul id="search-results"></ul>
        </div>
      </div>
    </div>
  </div>
</div>
<script src="search-v2.js"></script>
<script src="searchdata-v2.js" async="async"></script>
<footer><nav>
  <div class="m-container">
    <div class="m-row">
      <div class="m-col-l-10 m-push-l-1">
        <p>Taskflow handbook is part of the <a href="https://taskflow.github.io">Taskflow project</a>, copyright  <a href="https://tsung-wei-huang.github.io/">Dr. Tsung-Wei Huang</a>, 2018&ndash;2026.<br />Generated by <a href="https://doxygen.org/">Doxygen</a> 1.9.1 and <a href="https://mcss.mosra.cz/">m.css</a>.</p>
      </div>
    </div>
  </div>
</nav></footer>
</body>
</html>
